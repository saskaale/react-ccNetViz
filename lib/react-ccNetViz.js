(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define("react-ccNetViz", ["react"], factory);
	else if(typeof exports === 'object')
		exports["react-ccNetViz"] = factory(require("react"));
	else
		root["react-ccNetViz"] = factory(root["React"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ccnetviz/dist/ccNetViz.js":
/*!************************************************!*\
  !*** ./node_modules/ccnetviz/dist/ccNetViz.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ccNetViz = __webpack_require__(1);
	
	var _ccNetViz2 = _interopRequireDefault(_ccNetViz);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: AleÅ¡ Saska - http://alessaska.cz/
	 */
	
	var ccNetVizMultiLevel = function ccNetVizMultiLevel(canvas, options) {
	  var vizScreen = new _ccNetViz2.default(canvas, options);
	  var vizLayout;
	
	  var history = [];
	  var curlevel = {};
	
	  var onContextMenu, onClick;
	
	  //right click >> go back
	  canvas.addEventListener('contextmenu', onContextMenu = function onContextMenu(e) {
	    if (history.length > 0) {
	      var histel = history.pop();
	
	      //currently shown level
	      curlevel = histel;
	
	      vizScreen.set(curlevel.nodes, curlevel.edges);
	      vizScreen.draw();
	    }
	
	    e.preventDefault();
	  });
	
	  canvas.addEventListener('click', onClick = function onClick(e) {
	    var bb = canvas.getBoundingClientRect();
	
	    var x = e.clientX - bb.left;
	    var y = e.clientY - bb.top;
	    var radius = 5;
	
	    var lCoords = vizScreen.getLayerCoords({ radius: radius, x: x, y: y });
	    var result = vizScreen.find(lCoords.x, lCoords.y, lCoords.radius, true, false);
	    if (result.nodes.length > 0) {
	      var node = result.nodes[0].node;
	
	      var layout = node.layout || vizLayout;
	      if (node.__computedLayout) {
	        //it is not nessesary to recompute layout if it was yet computed on this subgraph
	        layout = undefined;
	      } else {
	        //we store that layout was once computed for this subgraph
	        node.__computedLayout = true;
	      }
	
	      if (node.nodes && node.edges) {
	        var insidenodes = node.nodes;
	        var insideedges = node.edges;
	
	        history.push(curlevel);
	
	        curlevel = { nodes: insidenodes, edges: insideedges };
	
	        vizScreen.set(curlevel.nodes, curlevel.edges, layout);
	        vizScreen.draw();
	      }
	    }
	  });
	
	  ////TODO: Add interactivity functios into this class
	
	  this.remove = function () {
	    canvas.removeEventListener('contextmenu', onContextMenu);
	    canvas.removeEventListener('click', onClick);
	    vizScreen.remove();
	  };
	
	  this.set = function (nodes, edges, layout) {
	    curlevel = { nodes: nodes, edges: edges };
	    history = [];
	
	    vizLayout = layout;
	    vizScreen.set.apply(vizScreen, arguments);
	  };
	
	  var exposeMethods = ['find', 'findArea', 'getLayerCoords', 'draw', 'resetView', 'setViewport', 'update', 'resetView'];
	  var self = this;
	  exposeMethods.forEach(function (method) {
	    (function (method, self) {
	      self[method] = function () {
	        return vizScreen[method].apply(vizScreen, arguments);
	      };
	    })(method, self);
	  });
	};
	
	window.ccNetVizMultiLevel = ccNetVizMultiLevel;
	
	exports.default = ccNetVizMultiLevel;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _layer = __webpack_require__(2);
	
	var _layer2 = _interopRequireDefault(_layer);
	
	var _layout = __webpack_require__(9);
	
	var _layout2 = _interopRequireDefault(_layout);
	
	var _gl = __webpack_require__(4);
	
	var _gl2 = _interopRequireDefault(_gl);
	
	var _color = __webpack_require__(3);
	
	var _color2 = _interopRequireDefault(_color);
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _textures = __webpack_require__(32);
	
	var _textures2 = _interopRequireDefault(_textures);
	
	var _files = __webpack_require__(33);
	
	var _files2 = _interopRequireDefault(_files);
	
	var _texts = __webpack_require__(34);
	
	var _texts2 = _interopRequireDefault(_texts);
	
	var _lazyEvents = __webpack_require__(42);
	
	var _lazyEvents2 = _interopRequireDefault(_lazyEvents);
	
	var _interactivityBatch = __webpack_require__(43);
	
	var _interactivityBatch2 = _interopRequireDefault(_interactivityBatch);
	
	var _spatialSearch = __webpack_require__(29);
	
	var _spatialSearch2 = _interopRequireDefault(_spatialSearch);
	
	var _primitiveTools = __webpack_require__(8);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: 
	 *  David Tichy
	 *    AleÅ¡ Saska - http://alessaska.cz/
	 */
	
	var sCanvas = document.createElement("canvas");
	function getContext(canvas) {
	  var attributes = { depth: false, antialias: false };
	  var gl = canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl', attributes);
	
	  return gl;
	}
	
	var lastUniqId = 0;
	
	function checkUniqId(el) {
	  if (el.__uniqid !== undefined) {
	    el.uniqid = el.__uniqid;
	    delete el.__uniqid;
	  } else if (el.uniqid === undefined) {
	    el.uniqid = ++lastUniqId;
	  }
	}
	
	function mergeArrays(a, b, cmp) {
	  var r = [];
	  r.length = a.length + b.length;
	
	  var i = 0,
	      j = 0,
	      k = 0;
	
	  while (i < a.length && j < b.length) {
	    if (cmp(a[i], b[j]) < 0) r[k++] = a[i++];else r[k++] = b[j++];
	  }
	
	  while (i < a.length) {
	    r[k++] = a[i++];
	  }while (j < b.length) {
	    r[k++] = b[j++];
	  }return r;
	}
	
	var ccNetViz = function ccNetViz(canvas, options) {
	  var _this = this;
	
	  var self = this;
	  canvas = canvas || sCanvas;
	
	  var backgroundStyle = options.styles.background = options.styles.background || {};
	  var backgroundColor = new _color2.default(backgroundStyle.color || "rgb(255, 255, 255)");
	
	  var removed = false;
	  var setted = false;
	
	  var nodeStyle = options.styles.node = options.styles.node || {};
	  nodeStyle.minSize = nodeStyle.minSize != null ? nodeStyle.minSize : 6;
	  nodeStyle.maxSize = nodeStyle.maxSize || 16;
	  nodeStyle.color = nodeStyle.color || "rgb(255, 255, 255)";
	
	  if (nodeStyle.label) {
	    var s = nodeStyle.label;
	    s.color = s.color || "rgb(120, 120, 120)";
	    s.font = s.font || { type: "Arial, Helvetica, sans-serif", size: 11 };
	  }
	
	  var edgeStyle = options.styles.edge = options.styles.edge || {};
	  edgeStyle.width = edgeStyle.width || 1;
	  edgeStyle.color = edgeStyle.color || "rgb(204, 204, 204)";
	
	  var onLoad = function onLoad() {
	    if (!options.onLoad || options.onLoad()) {
	      _this.draw(true);
	    }
	  };
	
	  if (edgeStyle.arrow) {
	    var _s = edgeStyle.arrow;
	    _s.minSize = _s.minSize != null ? _s.minSize : 6;
	    _s.maxSize = _s.maxSize || 12;
	    _s.aspect = 1;
	  }
	
	  var events = new _lazyEvents2.default();
	  var layers = {};
	  var view = void 0,
	      gl = void 0,
	      drawFunc = void 0,
	      textures = void 0,
	      files = void 0,
	      texts = void 0;
	  var context = {};
	
	  this.cntShownNodes = function () {
	    var n = 0;
	    for (var k in layers) {
	      n += layers[k].cntShownNodes();
	    }return n;
	  };
	  var getNodesCnt = options.getNodesCnt || this.cntShownNodes;
	
	  this.cntShownEdges = function () {
	    var e = 0;
	    for (var k in layers) {
	      e += layers[k].cntShownEdges();
	    }return e;
	  };
	  var getEdgesCnt = options.getEdgesCnt || this.cntShownEdges;
	
	  var onRedraw = events.debounce(function () {
	    self.draw.call(self);
	    return false;
	  }, 5);
	
	  function checkRemoved() {
	    if (removed) {
	      console.error("Cannot call any function on graph after remove()");
	      return true;
	    }
	    return false;
	  }
	
	  var nodes = void 0,
	      edges = void 0;
	
	  function insertTempLayer() {
	    if (layers.temp) return;
	    layers.temp = new _layer2.default(canvas, context, view, gl, textures, files, texts, events, options, backgroundColor, nodeStyle, edgeStyle, getSize, getNodeSize, getLabelSize, getLabelHideSize, getNodesCnt, getEdgesCnt, onRedraw, onLoad);
	  }
	
	  var batch = undefined;
	  function getBatch() {
	    if (!batch) batch = new _interactivityBatch2.default(layers, insertTempLayer, drawFunc, nodes, edges, checkUniqId);
	    return batch;
	  };
	
	  this.set = function (n, e, layout) {
	    var layout_options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	
	    if (checkRemoved()) return _this;
	
	    nodes = n || [];
	    edges = e || [];
	
	    nodes.forEach(checkUniqId);
	    edges.forEach(checkUniqId);
	
	    layers.temp && layers.temp.set([], [], layout, layout_options);
	    layers.main.set(nodes, edges, layout, layout_options);
	
	    //reset batch
	    batch = undefined;
	    setted = true;
	    return _this;
	  };
	
	  //make all dynamic changes static
	  this.reflow = function () {
	    if (checkRemoved()) return;
	
	    getBatch().applyChanges();
	
	    //nodes and edges in dynamic chart are actual
	    var n = layers.main.getVisibleNodes();
	    if (layers.temp) n = n.concat(layers.temp.getVisibleNodes());
	
	    var e = layers.main.getVisibleEdges();
	    if (layers.temp) e = e.concat(layers.temp.getVisibleEdges());
	
	    _this.set(n, e);
	    _this.draw();
	  };
	
	  this.removeNode = function (n) {
	    if (checkRemoved()) {
	      return _this;
	    }getBatch().removeNode(n);return _this;
	  };
	  this.removeEdge = function (e) {
	    if (checkRemoved()) {
	      return _this;
	    }getBatch().removeEdge(e);return _this;
	  };
	  this.addEdge = function (e) {
	    if (checkRemoved()) {
	      return _this;
	    }getBatch().addEdge(e);return _this;
	  };
	  this.addNode = function (n) {
	    if (checkRemoved()) {
	      return _this;
	    }getBatch().addNode(n);return _this;
	  };
	  this.updateNode = function (n) {
	    if (checkRemoved()) {
	      return _this;
	    }return _this.removeNode(n).addNode(n);
	  };
	  this.updateEdge = function (e) {
	    if (checkRemoved()) {
	      return _this;
	    }return _this.removeEdge(e).addEdge(e);
	  };
	  this.applyChanges = function () {
	    if (checkRemoved()) {
	      return _this;
	    }getBatch().applyChanges();return _this;
	  };
	
	  this.addEdges = function (edges) {
	    if (checkRemoved()) return _this;
	
	    edges.forEach(function (e) {
	      _this.addEdge(e);
	    });
	
	    return _this;
	  };
	
	  this.addNodes = function (nodes) {
	    if (checkRemoved()) return _this;
	
	    nodes.forEach(function (n) {
	      _this.addNode(n);
	    });
	
	    return _this;
	  };
	
	  this.removeEdges = function (edges) {
	    if (checkRemoved()) return _this;
	
	    edges.forEach(function (e) {
	      _this.removeEdge(e);
	    });
	    return _this;
	  };
	
	  this.removeNodes = function (nodes) {
	    if (checkRemoved()) return _this;
	
	    nodes.forEach(function (n) {
	      _this.removeNode(n);
	    });
	    return _this;
	  };
	
	  this.updateNodes = function (nodes) {
	    if (checkRemoved()) return _this;
	
	    nodes.forEach(function (n) {
	      _this.updateNode(n);
	    });
	
	    return _this;
	  };
	
	  this.updateEdges = function (edges) {
	    if (checkRemoved()) return _this;
	
	    edges.forEach(function (e) {
	      _this.updateEdge(e);
	    });
	
	    return _this;
	  };
	
	  var getSize = function getSize(c, s, n, sc) {
	    var result = sc * Math.sqrt(c.width * c.height / (n + 1)) / view.size;
	    if (s) {
	      var min = s.size ? s.size : s.minSize;
	      var max = s.size ? s.size : s.maxSize;
	
	      result = max ? Math.min(max, result) : result;
	      if (result < s.hideSize) return 0;
	      result = min ? Math.max(min, result) : result;
	    }
	    return result;
	  };
	
	  var getNodeSize = function getNodeSize(c) {
	    return getSize(c, c.style, getNodesCnt(), 0.4);
	  };
	  var getLabelSize = function getLabelSize(c, s) {
	    return getSize(c, s, getNodesCnt(), 0.25);
	  };
	
	  var getLabelHideSize = function getLabelHideSize(c, s) {
	    if (s) {
	      var sc = 0.25;
	      var n = layers.main.cntShownNodes(); //lower bound
	      var t = sc * Math.sqrt(c.width * c.height / (n + 1));
	
	      var vs = void 0;
	      if (s.hideSize) {
	        vs = t / s.hideSize;
	        if (s.maxSize) vs = Math.min(vs, t / s.maxSize);
	        return vs;
	      }
	    }
	
	    return 1;
	  };
	
	  var offset = 0.5 * nodeStyle.maxSize;
	
	  this.draw = function (silent) {
	    if (silent && (removed || !setted)) return;
	    if (checkRemoved()) return;
	
	    var width = canvas.width;
	    var height = canvas.height;
	    var aspect = width / height;
	    var o = view.size === 1 ? offset : 0;
	    var ox = o / width;
	    var oy = o / height;
	
	    context.transform = _gl2.default.ortho(view.x - ox, view.x + view.size + ox, view.y - oy, view.y + view.size + oy, -1, 1);
	    context.offsetX = ox;
	    context.offsetY = oy;
	    context.width = 0.5 * width;
	    context.height = 0.5 * height;
	    context.aspect2 = aspect * aspect;
	    context.aspect = aspect;
	    context.count = getNodesCnt();
	
	    //bad hack because we use different size for curveExc and for nodeSize :(
	    if (context.style) delete context.style;
	    context.curveExc = getSize(context, undefined, getEdgesCnt(), 0.5);
	    context.style = nodeStyle;
	    context.nodeSize = getNodeSize(context);
	
	    gl && gl.viewport(0, 0, width, height);
	
	    gl && gl.clear(gl.COLOR_BUFFER_BIT);
	
	    for (var i = 0; i < layers.main.scene.elements.length; i++) {
	      layers.main.scene.elements[i].draw(context);
	      layers.temp && layers.temp.scene.elements[i].draw(context);
	    }
	  };
	  drawFunc = this.draw.bind(this);
	
	  this.getScreenCoords = function (conf) {
	    if (checkRemoved()) return;
	    var ret = {};
	    var rect = canvas.getBoundingClientRect();
	    if (conf.x !== undefined) ret.x = (conf.x - view.x + context.offsetX) / (view.size + 2 * context.offsetX) * canvas.width + rect.left;
	    if (conf.y !== undefined) ret.y = (1 - (conf.y - view.y + context.offsetY) / (view.size + 2 * context.offsetY)) * canvas.height + rect.top;
	    return ret;
	  };
	
	  this.getLayerCoords = function (conf) {
	    if (checkRemoved()) return;
	
	    var ret = {};
	
	    ['x', 'x1', 'x2'].forEach(function (k) {
	      if (conf[k] !== undefined) {
	        var x = conf[k];
	        x = x / canvas.width * (view.size + 2 * context.offsetX) - context.offsetX + view.x;
	        ret[k] = x;
	      }
	    });
	
	    ['y', 'y1', 'y2'].forEach(function (k) {
	      if (conf[k] !== undefined) {
	        var y = conf[k];
	        y = (1 - y / canvas.height) * (view.size + 2 * context.offsetY) - context.offsetY + view.y;
	        ret[k] = y;
	      }
	    });
	
	    if (conf.radius !== undefined) {
	      var dist = conf.radius;
	
	      var disth = dist / canvas.height;
	      var distw = dist / canvas.width;
	      dist = Math.max(disth, distw) * view.size;
	
	      ret.radius = dist;
	    }
	
	    return ret;
	  };
	
	  var findMerge = function findMerge(funcname, args) {
	    if (checkRemoved() || !gl) return;
	
	    var f1 = layers.main[funcname].apply(layers.main, args);
	
	    if (!layers.temp) return f1;
	
	    var f2 = layers.temp[funcname].apply(layers.temp, args);
	
	    var r = {};
	    for (var key in f1) {
	      r[key] = mergeArrays(f1[key], f2[key], function (e1, e2) {
	        return e1.dist2 - e2.dist2;
	      });
	    }
	
	    return r;
	  };
	
	  this.find = function () {
	    return findMerge('find', arguments);
	  };
	  this.findArea = function () {
	    return findMerge('findArea', arguments);
	  };
	
	  this.getTextPosition = function (n) {
	    if (checkRemoved() || !gl) return;
	
	    var offset = 0.5 * context.nodeSize;
	    var offsety = (2.0 * (n.y <= 0.5 ? 0 : 1) - 1.0) * offset;
	
	    var ns = (0, _primitiveTools.getPartitionStyle)(options.styles[n.style], nodeStyle, "label");
	    var textEngine = texts.getEngine(ns.font);
	    textEngine.setFont(ns.font);
	
	    var wantedSize = textEngine.isSDF ? getLabelSize(context, ns.label || {}) : textEngine.fontSize;
	    var fontScale = wantedSize / textEngine.fontSize;if (wantedSize === 0) {
	      fontScale = 0;
	    };
	
	    return { offsetY: offsety, fontScale: fontScale, chars: textEngine.get(n.label, n.x, n.y) };
	  };
	
	  var addEvts = function addEvts(el, evts) {
	    for (var k in evts || {}) {
	      evts[k] && el.addEventListener(k, evts[k], { passive: options.passiveEvts });
	    }
	  };
	
	  var removeEvts = function removeEvts(el, evts) {
	    for (var k in evts || {}) {
	      evts[k] && el.removeEventListener(k, evts[k]);
	    }
	  };
	
	  var onDownThis = onMouseDown.bind(this);
	
	  var zoomevts = void 0;
	  addEvts(canvas, zoomevts = {
	    'mousedown': onDownThis,
	    'touchstart': onDownThis,
	    'wheel': onWheel.bind(this),
	    'contextmenu': options.onContextMenu
	  });
	
	  this.remove = function () {
	    if (checkRemoved()) return;
	
	    for (var k in layers) {
	      layers[k].remove();
	    }
	
	    if (gl) {
	      gl.viewport(0, 0, context.width * 2, context.height * 2);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	
	      var gl_lose = gl.getExtension('WEBGL_lose_context');
	      gl_lose && gl_lose.loseContext();
	    }
	
	    removeEvts(canvas, zoomevts);
	
	    events.disable();
	    texts && texts.remove();
	
	    removed = true;
	  };
	
	  var last_view = {};
	  function checkChangeViewport() {
	    var is_change = false;
	    if (last_view) {
	      for (var k in view) {
	        if (last_view[k] !== view[k]) is_change = true;
	      }
	    }
	    _utils2.default.extend(last_view, view);
	
	    if (is_change) {
	      options.onChangeViewport && options.onChangeViewport(view);
	    }
	  }
	
	  function onContextMenu(e) {}
	
	  function onWheel(e) {
	    var rect = canvas.getBoundingClientRect();
	    var size = Math.min(1.0, view.size * (1 + 0.001 * (e.deltaMode ? 33 : 1) * e.deltaY));
	    var delta = size - view.size;
	
	    if (!options.passiveEvts) {
	      e.preventDefault();
	    }
	
	    var oldsize = view.size;
	    var oldx = view.x;
	    var oldy = view.y;
	
	    view.size = size;
	    view.x = Math.max(0, Math.min(1 - size, view.x - delta * (e.clientX - rect.left) / canvas.width));
	    view.y = Math.max(0, Math.min(1 - size, view.y - delta * (1 - (e.clientY - rect.top) / canvas.height)));
	
	    if (options.onZoom && options.onZoom(view) === false) {
	      view.size = oldsize;
	      view.x = oldx;
	      view.y = oldy;
	      return;
	    }
	
	    checkChangeViewport();
	
	    this.draw();
	  }
	
	  var lastUpTime = 0;
	  function onMouseDown(downe) {
	    var _this2 = this;
	
	    if (downe.which !== 1) return; //catch only 1 - left mouse button
	
	    var parseTouchEvts = function parseTouchEvts(e) {
	      if (!e.touches) return e;
	
	      var x = 0,
	          y = 0;
	      for (var i = 0; i < e.touches.length; i++) {
	        x += e.touches[i].clientX;y += e.touches[i].clientY;
	      }
	      e.clientX = x / e.touches.length;
	      e.clientY = y / e.touches.length;
	
	      return e;
	    };
	
	    downe = parseTouchEvts(downe);
	
	    var width = canvas.width / view.size;
	    var height = canvas.height / view.size;
	    var sx = downe.clientX;
	    var sy = downe.clientY;
	    var dx = view.x + sx / width;
	    var dy = sy / height - view.y;
	    var od = options.onDrag;
	    var dragged = void 0,
	        custom = void 0;
	    var panning = true;
	    var zooming = false;
	    var evts = void 0;
	
	    var origdist = void 0;
	    if ((downe.touches || []).length === 2) {
	      var mx = downe.touches[0].clientX - downe.touches[1].clientX,
	          my = downe.touches[0].clientY - downe.touches[1].clientY;
	      origdist = Math.sqrt(mx * mx + my * my);
	      zooming = true;
	    }
	
	    var drag = function drag(e) {
	      e = parseTouchEvts(e);
	
	      if (e.touches && e.touches.length != 1) panning = false;
	
	      if (dragged) {
	        if (panning) {
	          if (custom) {
	            od.drag && od.drag(e);
	          } else {
	            view.x = Math.max(0, Math.min(1 - view.size, dx - e.clientX / width));
	            view.y = Math.max(0, Math.min(1 - view.size, e.clientY / height - dy));
	            checkChangeViewport();
	            _this2.draw();
	          }
	        }
	      } else {
	        var x = void 0,
	            y = void 0;
	        if (e.touches && e.touches.length > 0) {
	          x = e.touches[0].clientX;y = e.touches[0].clientY;
	        } else {
	          x = e.clientX;y = e.clientY;
	        }
	
	        var _mx = x - sx;
	        var _my = y - sy;
	
	        if (_mx * _mx + _my * _my > 8) {
	          dragged = true;
	          custom = od && od.start(downe);
	          custom && od.drag && od.drag(e);
	        }
	      }
	      if (!options.passiveEvts) {
	        e.preventDefault();
	      }
	    };
	
	    var up = function up(e) {
	      e = parseTouchEvts(e);
	
	      custom && od.stop && od.stop(e);
	
	      if (!dragged) {
	        options.onClick && options.onClick(e);
	
	        if (new Date().getTime() - lastUpTime < 250) {
	          options.onDblClick && options.onDblClick(e);
	          lastUpTime = 0;
	        } else {
	          lastUpTime = new Date().getTime();
	        }
	      }
	
	      removeEvts(window, evts);
	    };
	
	    var zoom = function zoom(e) {
	      e = parseTouchEvts(e);
	
	      if (e.touches && e.touches.length == 2) {
	        var _mx2 = e.touches[0].clientX - e.touches[1].clientX,
	            _my2 = e.touches[0].clientY - e.touches[1].clientY;
	        var dist = Math.sqrt(_mx2 * _mx2 + _my2 * _my2);
	        e.deltaY = -(dist - origdist) * 5;
	        onWheelThis(e);
	        origdist = dist;
	      }
	    };
	
	    addEvts(window, evts = {
	      'mouseup': up,
	      'touchend': up,
	      'touchcancel': up,
	      'mousemove': zooming ? zoom : drag,
	      'touchmove': zooming ? zoom : drag
	    });
	  }
	
	  this.image = function () {
	    if (checkRemoved()) return;
	
	    return canvas.toDataURL();
	  };
	
	  this.resize = function () {
	    if (checkRemoved()) return;
	
	    canvas.width = canvas.offsetWidth;
	    canvas.height = canvas.offsetHeight;
	  };
	
	  this.getViewport = function () {
	    return view;
	  };
	
	  this.setViewport = function (v) {
	    if (checkRemoved()) return;
	
	    _utils2.default.extend(view, v);
	
	    checkChangeViewport();
	  };
	
	  this.resetView = function () {
	    return _this.setViewport({ size: 1, x: 0, y: 0 });
	  };
	
	  //expose these methods from layer into this class
	  ['update'].forEach(function (method) {
	    (function (method, self) {
	      self[method] = function () {
	        var args = arguments;
	        for (var k in layers) {
	          var l = layers[k];
	          l[method].apply(l, args);
	        };
	        return self;
	      };
	    })(method, self);
	  });
	
	  if (gl = getContext(canvas)) {
	    gl.clearColor(backgroundColor.r, backgroundColor.g, backgroundColor.b, backgroundColor.a);
	    gl.blendEquation(gl.FUNC_ADD);
	    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
	    gl.enable(gl.BLEND);
	  }
	
	  view = { size: 1, x: 0, y: 0 };
	
	  this.resize();
	
	  textures = new _textures2.default(events, onLoad);
	  files = new _files2.default(events, onLoad);
	  texts = gl && new _texts2.default(gl, files, textures);
	  layers.main = new _layer2.default(canvas, context, view, gl, textures, files, texts, events, options, backgroundColor, nodeStyle, edgeStyle, getSize, getNodeSize, getLabelSize, getLabelHideSize, getNodesCnt, getEdgesCnt, onRedraw, onLoad);
	
	  if (!gl) console.warn("Cannot initialize WebGL context");
	};
	
	ccNetViz.isWebGLSupported = function () {
	  return !!getContext(sCanvas);
	};
	
	ccNetViz.color = _color2.default;
	ccNetViz.spatialSearch = _spatialSearch2.default;
	ccNetViz.layout = _layout2.default;
	ccNetViz.color = _color2.default;
	
	window.ccNetViz = ccNetViz;
	exports.default = ccNetViz;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (canvas, context, view, gl, textures, files, texts, events, options, backgroundColor, nodeStyle, edgeStyle, getSize, getNodeSize, getLabelSize, getLabelHideSize, getNodesCnt, getEdgesCnt, onRedraw, onLoad) {
	    var _this = this;
	
	    getNodesCnt = getNodesCnt || function () {
	        return _this.nodes.length;
	    };
	    getEdgesCnt = getEdgesCnt || function () {
	        return _this.edges.length;
	    };
	
	    this.redraw = onRedraw || function () {};
	
	    options = options || {};
	    options.styles = options.styles || {};
	
	    var nodesFiller = function nodesFiller(style) {
	        return {
	            set: function set(v, e, iV, iI) {
	                var x = e.x;
	                var y = e.y;
	                _primitive2.default.vertices(v.position, iV, x, y, x, y, x, y, x, y);
	                _primitive2.default.vertices(v.textureCoord, iV, 0, 0, 1, 0, 1, 1, 0, 1);
	                if (v.color) {
	                    var c = e.color;
	                    _primitive2.default.colors(v.color, iV, c, c, c, c);
	                }
	                _primitive2.default.quad(v.indices, iV, iI);
	            } };
	    };
	    var labelsFiller = function labelsFiller(style) {
	        return function (style) {
	            var textEngine = texts.getEngine(style.font);
	
	            textEngine.setFont(style.font);
	
	            return {
	                set: function set(v, e, iV, iI) {
	                    var x = e.x;
	                    var y = e.y;
	
	                    var ret = false;
	                    var parts = textEngine.get(e.label || "", x, y, function () {
	                        ret = true;
	                    });
	                    for (var i = 0; i < parts.length; i++, iV += 4, iI += 6) {
	                        var c = parts[i];
	
	                        _primitive2.default.vertices(v.position, iV, x, y, x, y, x, y, x, y);
	                        _primitive2.default.vertices(v.relative, iV, c.dx, c.dy, c.width + c.dx, c.dy, c.width + c.dx, c.height + c.dy, c.dx, c.height + c.dy);
	                        _primitive2.default.vertices(v.textureCoord, iV, c.left, c.bottom, c.right, c.bottom, c.right, c.top, c.left, c.top);
	                        _primitive2.default.quad(v.indices, iV, iI);
	                    }
	
	                    return ret;
	                },
	                size: function size(v, e) {
	                    return textEngine.steps(e.label || "");
	                }
	            };
	        }(style);
	    };
	
	    var normalize = function normalize(a, b) {
	        var x = b.x - a.x;
	        var y = b.y - a.y;
	        var sc = 1 / Math.sqrt(x * x + y * y);
	        return { x: sc * x, y: sc * y };
	    };
	
	    var dx = Math.cos(0.9);
	    var dy = Math.sin(0.9);
	
	    var ct1 = {},
	        ct2 = {},
	        ct = {};
	    var setVerticeCurveShift = function setVerticeCurveShift(v, iV, s, t) {
	        var csx = void 0,
	            csy = void 0,
	            ctx = void 0,
	            cty = void 0,
	            cisx = void 0,
	            cisy = void 0,
	            sisy = void 0,
	            citx = void 0,
	            city = void 0;
	        _geomutils2.default.getCurveShift(t.e, ct1);
	        ctx = ct1.x;
	        cty = ct1.y;
	        citx = ct1.cx;
	        city = ct1.cy;
	
	        _geomutils2.default.getCurveShift(s.e, ct2);
	        csx = ct2.x;
	        csy = ct2.y;
	        cisx = ct2.cx;
	        cisy = ct2.cy;
	
	        v.curveShift && _primitive2.default.vertices(v.curveShift, iV, -csy, csx, -csy, csx, -cty, ctx, -cty, ctx);
	        v.circleShift && _primitive2.default.vertices(v.circleShift, iV, -cisy, cisx, -cisy, cisx, -city, citx, -city, citx);
	    };
	
	    var edgesFiller = {
	        'lines': function lines(style) {
	            return {
	                set: function set(v, e, iV, iI) {
	                    var s = _geomutils2.default.edgeSource(e);
	                    var t = _geomutils2.default.edgeTarget(e);
	                    var dx = s.x - t.x;
	                    var dy = s.y - t.y;
	                    var d = normalize(s, t);
	
	                    setVerticeCurveShift(v, iV, s, t);
	
	                    _primitive2.default.vertices(v.position, iV, s.x, s.y, s.x, s.y, t.x, t.y, t.x, t.y);
	                    _primitive2.default.vertices(v.lengthSoFar, iV, 0, 0, 0, 0, dx, dy, dx, dy);
	                    _primitive2.default.vertices(v.normal, iV, -d.y, d.x, d.y, -d.x, d.y, -d.x, -d.y, d.x);
	                    _primitive2.default.quad(v.indices, iV, iI);
	                } };
	        },
	        'curves': function curves(style) {
	            return {
	                numVertices: 3,
	                numIndices: 3,
	                set: function set(v, e, iV, iI) {
	                    var s = _geomutils2.default.edgeSource(e);
	                    var t = _geomutils2.default.edgeTarget(e);
	                    var dx = s.x - t.x;
	                    var dy = s.y - t.y;
	                    var d = normalize(s, t);
	
	                    setVerticeCurveShift(v, iV, s, t);
	
	                    _primitive2.default.vertices(v.position, iV, s.x, s.y, 0.5 * (t.x + s.x), 0.5 * (t.y + s.y), t.x, t.y);
	                    _primitive2.default.vertices(v.lengthSoFar, iV, 0, 0, dx / 2, dy / 2, dx, dy);
	                    _primitive2.default.vertices(v.normal, iV, 0, 0, d.y, -d.x, 0, 0);
	                    _primitive2.default.vertices(v.curve, iV, 1, 1, 0.5, 0.0, 0, 0);
	                    _primitive2.default.indices(v.indices, iV, iI, 0, 1, 2);
	                }
	            };
	        },
	        'circles': function circles(style) {
	            return {
	                set: function set(v, e, iV, iI) {
	                    var s = _geomutils2.default.edgeSource(e);
	                    var d = s.y < 0.5 ? 1 : -1;
	
	                    var xdiff1 = 0;
	                    var ydiff1 = 0;
	                    var xdiff2 = 1;
	                    var ydiff2 = d;
	                    var xdiff3 = 2;
	                    var ydiff3 = 1.25 * d;
	                    var xdiff4 = 3;
	                    var ydiff4 = 1.5 * d;
	
	                    setVerticeCurveShift(v, iV, s, s);
	
	                    _primitive2.default.vertices(v.position, iV, s.x, s.y, s.x, s.y, s.x, s.y, s.x, s.y);
	                    _primitive2.default.vertices(v.lengthSoFar, iV, xdiff1, ydiff1, xdiff2, ydiff2, xdiff3, ydiff3, xdiff4, ydiff4);
	                    _primitive2.default.vertices(v.normal, iV, 0, 0, 1, d, 0, 1.25 * d, -1, d);
	                    _primitive2.default.vertices(v.curve, iV, 1, 1, 0.5, 0, 0, 0, 0.5, 0);
	                    _primitive2.default.quad(v.indices, iV, iI);
	                }
	            };
	        }
	    };
	
	    var _set = function _set(v, e, s, t, iV, iI, dx, dy) {
	        var tx = t.x;
	        var ty = t.y;
	
	        var offsetMul = void 0;
	        var ctx = void 0,
	            cty = void 0,
	            citx = void 0,
	            city = void 0;
	
	        _geomutils2.default.getCurveShift(t.e, ct);
	        ctx = ct.x;
	        cty = ct.y;
	        citx = ct.cx;
	        city = ct.cy;
	
	        if (t.is_edge) {
	            //if target is edge, disable node offset for arrow
	            //normal of that edge
	            offsetMul = 0;
	        } else {
	            offsetMul = 1;
	        }
	        v.curveShift && _primitive2.default.vertices(v.curveShift, iV, -cty, ctx, -cty, ctx, -cty, ctx, -cty, ctx);
	        v.circleShift && _primitive2.default.vertices(v.circleShift, iV, -city, citx, -city, citx, -city, citx, -city, citx);
	
	        _primitive2.default.singles(v.offsetMul, iV, offsetMul, offsetMul, offsetMul, offsetMul);
	        _primitive2.default.vertices(v.position, iV, tx, ty, tx, ty, tx, ty, tx, ty);
	        _primitive2.default.vertices(v.direction, iV, dx, dy, dx, dy, dx, dy, dx, dy);
	        _primitive2.default.vertices(v.textureCoord, iV, 0, 0, 1, 0, 1, 1, 0, 1);
	        _primitive2.default.quad(v.indices, iV, iI);
	    };
	
	    var arrowFiller = {
	        lineArrows: function lineArrows(style) {
	            return {
	                set: function set(v, e, iV, iI) {
	                    var s = _geomutils2.default.edgeSource(e);
	                    var t = _geomutils2.default.edgeTarget(e);
	                    var d = normalize(s, t);
	                    _set(v, e, s, t, iV, iI, d.x, d.y);
	                } };
	        },
	        curveArrows: function curveArrows(style) {
	            return {
	                set: function set(v, e, iV, iI) {
	                    var s = _geomutils2.default.edgeSource(e);
	                    var t = _geomutils2.default.edgeTarget(e);
	                    return _set(v, e, s, t, iV, iI, 0.5 * (t.x - s.x), 0.5 * (t.y - s.y));
	                }
	            };
	        },
	        circleArrows: function circleArrows(style) {
	            return {
	                set: function set(v, e, iV, iI) {
	                    var t = _geomutils2.default.edgeTarget(e);
	                    var s = t;
	                    return _set(v, e, s, t, iV, iI, t.x < 0.5 ? dx : -dx, t.y < 0.5 ? -dy : dy);
	                }
	            };
	        }
	    };
	
	    this.getCurrentSpatialSearch = function (context) {
	        if (spatialSearch === undefined) {
	            spatialSearch = new _spatialSearch2.default(context, texts, options, [], {}, [], {}, [], {}, [], {}, normalize, nodeStyle, getLabelSize, getLabelHideSize);
	        }
	        return spatialSearch;
	    };
	
	    this.remove = function () {};
	
	    var edgeTypes = void 0;
	    var edgePoses = void 0;
	
	    var spatialSearch = undefined;
	
	    var lvl = 0;
	    //make sure everything (files and textures) are load, if not, redraw the whole graph after they became
	    var set_end = function set_end() {
	        var enableLazyRedraw = false;
	        var reset = function reset(p) {
	            if (enableLazyRedraw) _this.set(_this.nodes, _this.edges);
	        };
	        files.onLoad(reset);
	        textures.onLoad(reset);
	        enableLazyRedraw = true;
	    };
	
	    this.set = function (nodes, edges, layout, layout_options) {
	        removedNodes = 0;
	        removedEdges = 0;
	
	        this.nodes = nodes = nodes || [];
	        this.edges = edges = edges ? [].concat(edges) : [];
	
	        spatialSearch = undefined;
	
	        var lines = [],
	            curves = [],
	            circles = [];
	
	        //tanslate indexes into node objects
	        for (var i = 0; i < edges.length; i++) {
	            var e = edges[i];
	            if (typeof e.source == 'number') e.source = nodes[e.source];
	
	            if (typeof e.target == 'number') e.target = nodes[e.target];
	        }
	
	        var getIndex = function getIndex(e) {
	            return e.uniqid || -e.index || -e.nidx;
	        };
	
	        var init = function init() {
	            for (var _i = 0; _i < nodes.length; _i++) {
	                nodes[_i].index = _i;
	            }
	
	            for (var _i2 = 0, j = nodes.length + 10; _i2 < edges.length; _i2++, j++) {
	                edges[_i2].nidx = j;
	            }
	
	            edgeTypes = [];
	            edgePoses = new Uint32Array(edges.length);
	            var dummysd = { k: '_', kArrow: '_', d: [] };
	            var circlesd = { k: 'circles', kArrow: 'circleArrows', d: circles };
	            var linesd = { k: 'lines', kArrow: 'lineArrows', d: lines };
	            var curvesd = { k: 'curves', kArrow: 'curveArrows', d: curves };
	
	            if (extensions.OES_standard_derivatives) {
	                var map = {};
	                for (var _i3 = 0; _i3 < edges.length; _i3++) {
	                    var _e = edges[_i3];
	
	                    var si = getIndex(_e.source);
	                    var ti = getIndex(_e.target);
	
	                    (map[si] || (map[si] = {}))[ti] = true;
	                }
	
	                for (var _i4 = 0; _i4 < edges.length; _i4++) {
	                    var target = void 0,
	                        _e2 = edges[_i4];
	
	                    var _si = getIndex(_e2.source);
	                    var _ti = getIndex(_e2.target);
	
	                    var t = dummysd;
	                    if (_si === _ti) {
	                        _e2.t = 2; //circle
	                        target = circles;
	                        t = circlesd;
	                    } else {
	                        var m = map[_ti];
	                        if (m && m[_si]) {
	                            _e2.t = 1; //curve
	                            target = curves;
	                            t = curvesd;
	                        } else {
	                            _e2.t = 0; //line
	                            target = lines;
	                            t = linesd;
	                        }
	                    }
	                    edgeTypes.push(t);
	                    edgePoses[_i4] = t.d.length;
	                    target.push(_e2);
	                }
	            } else {
	                for (var _i5 = 0; _i5 < edges.length; _i5++) {
	                    var _e3 = edges[_i5];
	
	                    var _si2 = getIndex(_e3.source);
	                    var _ti2 = getIndex(_e3.target);
	
	                    var _t = dummysd;
	                    if (_si2 !== _ti2) {
	                        _t = linesd;
	                        _e3.t = 0;
	                        lines.push(_e3);
	                    }
	                    edgeTypes.push(_t);
	                    edgePoses[_i5] = _t.d.length;
	                }
	            }
	        };
	
	        init();
	
	        var nodesParts = (0, _primitiveTools.partitionByStyle)(nodes);
	        var circlesParts = (0, _primitiveTools.partitionByStyle)(circles);
	        var linesParts = (0, _primitiveTools.partitionByStyle)(lines);
	        var curvesParts = (0, _primitiveTools.partitionByStyle)(curves);
	
	        this.getCurrentSpatialSearch = function (context) {
	            if (spatialSearch === undefined) {
	                spatialSearch = new _spatialSearch2.default(context, texts, options, nodes, nodesParts, lines, linesParts, curves, curvesParts, circles, circlesParts, normalize, nodeStyle, getLabelSize, getLabelHideSize);
	            }
	            return spatialSearch;
	        };
	
	        layout && new _layout2.default[layout](nodes, edges, layout_options).apply() && _layout2.default.normalize(nodes);
	
	        if (!gl) return;
	
	        var tryInitPrimitives = function tryInitPrimitives() {
	            var isDirty = false;
	
	            var defaultAdder = function defaultAdder(section, addSection) {
	                if (typeof section.style.texture === 'string') section.style.texture = textures.get(gl, section.style.texture, addSection);else addSection();
	            };
	            var labelAdder = function labelAdder(section, addSection) {
	                var slf = (section.style.label || {}).font || {};
	                var textEngine = texts.getEngine(slf);
	                section.style.texture = textEngine.getTexture(slf, addSection);
	            };
	
	            var is = void 0;
	            is = nodes.length && !nodes[0].color;
	            isDirty = isDirty || scene.nodes.set(gl, options.styles, defaultAdder, is ? nodes : [], is ? nodesParts : {}, nodesFiller);
	            is = nodes.length && nodes[0].color;
	            isDirty = isDirty || scene.nodesColored.set(gl, options.styles, defaultAdder, is ? nodes : [], is ? nodesParts : {}, nodesFiller);
	
	            if (nodeStyle.label) {
	                texts.clear();
	                isDirty = isDirty || scene.labelsOutline.set(gl, options.styles, labelAdder, nodes, nodesParts, labelsFiller);
	                isDirty = isDirty || scene.labels.set(gl, options.styles, labelAdder, nodes, nodesParts, labelsFiller);
	                texts.bind();
	            }
	
	            isDirty = isDirty || scene.lines.set(gl, options.styles, defaultAdder, lines, linesParts, edgesFiller.lines);
	
	            if (extensions.OES_standard_derivatives) {
	                isDirty = isDirty || scene.curves.set(gl, options.styles, defaultAdder, curves, curvesParts, edgesFiller.curves);
	                isDirty = isDirty || scene.circles.set(gl, options.styles, defaultAdder, circles, circlesParts, edgesFiller.circles);
	            }
	
	            if (edgeStyle.arrow) {
	                isDirty = isDirty || scene.lineArrows.set(gl, options.styles, defaultAdder, lines, linesParts, arrowFiller.lineArrows);
	
	                if (extensions.OES_standard_derivatives) {
	                    isDirty = isDirty || scene.curveArrows.set(gl, options.styles, defaultAdder, curves, curvesParts, arrowFiller.curveArrows);
	
	                    isDirty = isDirty || scene.circleArrows.set(gl, options.styles, defaultAdder, circles, circlesParts, arrowFiller.circleArrows);
	                }
	            }
	
	            return isDirty;
	        };
	
	        while (tryInitPrimitives()) {} //loop until they are not dirty
	        set_end();
	    };
	
	    this.update = function (element, attribute, data) {
	        if (!gl) return;
	        scene[element].update(gl, attribute, data, function (style) {
	            return {
	                set: function set(v, e, iV) {
	                    return _primitive2.default.colors(v, iV, e, e, e, e);
	                }
	            };
	        });
	    };
	
	    this.find = function (x, y, dist, nodes, edges, labels) {
	        return _this.getCurrentSpatialSearch(context).find(context, x, y, dist, view.size, nodes, edges, labels);
	    };
	
	    this.findArea = function (x1, y1, x2, y2, nodes, edges, labels) {
	        return _this.getCurrentSpatialSearch(context).findArea(context, x1, y1, x2, y2, view.size, nodes, edges, labels);
	    };
	
	    this.updateNode = function (n, i) {
	        _this.nodes[i] = n;
	
	        if (spatialSearch) spatialSearch.update(context, 'nodes', i, n);
	
	        if (!gl) return;
	
	        (_this.nodes[0].color ? scene.nodesColored : scene.nodes).updateEl(gl, n, i, nodesFiller);
	        scene.labels && scene.labels.updateEl(gl, n, i, labelsFiller);
	        scene.labelsOutline && scene.labelsOutline.updateEl(gl, n, i, labelsFiller);
	    };
	
	    this.updateEdge = function (e, i) {
	        var t = edgeTypes[i];
	        var pos = edgePoses[i];
	
	        t.d[pos] = _this.edges[i] = e;
	
	        if (spatialSearch) spatialSearch.update(context, t.k, pos, e);
	
	        if (!gl) return;
	
	        scene[t.k].updateEl(gl, e, pos, edgesFiller[t.k]);
	        if (edgeStyle.arrow) scene[t.kArrow].updateEl(gl, e, pos, arrowFiller[t.kArrow]);
	    };
	
	    var removedNodes = 0;
	    var removedEdges = 0;
	
	    var freenode = { x: -1, y: -1, title: "" };
	    this.removeNodeAtPos = function (pos) {
	        if (_this.nodes[pos] === freenode) {
	            return;
	        }
	
	        removedNodes++;
	        _this.updateNode(freenode, pos);
	    };
	
	    var freeedge = { source: { x: -1, y: -1 }, target: { x: -1, y: -1 } };
	    this.removeEdgeAtPos = function (pos) {
	        if (_this.edges[pos] === freeedge) {
	            return;
	        }
	
	        removedEdges++;
	
	        _this.updateEdge(freeedge, pos);
	    };
	
	    this.getVisibleNodes = function () {
	        if (removedNodes <= 0) return _this.nodes;
	
	        var r = [];
	        _this.nodes.forEach(function (n) {
	            if (n !== freenode) r.push(n);
	        });
	        return r;
	    };
	
	    this.getVisibleEdges = function () {
	        if (removedEdges <= 0) return _this.edges;
	
	        var r = [];
	        _this.edges.forEach(function (n) {
	            if (n !== freeedge) r.push(n);
	        });
	        return r;
	    };
	
	    this.cntShownNodes = function () {
	        return _this.nodes.length - removedNodes;
	    };
	
	    this.cntShownEdges = function () {
	        return _this.edges.length - removedEdges;
	    };
	
	    var getEdgeStyleSize = function getEdgeStyleSize(c) {
	        return c.width / 120;
	        /*      let avsize = (c.width + c.height)/2;
	              let koef = (Math.min(Math.max((avsize - 150)/150, 0),1)+1)*1.3;
	              //koef 1 for 150 size and 1.4 for 300 size
	              return c.width/(130*koef);
	        */
	    };
	
	    var stylesTransl = {
	        'line': 0,
	        'dashed': 1,
	        'chain-dotted': 2,
	        'dotted': 3
	    };
	    var getEdgeType = function getEdgeType(t) {
	        if (t !== undefined) {
	            t = stylesTransl[t];
	        }
	
	        if (t === undefined || typeof t !== 'number') {
	            t = 0;
	        }
	
	        return t;
	    };
	
	    this.nodes = [];
	    this.edges = [];
	
	    var extensions = gl ? _gl2.default.initExtensions(gl, "OES_standard_derivatives") : {};
	    var scene = this.scene = createScene.call(this);
	
	    var loadCalled = false;
	    if (!gl) {
	        options.onLoad && !loadCalled && (loadCalled = true) && options.onLoad();return this;
	    };
	
	    var getLabelType = function getLabelType(f) {
	        if (texts.isSDF(f)) return 1;
	        return 0;
	    };
	
	    var fsColorTexture = ["precision mediump float;", "uniform vec4 color;", "uniform sampler2D texture;", "varying vec2 tc;", "void main(void) {", "   gl_FragColor = color * texture2D(texture, vec2(tc.s, tc.t));", "}"];
	
	    var fsLabelTexture = ["precision mediump float;", "uniform lowp sampler2D texture;", "uniform mediump vec4 color;", "uniform mediump float height_font;", "uniform float type;", "uniform float buffer;", "uniform float boldness;", "float gamma = 4.0 * 1.4142 * boldness / height_font;", "varying mediump vec2 tc;", "void main() {", "  if(type > 0.5){", //SDF
	    "    float tx=texture2D(texture, tc).a;", "    float a= smoothstep(buffer - gamma, buffer + gamma, tx);", "    gl_FragColor=vec4(color.rgb, a*color.a);", "  }else{", //NORMAL FONT
	    "    gl_FragColor = color * texture2D(texture, vec2(tc.s, tc.t));", "  }", "}"];
	
	    var fsVarColorTexture = ["precision mediump float;", "uniform sampler2D texture;", "varying vec2 tc;", "varying vec4 c;", "void main(void) {", "   gl_FragColor = c * texture2D(texture, vec2(tc.s, tc.t));", "}"];
	
	    var lineTypes = ["   if(type >= 2.5){", //3.0 dotted
	    "      part = fract(part*3.0);", "      if(part < 0.5) discard;", "   }else if(type >= 1.5){", //2.0 - chain dotted
	    "      if(part < 0.15) discard;", "      if(part > 0.30 && part < 0.45) discard;", "   }else if(type >= 0.5){", //1.0 - dashed
	    "      if(part < 0.5) discard;", "   }"];
	    var fsCurve = ["#extension GL_OES_standard_derivatives : enable", "#ifdef GL_ES", "precision highp float;", "#endif", "uniform float width;", "uniform vec4 color;", "uniform float type;", "uniform float lineStepSize;", "uniform float lineSize;", "varying vec2 c;", "varying vec2 v_lengthSoFar;", "void main(void) {", "   float part = abs(fract(length(v_lengthSoFar)*lineStepSize*lineSize));"].concat(lineTypes).concat(["   vec2 px = dFdx(c);", "   vec2 py = dFdy(c);", "   float fx = 2.0 * c.x * px.x - px.y;", "   float fy = 2.0 * c.y * py.x - py.y;", "   float sd = (c.x * c.x - c.y) / sqrt(fx * fx + fy * fy);", "   float alpha = 1.0 - abs(sd) / width;", "   if (alpha < 0.0) discard;", "   gl_FragColor = vec4(color.r, color.g, color.b, min(alpha, 1.0));", "}"]);
	
	    var getShiftFuncs = ["attribute vec2 curveShift;", "vec4 getShiftCurve(void) {", "   vec2 shiftN = vec2(curveShift.x, aspect2 * curveShift.y);", "   float length = length(screen * shiftN);", "   return vec4(exc * (length == 0.0 ? vec2(0, 0) : shiftN * 0.5 / length), 0, 0);", "}", "attribute vec2 circleShift;", "vec4 getShiftCircle(void) {", "   return vec4(size*circleShift,0,0);", "}"];
	
	    scene.add("lines", new _primitive2.default(gl, edgeStyle, null, ["precision mediump float;", "attribute vec2 position;", "attribute vec2 normal;", "attribute vec2 lengthSoFar;", "uniform float exc;", "uniform vec2 size;", "uniform vec2 screen;", "uniform float aspect2;", "uniform float aspect;", "uniform vec2 width;", "uniform mat4 transform;", "varying vec2 n;", "varying vec2 v_lengthSoFar;"].concat(getShiftFuncs).concat(["void main(void) {", "   gl_Position = getShiftCurve() + getShiftCircle() + vec4(width * normal, 0, 0) + transform * vec4(position, 0, 1);", "   vec4 p = transform*vec4(lengthSoFar,0,0);", "   v_lengthSoFar = vec2(p.x, p.y/aspect);", "   n = normal;", "}"]), ["precision mediump float;", "uniform float type;", "uniform vec4 color;", "varying vec2 n;", "varying vec2 v_lengthSoFar;", "uniform float lineSize;", "void main(void) {", "   float part = abs(fract(length(v_lengthSoFar)*lineSize*5.0));"].concat(lineTypes).concat(["   gl_FragColor = vec4(color.r, color.g, color.b, color.a - length(n));", "}"]), function (c) {
	        var uniforms = c.shader.uniforms;
	        uniforms.exc && gl.uniform1f(uniforms.exc, c.curveExc);
	        gl.uniform2f(uniforms.screen, c.width, c.height);
	        var size = 2.5 * c.nodeSize;
	        uniforms.size && gl.uniform2f(uniforms.size, size / c.width, size / c.height);
	        gl.uniform1f(uniforms.lineSize, getEdgeStyleSize(c));
	        gl.uniform1f(uniforms.aspect2, c.aspect2);
	        gl.uniform1f(uniforms.aspect, c.aspect);
	        gl.uniform2f(uniforms.width, c.style.width / c.width, c.style.width / c.height);
	        gl.uniform1f(uniforms.type, getEdgeType(c.style.type));
	        _gl2.default.uniformColor(gl, uniforms.color, c.style.color);
	    }));
	
	    if (extensions.OES_standard_derivatives) {
	        scene.add("curves", new _primitive2.default(gl, edgeStyle, null, ["precision highp float;", "attribute vec2 position;", "attribute vec2 normal;", "attribute vec2 curve;", "attribute vec2 lengthSoFar;", "uniform vec2 size;", "uniform float exc;", "uniform vec2 screen;", "uniform float aspect2;", "uniform float aspect;", "uniform mat4 transform;", "varying vec2 v_lengthSoFar;", "varying vec2 c;"].concat(getShiftFuncs).concat(["void main(void) {", "   vec2 n = vec2(normal.x, aspect2 * normal.y);", "   float length = length(screen * n);", "   n = length == 0.0 ? vec2(0, 0) : n / length;", "   gl_Position = getShiftCurve() + getShiftCircle() + vec4(exc * n, 0, 0) + transform * vec4(position, 0, 1);", "   c = curve;", "   vec4 p = transform*vec4(lengthSoFar,0,0);", "   v_lengthSoFar = vec2(p.x, p.y/aspect);", "}"]), fsCurve, function (c) {
	            var uniforms = c.shader.uniforms;
	            gl.uniform1f(uniforms.width, c.style.width);
	            gl.uniform1f(uniforms.exc, c.curveExc);
	            gl.uniform2f(uniforms.screen, c.width, c.height);
	            var size = 2.5 * c.nodeSize;
	            uniforms.size && gl.uniform2f(uniforms.size, size / c.width, size / c.height);
	            gl.uniform1f(uniforms.lineSize, getEdgeStyleSize(c));
	            gl.uniform1f(uniforms.aspect2, c.aspect2);
	            gl.uniform1f(uniforms.aspect, c.aspect);
	            gl.uniform1f(uniforms.type, getEdgeType(c.style.type));
	            uniforms.lineStepSize && gl.uniform1f(uniforms.lineStepSize, 5);
	            _gl2.default.uniformColor(gl, uniforms.color, c.style.color);
	        }));
	        scene.add("circles", new _primitive2.default(gl, edgeStyle, null, ["precision highp float;", "attribute vec2 position;", "attribute vec2 normal;", "attribute vec2 curve;", "attribute vec2 lengthSoFar;", "uniform float exc;", "uniform vec2 screen;", "uniform float aspect2;", "uniform float aspect;", "uniform vec2 size;", "uniform mat4 transform;", "varying vec2 c;", "varying vec2 v_lengthSoFar;"].concat(getShiftFuncs).concat(["void main(void) {", "   gl_Position = getShiftCurve() + getShiftCircle() + vec4(size * normal, 0, 0) + transform * vec4(position, 0, 1);", "   c = curve;", "   vec4 p = transform*vec4(size * lengthSoFar,0,0);", "   v_lengthSoFar = vec2(p.x, p.y/aspect);", "}"]), fsCurve, function (c) {
	            var uniforms = c.shader.uniforms;
	            uniforms.exc && gl.uniform1f(uniforms.exc, c.curveExc);
	            gl.uniform1f(uniforms.width, c.style.width);
	            gl.uniform1f(uniforms.type, getEdgeType(c.style.type));
	            gl.uniform2f(uniforms.screen, c.width, c.height);
	            var size = 2.5 * c.nodeSize;
	            uniforms.size && gl.uniform2f(uniforms.size, size / c.width, size / c.height);
	            gl.uniform1f(uniforms.lineSize, getEdgeStyleSize(c));
	            gl.uniform1f(uniforms.aspect2, c.aspect2);
	            gl.uniform1f(uniforms.aspect, c.aspect);
	            uniforms.lineStepSize && gl.uniform1f(uniforms.lineStepSize, 5 / 3);
	            _gl2.default.uniformColor(gl, uniforms.color, c.style.color);
	        }));
	    }
	
	    if (edgeStyle.arrow) {
	        var shaderparams = { attribute: { offsetMul: 1 } };
	
	        var bind = function bind(c) {
	            var size = getSize(c, c.style, getEdgesCnt(), 0.2);
	            if (!size) return true;
	
	            var uniforms = c.shader.uniforms;
	            gl.uniform1f(uniforms.offset, 0.5 * c.nodeSize);
	            gl.uniform2f(uniforms.arrowsize, size, c.style.aspect * size);
	            gl.uniform1f(uniforms.exc, c.curveExc);
	            uniforms.cexc && gl.uniform1f(uniforms.cexc, 0.5 * view.size * c.curveExc);
	            if (uniforms.size) {
	                size = 2.5 * c.nodeSize;
	                uniforms.size && gl.uniform2f(uniforms.size, size / c.width, size / c.height);
	            }
	            gl.uniform2f(uniforms.screen, c.width, c.height);
	            gl.uniform1f(uniforms.aspect2, c.aspect2);
	            _gl2.default.uniformColor(gl, uniforms.color, c.style.color);
	        };
	
	        scene.add("lineArrows", new _primitive2.default(gl, edgeStyle, "arrow", ["attribute vec2 position;", "attribute vec2 direction;", "attribute vec2 textureCoord;", "attribute float offsetMul;", "uniform float offset;", "uniform vec2 arrowsize;", "uniform vec2 size;", "uniform vec2 screen;", "uniform float exc;", "uniform float aspect2;", "uniform mat4 transform;", "varying vec2 tc;"].concat(getShiftFuncs).concat(["void main(void) {", "   vec2 u = direction / length(screen * direction);", "   vec2 v = vec2(u.y, -aspect2 * u.x);", "   v = v / length(screen * v);", "   gl_Position = getShiftCurve() + getShiftCircle()  + vec4(arrowsize.x * (0.5 - textureCoord.x) * v - arrowsize.y * textureCoord.y * u - offset * offsetMul * u, 0, 0) + transform * vec4(position, 0, 1);", "   tc = textureCoord;", "}"]), fsColorTexture, bind, shaderparams));
	
	        if (extensions.OES_standard_derivatives) {
	            scene.add("curveArrows", new _primitive2.default(gl, edgeStyle, "arrow", ["attribute vec2 position;", "attribute vec2 direction;", "attribute vec2 textureCoord;", "attribute float offsetMul;", "uniform float offset;", "uniform vec2 arrowsize;", "uniform vec2 size;", "uniform float exc;", "uniform float cexc;", "uniform vec2 screen;", "uniform float aspect2;", "uniform mat4 transform;", "varying vec2 tc;"].concat(getShiftFuncs).concat(["void main(void) {", "   vec2 u = normalize(vec2(direction.y, -aspect2 * direction.x));", "   u = normalize(direction - cexc * u / length(screen * u));", "   u = u / length(screen * u);", "   vec2 v = vec2(u.y, -aspect2 * u.x);", "   v = v / length(screen * v);", "   gl_Position = getShiftCurve() + getShiftCircle() + vec4(arrowsize.x * (0.5 - textureCoord.x) * v - arrowsize.y * textureCoord.y * u - offset * offsetMul * u, 0, 0) + transform * vec4(position, 0, 1);", "   tc = textureCoord;", "}"]), fsColorTexture, bind, shaderparams));
	            scene.add("circleArrows", new _primitive2.default(gl, edgeStyle, "arrow", ["attribute vec2 position;", "attribute vec2 direction;", "attribute vec2 textureCoord;", "attribute float offsetMul;", "uniform float offset;", "uniform vec2 arrowsize;", "uniform vec2 size;", "uniform vec2 screen;", "uniform float exc;", "uniform float aspect2;", "uniform mat4 transform;", "varying vec2 tc;"].concat(getShiftFuncs).concat(["void main(void) {", "   vec2 u = direction;", "   vec2 v = vec2(direction.y, -direction.x);", "   gl_Position = getShiftCurve() + getShiftCircle() + vec4((arrowsize.x * (0.5 - textureCoord.x) * v - arrowsize.y * textureCoord.y * u - offset * offsetMul * u) / screen, 0, 0) + transform * vec4(position, 0, 1);", "   tc = textureCoord;", "}"]), fsColorTexture, bind, shaderparams));
	        }
	    }
	
	    scene.add("nodes", new _primitive2.default(gl, nodeStyle, null, ["attribute vec2 position;", "attribute vec2 textureCoord;", "uniform vec2 size;", "uniform mat4 transform;", "varying vec2 tc;", "void main(void) {", "   gl_Position = vec4(size * (textureCoord - vec2(0.5, 0.5)), 0, 0) + transform * vec4(position, 0, 1);", "   tc = textureCoord;", "}"], fsColorTexture, function (c) {
	        var size = getNodeSize(c);
	        var uniforms = c.shader.uniforms;
	        gl.uniform2f(uniforms.size, size / c.width, size / c.height);
	        _gl2.default.uniformColor(gl, uniforms.color, c.style.color);
	    }));
	    scene.add("nodesColored", new _primitive2.default(gl, nodeStyle, null, ["attribute vec2 position;", "attribute vec2 textureCoord;", "attribute vec4 color;", "uniform vec2 size;", "uniform mat4 transform;", "varying vec2 tc;", "varying vec4 c;", "void main(void) {", "   gl_Position = vec4(size * (textureCoord - vec2(0.5, 0.5)), 0, 0) + transform * vec4(position, 0, 1);", "   tc = textureCoord;", "   c = color;", "}"], fsVarColorTexture, function (c) {
	        var size = getNodeSize(c);
	        var uniforms = c.shader.uniforms;
	        gl.uniform2f(uniforms.size, size / c.width, size / c.height);
	    }));
	
	    var vsLabelsShader = ["attribute vec2 position;", "attribute vec2 relative;", "attribute vec2 textureCoord;", "uniform float offset;", "uniform vec2 scale;", "uniform float fontScale;", "uniform mat4 transform;", "varying vec2 tc;", "void main(void) {", "   gl_Position = vec4(scale * (relative*fontScale + vec2(0, (2.0 * step(position.y, 0.5) - 1.0) * offset)), 0, 0) + transform * vec4(position, 0, 1);", "   tc = textureCoord;", "}"];
	    var bindLabels = function bindLabels(is_outline) {
	        return function (c) {
	            if (!getNodeSize(c)) return true;
	
	            var l = c.style.label;
	            var f = l.font;
	            var uniforms = c.shader.uniforms;
	
	            gl.uniform1f(uniforms.type, getLabelType(f));
	
	            var textEngine = texts.getEngine(f);
	            textEngine.setFont(f);
	
	            var fontScale = 1.0;
	            var sdfSize = textEngine.fontSize;
	            var wantedSize = textEngine.isSDF ? getLabelSize(context, l || {}) : sdfSize;
	            if (wantedSize === 0) {
	                fontScale = 0;
	            };
	
	            var opts = {};
	            if (wantedSize && sdfSize) {
	                fontScale *= wantedSize / sdfSize;
	            }
	
	            if (is_outline && !textEngine.isSDF) //discardAll
	                fontScale = 0;
	
	            gl.uniform1f(uniforms.buffer, is_outline ? 0.25 : 192.0 / 256.0);
	            gl.uniform1f(uniforms.boldness, (f ? f.boldness : undefined) || 1.);
	            gl.uniform1f(uniforms.fontScale, fontScale);
	            gl.uniform1f(uniforms.height_font, sdfSize);
	            gl.uniform1f(uniforms.offset, 0.5 * c.nodeSize);
	            gl.uniform2f(uniforms.scale, 1 / c.width, 1 / c.height);
	
	            var color = void 0;
	            if (is_outline && f) color = new _color2.default(f.outlineColor || backgroundColor);else color = c.style.color;
	            _gl2.default.uniformColor(gl, uniforms.color, color);
	        };
	    };
	    nodeStyle.label && scene.add("labelsOutline", new _primitive2.default(gl, nodeStyle, "label", vsLabelsShader, fsLabelTexture, bindLabels(true)));
	    nodeStyle.label && scene.add("labels", new _primitive2.default(gl, nodeStyle, "label", vsLabelsShader, fsLabelTexture, bindLabels(false)));
	
	    if (options.onLoad) {
	        var styles = options.styles;
	        for (var p in styles) {
	            var s = styles[p];
	
	            s.texture && textures.get(gl, s.texture, onLoad);
	            s.arrow && s.arrow.texture && textures.get(gl, s.arrow.texture);
	        }
	    }
	
	    function createScene() {
	        return {
	            elements: [],
	            add: function add(name, e) {
	                scene[name] = e;
	                scene.elements.push(e);
	            }
	        };
	    }
	};
	
	var _color = __webpack_require__(3);
	
	var _color2 = _interopRequireDefault(_color);
	
	var _gl = __webpack_require__(4);
	
	var _gl2 = _interopRequireDefault(_gl);
	
	var _primitive = __webpack_require__(5);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	var _layout = __webpack_require__(9);
	
	var _layout2 = _interopRequireDefault(_layout);
	
	var _geomutils = __webpack_require__(28);
	
	var _geomutils2 = _interopRequireDefault(_geomutils);
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _primitiveTools = __webpack_require__(8);
	
	var _spatialSearch = __webpack_require__(29);
	
	var _spatialSearch2 = _interopRequireDefault(_spatialSearch);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */
	
	var Color = function Color(color) {
	    _classCallCheck(this, Color);
	
	    this.a = 1;
	
	    if (color instanceof Color) {
	        this.r = color.r;
	        this.g = color.g;
	        this.b = color.b;
	        this.a = color.a;
	    } else if (arguments.length >= 3) {
	        this.r = arguments[0];
	        this.g = arguments[1];
	        this.b = arguments[2];
	        arguments.length > 3 && (this.a = arguments[3]);
	    } else if (/^rgba\((\d+), ?(\d+), ?(\d+), ?(\d+)\)$/i.test(color)) {
	        color = /^rgba\((\d+), ?(\d+), ?(\d+), ?(\d+)\)$/i.exec(color);
	        var get = function get(v) {
	            return parseInt(v, 10) / 255;
	        };
	
	        this.r = get(color[1]);
	        this.g = get(color[2]);
	        this.b = get(color[3]);
	        this.a = get(color[4]);
	    } else if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(color)) {
	        color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(color);
	        var _get = function _get(v) {
	            return parseInt(v, 10) / 255;
	        };
	
	        this.r = _get(color[1]);
	        this.g = _get(color[2]);
	        this.b = _get(color[3]);
	    } else if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(color)) {
	        color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(color);
	        var _get2 = function _get2(v) {
	            return parseInt(v, 10) / 100;
	        };
	
	        this.r = _get2(color[1]);
	        this.g = _get2(color[2]);
	        this.b = _get2(color[3]);
	    } else if (/^\#([0-9a-f]{6})$/i.test(color)) {
	        color = parseInt(color.substring(1), 16);
	        this.r = (color >> 16 & 255) / 255;
	        this.g = (color >> 8 & 255) / 255;
	        this.b = (color & 255) / 255;
	    } else {
	        this.r = this.g = this.b = 0;
	    }
	};
	
	exports.default = Color;
	;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */
	
	var _class = function () {
	    function _class() {
	        _classCallCheck(this, _class);
	    }
	
	    _createClass(_class, null, [{
	        key: "initExtensions",
	        value: function initExtensions(gl) {
	            var extensions = gl.getSupportedExtensions();
	            var result = {};
	            for (var i = 1; i < arguments.length; i++) {
	                var e = arguments[i];
	                (result[e] = extensions.indexOf(e) >= 0) && gl.getExtension(e);
	            }
	            return result;
	        }
	    }, {
	        key: "createShader",
	        value: function createShader(gl, type, source) {
	            var result = gl.createShader(type);
	            gl.shaderSource(result, source);
	            gl.compileShader(result);
	
	            if (!gl.getShaderParameter(result, gl.COMPILE_STATUS)) {
	                console.log(gl.getShaderInfoLog(result));
	                return null;
	            }
	            return result;
	        }
	    }, {
	        key: "createTexture",
	        value: function createTexture(gl, img, onLoad, options) {
	            var result = gl.createTexture();
	
	            var image = new Image();
	
	            var load = function load() {
	                image.onload = null;
	                gl.bindTexture(gl.TEXTURE_2D, result);
	
	                if ((options || {}).sdf) {
	                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, image);
	                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	                } else {
	                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	                }
	
	                gl.bindTexture(gl.TEXTURE_2D, null);
	                onLoad && onLoad();
	            };
	
	            image.onload = load;
	            image.src = img;
	            image.naturalWidth && image.naturalHeight && load();
	
	            result.image = image;
	            return result;
	        }
	    }, {
	        key: "uniformColor",
	        value: function uniformColor(gl, location, color) {
	            gl.uniform4f(location, color.r, color.g, color.b, color.a);
	        }
	    }, {
	        key: "ortho",
	        value: function ortho(left, right, bottom, top, near, far) {
	            var lr = 1 / (left - right),
	                bt = 1 / (bottom - top),
	                nf = 1 / (near - far);
	
	            var result = new Float32Array(16);
	            result[0] = -2 * lr;
	            result[1] = 0;
	            result[2] = 0;
	            result[3] = 0;
	            result[4] = 0;
	            result[5] = -2 * bt;
	            result[6] = 0;
	            result[7] = 0;
	            result[8] = 0;
	            result[9] = 0;
	            result[10] = 2 * nf;
	            result[11] = 0;
	            result[12] = (left + right) * lr;
	            result[13] = (top + bottom) * bt;
	            result[14] = (far + near) * nf;
	            result[15] = 1;
	            return result;
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _shader = __webpack_require__(6);
	
	var _shader2 = _interopRequireDefault(_shader);
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _primitiveTools = __webpack_require__(8);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */
	
	var primitive = function () {
	    function primitive(gl, baseStyle, styleProperty, vs, fs, bind, shaderParams) {
	        var _this = this;
	
	        _classCallCheck(this, primitive);
	
	        var shader = new _shader2.default(gl, vs.join('\n'), fs.join('\n'), shaderParams);
	        var buffers = [];
	        var sections = [];
	
	        var sectionsByStyle = {};
	
	        var e = {};
	        var iV = void 0,
	            iI = void 0,
	            iS = 0,
	            iB = 0;
	
	        var partLength = function partLength(filler, part) {
	            if (filler.size) {
	                var n = 0;
	                part.forEach(function (p) {
	                    n += filler.size(e, p);
	                });
	                return n;
	            } else {
	                return part.length;
	            }
	            return;
	        };
	
	        var init = function init(filler, n) {
	            iV = iI = 0;
	            var max = Math.floor(primitive.maxBufferSize / filler.numVertices);
	            var nV = Math.min(max, n - (iB - iS) * max);
	            var nI = nV * filler.numIndices;
	
	            if (!e.indices || e.indices.length !== nI) {
	                e.indices = new Uint16Array(nI);
	                nV *= filler.numVertices;
	                for (var a in shader.attributes) {
	                    e[a] = new Float32Array(shader.attributes[a].size * nV);
	                }
	            }
	        };
	
	        var zerofiller = {
	            set: function set(v, iV, iI, numVertices, numIndices) {
	                var indicesarr = [v.indices, iV, iI];
	                for (var i = 0; i < numIndices; i++) {
	                    indicesarr.push(0);
	                }var verticesarr = [undefined, iV, iI];
	                for (var _i = 0; _i < numVertices; _i++) {
	                    verticesarr.push(0);
	                }for (var k in v) {
	                    if (k === 'indices') {
	                        primitive.indices.apply(_this, indicesarr);
	                    } else {
	                        verticesarr[0] = v[k];
	                        primitive.vertices.apply(_this, verticesarr);
	                    }
	                }
	            }
	        };
	
	        this.set = function (gl, styles, adder, data, parts, get) {
	            var isDirty = false;
	
	            iS = 0;
	            iB = 0;
	
	            _this._iIs = new Uint32Array(data.length);
	            _this._iVs = new Uint32Array(data.length);
	            _this._iBs = new Uint8Array(data.length);
	            _this._sizes = new Uint8Array(data.length);
	
	            var store = function store(section) {
	                var b = buffers[iB];
	                if (!b) {
	                    buffers[iB] = b = {};
	                    for (var a in e) {
	                        b[a] = gl.createBuffer();
	                    }
	                }
	                for (var _a in shader.attributes) {
	                    gl.bindBuffer(gl.ARRAY_BUFFER, b[_a]);
	                    gl.bufferData(gl.ARRAY_BUFFER, e[_a], gl.STATIC_DRAW);
	                }
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.indices);
	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, e.indices, gl.STATIC_DRAW);
	                b.numIndices = iI;
	                b.numVertices = iV;
	                section.buffers.push(b);
	                iB++;
	            };
	
	            sections = [];
	            for (var p in parts) {
	                var add = function add() {
	                    sections.push(this);
	                    sectionsByStyle[this.styleName] = this;
	                };
	
	                iS = iB;
	
	                var section = {
	                    style: (0, _primitiveTools.getPartitionStyle)(styles[p], baseStyle, styleProperty),
	                    buffers: [],
	                    styleName: p
	                };
	
	                var filler = get(section.style);
	                filler.numVertices = filler.numVertices || 4;
	                filler.numIndices = filler.numIndices || 6;
	
	                var part = parts[p];
	
	                var pL = partLength(filler, part);
	                init(filler, pL);
	                var max = primitive.maxBufferSize;
	                for (var i = 0; i < part.length; i++) {
	                    var s = filler.size ? filler.size(e, part[i]) : 1;
	                    var niV = iV + s * filler.numVertices;
	                    var niI = iI + s * filler.numIndices;
	
	                    if (niV >= max) {
	                        store(section);
	                        init(filler, pL);
	                        niV = iV;
	                        niI = iI;
	                    }
	
	                    if (filler.set(e, part[i], iV, iI)) isDirty = true;
	
	                    var idx = part.idx[i];
	                    _this._iIs[idx] = iI;
	                    _this._iVs[idx] = iV;
	                    _this._iBs[idx] = iB;
	                    _this._sizes[idx] = s;
	
	                    iI = niI;
	                    iV = niV;
	                }
	                store(section);
	
	                var addSection = add.bind(section);
	
	                adder ? adder(section, addSection) : addSection();
	            }
	
	            return isDirty;
	        };
	
	        var fb = void 0;
	        this.update = function (gl, attribute, data, get) {
	            var i = 0,
	                size = shader.attributes[attribute].size;
	            sections.forEach(function (section) {
	                var filler = get(section.style);
	                filler.numVertices = filler.numVertices || 4;
	
	                section.buffers.forEach(function (e) {
	                    (!fb || fb.length !== size * e.numVertices) && (fb = new Float32Array(size * e.numVertices));
	                    for (var _iV = 0; _iV < e.numVertices; _iV += (filler.size ? filler.size(e, data[i]) : 1) * filler.numVertices) {
	                        filler.set(fb, data[i++], _iV);
	                    }gl.bindBuffer(gl.ARRAY_BUFFER, e[attribute]);
	                    gl.bufferData(gl.ARRAY_BUFFER, fb, gl.DYNAMIC_DRAW);
	                });
	            });
	        };
	
	        this.updateEl = function (gl, el, pos, get) {
	            var storeToPos = function storeToPos(b, iV, iI) {
	                for (var a in shader.attributes) {
	                    gl.bindBuffer(gl.ARRAY_BUFFER, b[a]);
	                    gl.bufferSubData(gl.ARRAY_BUFFER, shader.attributes[a].size * iV * e[a].BYTES_PER_ELEMENT, e[a]);
	                }
	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.indices);
	                gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, iI * e.indices.BYTES_PER_ELEMENT, e.indices);
	            };
	
	            var section = sectionsByStyle[el.style];
	
	            var filler = get(section.style);
	            filler.numVertices = filler.numVertices || 4;
	            filler.numIndices = filler.numIndices || 6;
	
	            iB = iS = 0;
	
	            var buffer = section.buffers[_this._iBs[pos]];
	            var s = filler.size ? filler.size(buffer, el) : 1;
	            var olds = _this._sizes[pos];
	            if (s > olds) {
	                console.error('Cannot set primitive to new value which has greater size (' + s + " > " + olds + ") - no enough empty space to fill in GL buffer");
	                return;
	            }
	
	            init(filler, olds);
	            filler.set(e, el, 0, 0);
	
	            for (; s < olds; s++) {
	                //zero fill empty spaces
	                zerofiller.set(e, s * filler.numVertices, s * filler.numIndices, filler.numVertices, filler.numIndices);
	            }
	
	            var iV = _this._iVs[pos];
	            var iI = _this._iIs[pos];
	            storeToPos(buffer, iV, iI);
	        };
	
	        this.draw = function (context) {
	            context.shader = shader;
	            shader.bind();
	
	            gl.uniformMatrix4fv(shader.uniforms.transform, false, context.transform);
	
	            sections.forEach(function (section) {
	                if (section.style.texture) {
	                    section.style.texture.update && section.style.texture.update();
	                    gl.activeTexture(gl.TEXTURE0);
	                    gl.bindTexture(gl.TEXTURE_2D, section.style.texture);
	                    gl.uniform1i(shader.uniforms.texture, 0);
	                }
	
	                context.style = section.style;
	                if (bind(context)) return;
	
	                section.buffers.forEach(function (e) {
	                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, e.indices);
	
	                    for (var a in shader.attributes) {
	                        var attribute = shader.attributes[a];
	                        gl.bindBuffer(gl.ARRAY_BUFFER, e[a]);
	                        gl.vertexAttribPointer(attribute.index, attribute.size, gl.FLOAT, false, 0, 0);
	                    }
	
	                    gl.drawElements(gl.TRIANGLES, e.numIndices, gl.UNSIGNED_SHORT, 0);
	                });
	            });
	
	            shader.unbind();
	        };
	    }
	
	    _createClass(primitive, null, [{
	        key: 'vertices',
	        value: function vertices(buffer, iV) {
	            for (var i = 2, j = 2 * iV, n = arguments.length; i < n; i++, j++) {
	                buffer[j] = arguments[i];
	            }
	        }
	    }, {
	        key: 'singles',
	        value: function singles(buffer, iV) {
	            for (var i = 2, j = 1 * iV, n = arguments.length; i < n; i++, j++) {
	                buffer[j] = arguments[i];
	            }
	        }
	    }, {
	        key: 'colors',
	        value: function colors(buffer, iV) {
	            for (var i = 2, j = 4 * iV, n = arguments.length; i < n; i++) {
	                var c = arguments[i];
	                buffer[j++] = c.r;
	                buffer[j++] = c.g;
	                buffer[j++] = c.b;
	                buffer[j++] = c.a;
	            }
	        }
	    }, {
	        key: 'indices',
	        value: function indices(buffer, iV, iI) {
	            for (var i = 3, j = iI, n = arguments.length; i < n; i++, j++) {
	                buffer[j] = iV + arguments[i];
	            }
	        }
	    }, {
	        key: 'quad',
	        value: function quad(buffer, iV, iI) {
	            primitive.indices(buffer, iV, iI, 0, 1, 2, 2, 3, 0);
	        }
	    }, {
	        key: 'maxBufferSize',
	        get: function get() {
	            return 65536;
	        }
	    }]);
	
	    return primitive;
	}();
	
	exports.default = primitive;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _gl = __webpack_require__(4);
	
	var _gl2 = _interopRequireDefault(_gl);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */
	
	var defaultAttr = { color: 4 };
	
	var Shader = function () {
	  function Shader(gl, vs, fs, shaderParams) {
	    _classCallCheck(this, Shader);
	
	    this._gl = gl;
	    this._vs = vs;
	    this._fs = fs;
	
	    var program = this._program = gl.createProgram();
	
	    gl.attachShader(program, _gl2.default.createShader(gl, gl.VERTEX_SHADER, vs));
	    gl.attachShader(program, _gl2.default.createShader(gl, gl.FRAGMENT_SHADER, fs));
	    gl.linkProgram(program);
	
	    this.uniforms = {};
	    var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	    for (var i = 0; i < n; i++) {
	      var name = gl.getActiveUniform(program, i).name;
	      this.uniforms[name] = gl.getUniformLocation(program, name);
	    }
	
	    var attrParams = (shaderParams || {}).attribute || {};
	
	    this.attributes = {};
	    n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	    for (var _i = 0; _i < n; _i++) {
	      var _name = gl.getActiveAttrib(program, _i).name;
	      this.attributes[_name] = { index: _i, size: attrParams[_name] || Shader.attribute[_name] || 2 };
	    }
	  }
	
	  _createClass(Shader, [{
	    key: 'bind',
	    value: function bind() {
	      this._gl.useProgram(this._program);
	
	      var n = this._gl.getProgramParameter(this._program, this._gl.ACTIVE_ATTRIBUTES);
	      for (var i = 0; i < n; i++) {
	        this._gl.enableVertexAttribArray(i);
	      }
	    }
	  }, {
	    key: 'unbind',
	    value: function unbind() {
	      var n = this._gl.getProgramParameter(this._program, this._gl.ACTIVE_ATTRIBUTES);
	      for (var i = 0; i < n; i++) {
	        this._gl.disableVertexAttribArray(i);
	      }
	    }
	  }], [{
	    key: 'attribute',
	    get: function get() {
	      return defaultAttr;
	    }
	  }]);
	
	  return Shader;
	}();
	
	exports.default = Shader;
	;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: David Tichy, AleÅ¡ Saska
	 */
	
	var Utils = function () {
	  function Utils() {
	    _classCallCheck(this, Utils);
	  }
	
	  _createClass(Utils, null, [{
	    key: "extend",
	    value: function extend(from) {
	      for (var i = 1; i < arguments.length; i++) {
	        for (var k in arguments[i]) {
	          from[k] = arguments[i][k];
	        }
	      }
	      return from;
	    }
	  }, {
	    key: "isObject",
	    value: function isObject(obj) {
	      return obj === Object(obj);
	    }
	  }, {
	    key: "emptyObject",
	    value: function emptyObject(obj) {
	      if (!Utils.isObject(obj)) return false;
	
	      for (var k in obj) {
	        return false;
	      }return true;
	    }
	  }, {
	    key: "ajax",
	    value: function ajax(url, callback, type) {
	      var xmlhttp;
	      // compatible with IE7+, Firefox, Chrome, Opera, Safari
	      xmlhttp = new XMLHttpRequest();
	      xmlhttp.onreadystatechange = function (cbk) {
	        return function () {
	          if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
	            cbk(type == 'arraybuffer' ? xmlhttp.response : xmlhttp.responseText);
	          }
	        };
	      }(callback);
	      if (type) xmlhttp.responseType = type;
	      xmlhttp.open("GET", url, true);
	      xmlhttp.send();
	    }
	  }]);
	
	  return Utils;
	}();
	
	exports.default = Utils;
	;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.getPartitionStyle = exports.partitionByStyle = undefined;
	
	var _color = __webpack_require__(3);
	
	var _color2 = _interopRequireDefault(_color);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function partitionByStyle(data) {
	    var parts = {};
	
	    var pN = {};
	    for (var i = 0; i < data.length; i++) {
	        var el = data[i];
	        var part = parts[el.style] = parts[el.style] || [];
	        if (part.idx === undefined) part.idx = [];
	        part.idx.push(i);
	
	        el.sI = pN[el.style] = pN[el.style] === undefined ? 0 : pN[el.style] + 1;
	
	        part.push(el);
	    }
	
	    return parts;
	}
	
	function getPartitionStyle(style, baseStyle, styleProperty) {
	    var result = {};
	
	    var copy = function copy(s) {
	        if (s) for (var p in s) {
	            result[p] = s[p];
	        }
	    };
	
	    copy(baseStyle);
	    copy(style);
	
	    if (styleProperty) {
	        copy(baseStyle[styleProperty]);
	        style && copy(style[styleProperty]);
	    }
	    result.color = result.color && new _color2.default(result.color);
	    return result;
	};
	
	exports.partitionByStyle = partitionByStyle;
	exports.getPartitionStyle = getPartitionStyle;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _force = __webpack_require__(10);
	
	var _force2 = _interopRequireDefault(_force);
	
	var _random = __webpack_require__(12);
	
	var _random2 = _interopRequireDefault(_random);
	
	var _circular = __webpack_require__(13);
	
	var _circular2 = _interopRequireDefault(_circular);
	
	var _tree = __webpack_require__(15);
	
	var _tree2 = _interopRequireDefault(_tree);
	
	var _treeT = __webpack_require__(16);
	
	var _treeT2 = _interopRequireDefault(_treeT);
	
	var _hierarchical = __webpack_require__(17);
	
	var _hierarchical2 = _interopRequireDefault(_hierarchical);
	
	var _hierarchical3 = __webpack_require__(18);
	
	var _hierarchical4 = _interopRequireDefault(_hierarchical3);
	
	var _spectral = __webpack_require__(19);
	
	var _spectral2 = _interopRequireDefault(_spectral);
	
	var _spectral3 = __webpack_require__(24);
	
	var _spectral4 = _interopRequireDefault(_spectral3);
	
	var _hive = __webpack_require__(25);
	
	var _hive2 = _interopRequireDefault(_hive);
	
	var _grid = __webpack_require__(26);
	
	var _grid2 = _interopRequireDefault(_grid);
	
	var _versinus = __webpack_require__(27);
	
	var _versinus2 = _interopRequireDefault(_versinus);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */
	
	var _class = function () {
	  function _class() {
	    _classCallCheck(this, _class);
	  }
	
	  _createClass(_class, null, [{
	    key: 'normalize',
	    value: function normalize(nodes, dim) {
	      var minX = void 0,
	          minY = void 0,
	          n = nodes.length;
	
	      if (dim) {
	        minX = dim.minX;
	        minY = dim.minY;
	      } else {
	        var maxX = -Infinity;
	        var maxY = -Infinity;
	        minX = minY = Infinity;
	
	        for (var i = 0; i < n; i++) {
	          var o = nodes[i];
	          maxX = Math.max(maxX, o.x);
	          maxY = Math.max(maxY, o.y);
	          minX = Math.min(minX, o.x);
	          minY = Math.min(minY, o.y);
	        };
	
	        dim = {
	          maxX: maxX,
	          maxY: maxY,
	          minX: minX,
	          minY: minY
	        };
	      }
	
	      var scX = minX !== dim.maxX ? 1 / (dim.maxX - minX) : (minX -= 0.5, 1);
	      var scY = minY !== dim.maxY ? 1 / (dim.maxY - minY) : (minY -= 0.5, 1);
	
	      for (var _i = 0; _i < n; _i++) {
	        var _o = nodes[_i];
	        _o.x = scX * (_o.x - minX);
	        _o.y = scY * (_o.y - minY);
	      }
	
	      return dim;
	    }
	  }, {
	    key: 'force',
	    get: function get() {
	      return _force2.default;
	    }
	  }, {
	    key: 'random',
	    get: function get() {
	      return _random2.default;
	    }
	  }, {
	    key: 'circular',
	    get: function get() {
	      return _circular2.default;
	    }
	  }, {
	    key: 'tree',
	    get: function get() {
	      return _tree2.default;
	    }
	  }, {
	    key: 'tree2',
	    get: function get() {
	      return _treeT2.default;
	    }
	  }, {
	    key: 'hierarchical',
	    get: function get() {
	      return _hierarchical2.default;
	    }
	  }, {
	    key: 'hierarchical2',
	    get: function get() {
	      return _hierarchical4.default;
	    }
	  }, {
	    key: 'spectral',
	    get: function get() {
	      return _spectral2.default;
	    }
	  }, {
	    key: 'spectral2',
	    get: function get() {
	      return _spectral4.default;
	    }
	  }, {
	    key: 'hive',
	    get: function get() {
	      return _hive2.default;
	    }
	  }, {
	    key: 'grid',
	    get: function get() {
	      return _grid2.default;
	    }
	  }, {
	    key: 'versinus',
	    get: function get() {
	      return _versinus2.default;
	    }
	  }]);

	  return _class;
	}();

	exports.default = _class;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (nodes, edges, options) {
	    var edgeDistance = 15,
	        edgeStrength = 1,
	        friction = 0.9,
	        charge = -30,
	        gravity = 0.4,
	        theta2 = .64,
	        size = [1, 1],
	        chargeDistance2 = Infinity;
	
	    var alpha = void 0,
	        distances = [],
	        strengths = [],
	        charges = [];
	
	    function accumulate(quad, alpha, charges) {
	        var cx = 0,
	            cy = 0;
	        quad.charge = 0;
	        if (!quad.leaf) {
	            var _nodes = quad.nodes;
	            var c = void 0,
	                n = _nodes.length;
	
	            for (var i = 0; i < n; i++) {
	                c = _nodes[i];
	                if (c == null) continue;
	                accumulate(c, alpha, charges);
	                quad.charge += c.charge;
	                cx += c.charge * c.cx;
	                cy += c.charge * c.cy;
	            }
	        }
	        if (quad.point) {
	            if (!quad.leaf) {
	                quad.point.x += Math.random() - 0.5;
	                quad.point.y += Math.random() - 0.5;
	            }
	            var k = alpha * charges[quad.point.index];
	            quad.charge += quad.pointCharge = k;
	            cx += k * quad.point.x;
	            cy += k * quad.point.y;
	        }
	        quad.cx = cx / quad.charge;
	        quad.cy = cy / quad.charge;
	    }
	
	    function repulse(node) {
	        return function (quad, x1, _, x2) {
	            if (quad.point !== node) {
	                var dx = quad.cx - node.x;
	                var dy = quad.cy - node.y;
	                var dw = x2 - x1;
	                var dn = dx * dx + dy * dy;
	
	                if (dw * dw / theta2 < dn) {
	                    if (dn < chargeDistance2) {
	                        var k = quad.charge / dn;
	                        node.px -= dx * k;
	                        node.py -= dy * k;
	                    }
	                    return true;
	                }
	
	                if (quad.point && dn && dn < chargeDistance2) {
	                    var _k = quad.pointCharge / dn;
	                    node.px -= dx * _k;
	                    node.py -= dy * _k;
	                }
	            }
	            return !quad.charge;
	        };
	    }
	
	    function step() {
	        if ((alpha *= .99) < .05) {
	            alpha = 0;
	            return true;
	        }
	
	        var q = void 0,
	            o = void 0,
	            s = void 0,
	            t = void 0,
	            l = void 0,
	            k = void 0,
	            x = void 0,
	            y = void 0;
	        var n = nodes.length;
	        var m = edges.length;
	
	        for (var i = 0; i < m; i++) {
	            o = edges[i];
	            s = o.source;
	            t = o.target;
	            x = t.x - s.x;
	            y = t.y - s.y;
	            if (l = x * x + y * y) {
	                l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	                x *= l;
	                y *= l;
	                t.x -= x * (k = s.weight / (t.weight + s.weight));
	                t.y -= y * k;
	                s.x += x * (k = 1 - k);
	                s.y += y * k;
	            }
	        }
	
	        if (k = alpha * gravity) {
	            x = size[0] / 2;
	            y = size[1] / 2;
	
	            for (var _i = 0; _i < n; _i++) {
	                o = nodes[_i];
	                o.x += (x - o.x) * k;
	                o.y += (y - o.y) * k;
	            }
	        }
	
	        if (charge) {
	            accumulate(q = (0, _quadTree2.default)(nodes), alpha, charges);
	
	            for (var _i2 = 0; _i2 < n; _i2++) {
	                var _o = nodes[_i2];
	                !_o.fixed && q.visit(repulse(_o));
	            }
	        }
	
	        var rnd = function rnd(min, max) {
	            return Math.random() * (max - min) + min;
	        };
	        for (var _i3 = 0; _i3 < n; _i3++) {
	            o = nodes[_i3];
	            if (o.fixed || o.fixed2) {
	                o.x = o.px;
	                o.y = o.py;
	            } else {
	                o.x -= (o.px - (o.px = o.x)) * friction;
	                o.y -= (o.py - (o.py = o.y)) * friction;
	
	                if (options && options.minX !== undefined) {
	                    if (o.x < options.minX || o.x > options.maxX) {
	                        o.x = rnd(options.minX, options.maxX);
	                    }
	                    if (o.y < options.minY || o.y > options.maxY) {
	                        o.y = rnd(options.minY, options.maxY);
	                    }
	                }
	            }
	        }
	    };
	
	    this.apply = function () {
	        var n = nodes.length;
	        var d = Math.sqrt(n);
	        var s = 0.3 / d;
	
	        for (var i = 0; i < n; i++) {
	            var o = nodes[i];
	            o.weight = 0;
	            o.x = o.x !== undefined ? o.x : s + i % d / d;
	            o.y = o.y !== undefined ? o.y : s + Math.floor(i / d) / d;
	            o.px = o.x;
	            o.py = o.y;
	            charges[i] = charge;
	        }
	
	        for (var _i4 = 0; _i4 < edges.length; _i4++) {
	            var _o2 = edges[_i4];
	            _o2.source.weight++;
	            _o2.target.weight++;
	            distances[_i4] = edgeDistance;
	            strengths[_i4] = edgeStrength;
	        }
	
	        alpha = 0.1;
	        while (!step()) {}
	
	        return true;
	    };
	};
	
	var _quadTree = __webpack_require__(11);
	
	var _quadTree2 = _interopRequireDefault(_quadTree);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (points) {
	    var d = void 0,
	        xs = void 0,
	        ys = void 0,
	        i = void 0,
	        n = void 0,
	        x1_ = void 0,
	        y1_ = void 0,
	        x2_ = void 0,
	        y2_ = void 0;
	
	    x2_ = y2_ = -(x1_ = y1_ = Infinity);
	    xs = [], ys = [];
	    n = points.length;
	
	    for (i = 0; i < n; ++i) {
	        d = points[i];
	        if (d.x < x1_) x1_ = d.x;
	        if (d.y < y1_) y1_ = d.y;
	        if (d.x > x2_) x2_ = d.x;
	        if (d.y > y2_) y2_ = d.y;
	        xs.push(d.x);
	        ys.push(d.y);
	    }
	
	    var dx = x2_ - x1_;
	    var dy = y2_ - y1_;
	    dx > dy ? y2_ = y1_ + dx : x2_ = x1_ + dy;
	
	    function create() {
	        return {
	            leaf: true,
	            nodes: [],
	            point: null,
	            x: null,
	            y: null
	        };
	    }
	
	    function visit(f, node, x1, y1, x2, y2) {
	        if (!f(node, x1, y1, x2, y2)) {
	            var sx = (x1 + x2) * 0.5;
	            var sy = (y1 + y2) * 0.5;
	            var children = node.nodes;
	
	            if (children[0]) visit(f, children[0], x1, y1, sx, sy);
	            if (children[1]) visit(f, children[1], sx, y1, x2, sy);
	            if (children[2]) visit(f, children[2], x1, sy, sx, y2);
	            if (children[3]) visit(f, children[3], sx, sy, x2, y2);
	        }
	    }
	
	    function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (n.leaf) {
	            var nx = n.x;
	            var ny = n.y;
	
	            if (nx !== null) {
	                if (nx === x && ny === y) {
	                    insertChild(n, d, x, y, x1, y1, x2, y2);
	                } else {
	                    var nPoint = n.point;
	                    n.x = n.y = n.point = null;
	                    insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	                    insertChild(n, d, x, y, x1, y1, x2, y2);
	                }
	            } else {
	                n.x = x, n.y = y, n.point = d;
	            }
	        } else {
	            insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	    }
	
	    function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * 0.5;
	        var ym = (y1 + y2) * 0.5;
	        var right = x >= xm;
	        var below = y >= ym;
	        var i = below << 1 | right;
	
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = create());
	
	        right ? x1 = xm : x2 = xm;
	        below ? y1 = ym : y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	    }
	
	    function findNode(root, x, y, x0, y0, x3, y3) {
	        var minDistance2 = Infinity;
	        var closestPoint = void 0;
	
	        (function find(node, x1, y1, x2, y2) {
	            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	
	            if (point = node.point) {
	                var _point = void 0;
	                var _dx = x - node.x;
	                var _dy = y - node.y;
	                var distance2 = _dx * _dx + _dy * _dy;
	
	                if (distance2 < minDistance2) {
	                    var distance = Math.sqrt(minDistance2 = distance2);
	                    x0 = x - distance, y0 = y - distance;
	                    x3 = x + distance, y3 = y + distance;
	                    closestPoint = _point;
	                }
	            }
	
	            var children = node.nodes;
	            var xm = (x1 + x2) * .5;
	            var ym = (y1 + y2) * .5;
	            var right = x >= xm;
	            var below = y >= ym;
	
	            for (var _i = below << 1 | right, j = _i + 4; _i < j; ++_i) {
	                if (node = children[_i & 3]) switch (_i & 3) {
	                    case 0:
	                        find(node, x1, y1, xm, ym);break;
	                    case 1:
	                        find(node, xm, y1, x2, ym);break;
	                    case 2:
	                        find(node, x1, ym, xm, y2);break;
	                    case 3:
	                        find(node, xm, ym, x2, y2);break;
	                }
	            }
	        })(root, x0, y0, x3, y3);
	
	        return closestPoint;
	    }
	
	    var root = create();
	    root.visit = function (f) {
	        return visit(f, root, x1_, y1_, x2_, y2_);
	    };
	    root.find = function (x, y) {
	        return findNode(root, x, y, x1_, y1_, x2_, y2_);
	    };
	
	    for (i = 0; i < n; i++) {
	        insert(root, points[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	    }--i;
	
	    xs = ys = points = d = null;
	
	    return root;
	};
	
	; /**
	   *  Copyright (c) 2016, Helikar Lab.
	   *  All rights reserved.
	   *
	   *  This source code is licensed under the GPLv3 License.
	   *  Author: David Tichy
	   */

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: David Tichy
	 */
	
	var _class = function () {
	  function _class(nodes) {
	    _classCallCheck(this, _class);
	
	    this._nodes = nodes;
	  }
	
	  _createClass(_class, [{
	    key: "apply",
	    value: function apply() {
	      for (var i = 0, n = this._nodes.length; i < n; i++) {
	        var o = this._nodes[i];
	        o.x = Math.random();
	        o.y = Math.random();
	      }
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2017, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Author: Renato Fabbri
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	    // get degree of all nodes
	    // let user define at least: starting angle and radius and
	    // clock/cclock direction
	    // size of vertices
	    // more: a ratio of compactness for the more/less connected nodes
	    // a spiral ratio with a rotation ratio for having more than 2pi
	    // distribution of nodes when spiriling
	    // use some other ordering criterion than degree? Strength?
	    // defined by user and found as attribute of each node?
	    // random ordering, minimal crossing of edges?
	    function _class(nodes, edges, layout_options) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	        this._angle_step = 2 * Math.PI / nodes.length;
	        if (layout_options.starting_angle == null) this._starting_angle = 0;else this._starting_angle = layout_options.starting_angle;
	    }
	
	    _createClass(_class, [{
	        key: 'apply',
	        value: function apply() {
	            var nd = (0, _utils.degrees)(this._nodes, this._edges);
	            for (var i = 0; i < this._nodes.length; ++i) {
	                this._nodes[nd.nodes[i].index].x = 0.05 + (1 + Math.cos(this._starting_angle + i * this._angle_step)) * .45;
	                this._nodes[nd.nodes[i].index].y = 0.05 + (1 + Math.sin(this._starting_angle + i * this._angle_step)) * .45;
	                this._nodes[nd.nodes[i].index].weight = nd.degrees[i];
	            }
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.create2dArray = create2dArray;
	exports.degrees = degrees;
	exports.getDepth = getDepth;
	exports.getRanges = getRanges;
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/**
	 *  Copyright (c) 2017, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: Renato Fabbri
	 */
	
	function create2dArray(rows, columns) {
	    return [].concat(_toConsumableArray(Array(rows).keys())).map(function (i) {
	        return Array(columns).fill(0);
	    });
	}
	
	function degrees(nodes, edges) {
	    // should return ordered nodes and their degrees - high to low
	    var degrees = Array(nodes.length).fill(0);
	    edges.forEach(function (e) {
	        degrees[e.source.index] += 1;
	        degrees[e.target.index] += 1;
	    }); // check to see if not getting double of the degree in undirected graphs
	    //getting the order of nodes from highest to lowest degrees
	    var ordered_nodes = degrees.map(function (el, i) {
	        return { index: i, value: el };
	    });
	    ordered_nodes.sort(function (a, b) {
	        return +(a.value < b.value) || +(a.value === b.value) - 1;
	    });
	    var ordered_degrees = ordered_nodes.map(function (el) {
	        return degrees[el.index];
	    });
	    return { nodes: ordered_nodes,
	        degrees: ordered_degrees };
	}
	
	function getDepth(obj) {
	    var depth = 0;
	    if (obj.children) {
	        obj.children.forEach(function (d) {
	            if (d.depth_visited == true) {
	                throw new Error("This layout is only for trees acyclic graphs");
	            }
	            d.depth_visited = true;
	            var tmpDepth = getDepth(d);
	            if (tmpDepth > depth) {
	                depth = tmpDepth;
	            }
	        });
	    }
	    return 1 + depth;
	}
	
	function getRanges(n) {
	    n = Math.abs(n);
	    if (n <= 1) {
	        return {
	            start: 0.5,
	            step: 1
	        };
	    }
	    var start = .05;
	    return {
	        start: start,
	        step: (1 - 2 * start) / (n - 1)
	    };
	}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2017, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Author: Renato Fabbri
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	    }
	
	    _createClass(_class, [{
	        key: 'drawTreeCentered',
	        value: function drawTreeCentered(root) {
	            var visited_leafs_parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	            var layer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	
	            root.centered = true;
	            root.depth_visited = false; // so that getDepth does not raise error if another tree layout is called subsequently
	            // branch order is for now stable but unpredictable, see layouts.cri
	            var visited_leafs = 0;
	            for (var i = 0; i < root.children.length; i++) {
	                var child = root.children[i];
	                if (child.centered != true) {
	                    visited_leafs += this.drawTreeCentered(child, visited_leafs + visited_leafs_parent, layer + 1);
	                }
	            }
	            if (root.children == 0) {
	                visited_leafs++;
	            }
	            // moving to parent, position node
	            root.y = this.stepy * (visited_leafs_parent + (visited_leafs - 1) / 2) + this.alphay;
	            root.x = (layer - 1) * this.stepx + this.alphax;
	            return visited_leafs;
	        }
	    }, {
	        key: 'apply',
	        value: function apply() {
	            // only one root node supported for now
	            // left-right tree by default, let user choose
	            // top-down, bottom-top, right-left in subsequent versions
	            // hierarchical layouts for non-trees (cyclical graphs) should be
	            // implemented separately for now
	            var nodes = this._nodes;
	            // make hierarchy, annotate parent(s) and children in the nodes
	            nodes.forEach(function (n, i) {
	                n.parents = [];
	                n.children = [];
	                n.centered = false;
	            });
	            this._edges.forEach(function (e, i) {
	                e.source.children.push(e.target);
	                e.target.parents.push(e.source);
	            });
	            // find the root
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].parents.length == 0) {
	                    var root = nodes[i];
	                    break;
	                }
	            }
	            var depth = (0, _utils.getDepth)(root);
	            // each layer of tree x = [0+alpha,1-alpha]
	            var r = (0, _utils.getRanges)(depth);
	            this.alphax = r.start;
	            this.stepx = r.step;
	            // posx = alphax + stepx*(depth-1)
	
	            // find the number of leafs to distribute nodes vertically
	            var leafs = 0;
	            nodes.forEach(function (node) {
	                if (node.children.length == 0) {
	                    leafs++;
	                }
	            });
	            r = (0, _utils.getRanges)(leafs);
	            // each leaf y = [0+alpha,1-alpha]
	            this.alphay = r.start;
	            this.stepy = r.step;
	            // posy = alphay + stepy*(leafn-1)
	
	            this.drawTreeCentered(root);
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2017, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Author: Renato Fabbri
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	    }
	
	    _createClass(_class, [{
	        key: 'drawTreeTop',
	        value: function drawTreeTop(root) {
	            var visited_leafs_parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	            var layer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	
	            // each node is in vertically on the top of the stack of its leafs
	            root.visited = true;
	            root.depth_visited = false; // so that getDepth does not raise error if another tree layout is called subsequently
	            root.x = this.alphax + this.stepx * (layer - 1);
	            root.y = 1 - (this.alphay + this.stepy * visited_leafs_parent);
	            // visit children until leafs
	            var visited_leafs = 0;
	            for (var i = 0; i < root.children.length; i++) {
	                var child = root.children[i];
	                if (child.centered != true) {
	                    visited_leafs += this.drawTreeTop(child, visited_leafs + visited_leafs_parent, layer + 1);
	                }
	            }
	            if (root.children.length == 0) {
	                visited_leafs++;
	            }
	            return visited_leafs;
	        }
	    }, {
	        key: 'apply',
	        value: function apply() {
	            var nodes = this._nodes;
	            // make hierarchy, annotate parent(s) and children in the nodes
	            // this layout can be run on any graph actually
	            // for which the children might be selected e.g. for their degree
	            // draw can be decided on other measures, such as closeness centrality or clustering
	            nodes.forEach(function (n, i) {
	                n.parents = [];
	                n.children = [];
	                n.centered = false;
	            });
	            this._edges.forEach(function (e, i) {
	                e.source.children.push(e.target);
	                e.target.parents.push(e.source);
	            });
	            // find the root
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].parents.length == 0) {
	                    var root = nodes[i];
	                    break;
	                }
	            }
	            var depth = (0, _utils.getDepth)(root);
	            // each layer of tree x = [0+alpha,1-alpha]
	            var r = (0, _utils.getRanges)(depth);
	            this.alphax = r.start;
	            this.stepx = r.step;
	            // posx = alphax + stepx*(depth-1)
	
	            // find the number of leafs to distribute nodes vertically
	            var leafs = 0;
	            nodes.forEach(function (node) {
	                if (node.children.length == 0) {
	                    leafs++;
	                }
	            });
	            // each leaf y = [0+alpha,1-alpha]
	            r = (0, _utils.getRanges)(leafs);
	            this.alphay = r.start;
	            this.stepy = r.step;
	            // posy = alphay + stepy*(leafn-1)
	
	            // give nodes their positions
	            // plot each branch in depth first,
	            // increment y position for each leaf
	            // backtracking to go from leaf to parents
	            // and decide if parent is visited (always in tree layout)
	
	            this.drawTreeTop(root);
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2017, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: Renato Fabbri
	 */
	
	var _class = function () {
	    // this layout should handle any digraph
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	        this.alphay = 0.05; // y margin
	        this.alphax = 0.05; // x margin
	    }
	
	    _createClass(_class, [{
	        key: "makeLayers",
	        value: function makeLayers(nodes, layer) {
	            if (nodes.length > 1) {
	                var stepy = (1 - 2 * this.alphay) / (nodes.length - 1);
	                for (var i = 0; i < nodes.length; ++i) {
	                    nodes[i].visited = true;
	                    nodes[i].layer = layer; // makes x afterwards
	                    nodes[i].y = this.alphay + i * stepy;
	                }
	            } else {
	                nodes[0].visited = true;
	                nodes[0].layer = layer; // makes x afterwards
	                nodes[0].y = 0.5;
	            }
	            var next_layer = [];
	            for (var _i = 0; _i < nodes.length; _i++) {
	                var neighbors = nodes[_i].parents.concat(nodes[_i].children);
	                for (var j = 0; j < neighbors.length; j++) {
	                    if (neighbors[j].visited == false && !next_layer.includes(neighbors[j])) {
	                        next_layer.push(neighbors[j]);
	                    }
	                }
	            }
	            if (next_layer.length == 0) {
	                return layer;
	            } else {
	                return this.makeLayers(next_layer, layer + 1);
	            }
	        }
	    }, {
	        key: "apply",
	        value: function apply() {
	            // left-right tree by default, let user choose
	            // top-down, bottom-top, right-left in subsequent versions
	            // hierarchical layouts for trees (acyclic graphs) are
	            // implemented separately for now
	            var nodes = this._nodes;
	            nodes.forEach(function (n, i) {
	                n.parents = [];
	                n.children = [];
	                n.visited = false;
	            });
	            this._edges.forEach(function (e, i) {
	                e.source.children.push(e.target);
	                e.target.parents.push(e.source);
	            });
	            // find the roots:
	            // nodes defined by the user as roots OR
	            // nodes with in-degree == 0 OR
	            // nodes with greatest in-degree (or degree if undirected graph)
	            var roots = [];
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].isroot == true) {
	                    // has to be on the json file of the graph
	                    roots.push(nodes[i]);
	                }
	            }
	            if (roots.length == 0) {
	                for (var _i2 = 0; _i2 < nodes.length; _i2++) {
	                    if (nodes[_i2].parents.length == 0) {
	                        roots.push(nodes[_i2]);
	                    }
	                }
	            }
	            if (roots.length == 0) {
	                // calculate max out-degree
	                var max_outdegree = 0;
	                nodes.forEach(function (node) {
	                    if (node.children.length > max_outdegree) {
	                        max_outdegree = node.children.length;
	                    }
	                });
	                // choose vertices with greatest out-degree
	                nodes.forEach(function (node) {
	                    if (node.children.length == max_outdegree) {
	                        roots.push(node);
	                    }
	                });
	            }
	            // number of layers and max number of nodes in each layer
	            // has to be found by making the layout
	            // there are two approaches to finding the nodes in each layer:
	            // 1) each layer has all the neighbors of the nodes in the previous layer
	            // 2) follow links and then place non visited nodes on the layer of neighbors OR
	            // this layout implements the first of these approaches.
	            var depth = this.makeLayers(roots, 1);
	            // each layer of tree x = [0+alpha,1-alpha]
	            var stepx = (1 - 2 * this.alphax) / (depth - 1);
	            // posx = alphax + stepx*(depth-1)
	            for (var _i3 = 0; _i3 < this._nodes.length; ++_i3) {
	                this._nodes[_i3].x = this.alphax + stepx * (this._nodes[_i3].layer - 1);
	            }
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2017, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: Renato Fabbri
	 */
	
	function isOrphan(node) {
	    var orphan = true;
	    for (var i = 0; i < node.parents.length; ++i) {
	        var parent_ = node.parents[i];
	        if (parent_ != node) orphan = false;
	    }
	    for (var _i = 0; _i < node.children.length; ++_i) {
	        var child = node.children[_i];
	        if (child != node) orphan = false;
	    }
	    return orphan;
	}
	
	var _class = function () {
	    // this layout should handle any digraph
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	        this.alphay = 0.05; // y margin
	        this.alphax = 0.05; // x margin
	        this.components = { "current_component": 0, "depth": 1 };
	        this.unvisited = nodes;
	    }
	
	    _createClass(_class, [{
	        key: "initHierarchy",
	        value: function initHierarchy() {
	            this._nodes.forEach(function (n, i) {
	                n.parents = [];
	                n.children = [];
	                n.visited = false;
	            });
	            this._edges.forEach(function (e, i) {
	                e.source.children.push(e.target);
	                e.target.parents.push(e.source);
	            });
	        }
	    }, {
	        key: "separateOrphans",
	        value: function separateOrphans() {
	            var orphans = [];
	            var nodes = [];
	            for (var i = 0; i < this._nodes.length; ++i) {
	                var node = this._nodes[i];
	                if (isOrphan(node)) orphans.push(node);else nodes.push(node);
	            }
	            return orphans;
	        }
	    }, {
	        key: "findRoots",
	        value: function findRoots(nodes) {
	            // find the roots:
	            // nodes defined by the user as roots OR
	            // nodes with in-degree == 0 OR
	            // nodes with greatest in-degree (or degree if undirected graph)
	            var roots = [];
	            for (var i = 0; i < nodes.length; i++) {
	                if (nodes[i].isroot == true) {
	                    // has to be on the json file of the graph
	                    roots.push(nodes[i]);
	                }
	            }
	            if (roots.length == 0) {
	                for (var _i2 = 0; _i2 < nodes.length; _i2++) {
	                    if (nodes[_i2].parents.length == 0) {
	                        roots.push(nodes[_i2]);
	                    }
	                }
	            }
	            if (roots.length == 0) {
	                // calculate max out-degree
	                var max_outdegree = 0;
	                nodes.forEach(function (node) {
	                    if (node.children.length > max_outdegree) {
	                        max_outdegree = node.children.length;
	                    }
	                });
	                // choose vertices with greatest out-degree
	                nodes.forEach(function (node) {
	                    if (node.children.length == max_outdegree) {
	                        roots.push(node);
	                    }
	                });
	            }
	            return roots;
	        }
	    }, {
	        key: "placeOrphans",
	        value: function placeOrphans(nodes, max_layer) {
	            var stepy = (1 - 2 * this.alphay) / (nodes.length - 1);
	            for (var i = 0; i < nodes.length; ++i) {
	                nodes[i].y = this.alphay + i * stepy;
	                nodes[i].x = max_layer + 1;
	            }
	            if (nodes.length > 0) return max_layer + 1;else return max_layer;
	        }
	    }, {
	        key: "unvisitedNodes",
	        value: function unvisitedNodes() {
	            var nodes = [];
	            var orphans = this.orphans;
	            this.unvisited.forEach(function (node) {
	                if (node.visited == false && !(node in orphans)) nodes.push(node);
	            });
	            if (nodes.length != this.unvisited) {
	                this.maybe_more = true;
	                this.unvisited = nodes;
	            } else this.maybe_more = false;
	        }
	    }, {
	        key: "placeAdditional",
	        value: function placeAdditional() {
	            // place non-visited nodes in between layers
	            var aux_layers = {};
	            var c = this.components[this.components.current_component];
	            var layers = c.layers;
	            for (var i = 0; i < this.unvisited.length; ++i) {
	                var node = this.unvisited[i];
	                var lowest_layer = this.components.depth;
	                var child_found = false;
	                for (var j = 0; j < node.children.length; ++j) {
	                    var child = node.children[j];
	                    if (child.visited == true) {
	                        child_found = true;
	                        if (child.layer <= lowest_layer) {
	                            // child has to be visited to have a layer
	                            lowest_layer = child.layer;
	                        }
	                        break;
	                    }
	                }
	                if (child_found) {
	                    node.visited = true;
	                    // node.index = lowest_layer-sep;
	                    if (!(lowest_layer - sep in layers)) layers[lowest_layer - sep] = [];
	                    layers[lowest_layer - sep].push(node);
	                } else {
	                    var _lowest_layer = max_layer;
	                    var parent_found = false;
	                    for (var _j = 0; _j < node.parents.length; ++_j) {
	                        var parent_ = node.parents[_j];
	                        if (parent_.visited == true) {
	                            parent_found = true;
	                            if (parent_.layer <= _lowest_layer) {
	                                // child has to be visited to have a layer
	                                _lowest_layer = parent_.layer;
	                            }
	                        }
	                    }
	                    if (parent_found) {
	                        node.visited = true;
	                        node.x = _lowest_layer + sep;
	                        if (!(_lowest_layer + sep in layers)) layers[_lowest_layer + sep] = [];
	                        layers[_lowest_layer + sep].push(node);
	                    }
	                }
	            }
	        }
	    }, {
	        key: "initializeComponent",
	        value: function initializeComponent(component) {
	            this.components[component] = {};
	            this.components[component].max_nodes_layer = 0;
	            if (component > 0) this.components[component].index_offset = this.components[component - 1].vertical_nodes;else this.components[component].index_offset = 0;
	            this.components[component].current_layer = 1;
	            //this.components[component].layers = {"nodes": [], "layer_value": 1};
	            this.components[component].layers = {};
	            this.components[component].vertical_nodes = 0;
	        }
	    }, {
	        key: "layerNodes",
	        value: function layerNodes(nodes) {
	            if (!(this.components.current_component in this.components)) this.initializeComponent(this.components.current_component);
	            var c = this.components[this.components.current_component];
	            if (nodes.length > c.vertical_nodes) c.vertical_nodes = nodes.length;
	            c.layers[c.current_layer] = [];
	            for (var i = 0; i < nodes.length; ++i) {
	                nodes[i].visited = true;
	                c.layers[c.current_layer].push(nodes[i]);
	            }
	            var next_layer = [];
	            for (var _i3 = 0; _i3 < nodes.length; _i3++) {
	                var candidates = nodes[_i3].children;
	                for (var j = 0; j < candidates.length; j++) {
	                    if (candidates[j].visited == false && !next_layer.includes(candidates[j])) {
	                        next_layer.push(candidates[j]);
	                    }
	                }
	            }
	            if (next_layer.length > 0) {
	                c.current_layer++;
	                if (this.components.depth < c.current_layer) this.components.depth = c.current_layer;
	                this.layerNodes(next_layer);
	            }
	        }
	    }, {
	        key: "apply",
	        value: function apply() {
	            // left-right tree by default, let user choose
	            // top-down, bottom-top, right-left in subsequent versions
	            // hierarchical layouts for trees (acyclic graphs) are
	            // implemented separately for now
	
	            // number of layers and max number of nodes in each layer
	            // has to be found by making the layout
	            // there are two approaches to finding the nodes in each layer:
	            // 1) each layer has all the neighbors of the nodes in the previous layer
	            // 2) follow links and then place non visited nodes on the layer of neighbors OR
	            // this layout implements the second of these approaches.
	
	            this.initHierarchy();
	            this.orphans = this.separateOrphans();
	            this.unvisitedNodes();
	            while (this.unvisited.length > 0) {
	                var roots = this.findRoots(this.unvisited);
	                this.layerNodes(roots);
	                this.unvisitedNodes(); // update unvisited nodes
	                this.maybe_mode = true;
	                while (this.maybe_more) {
	                    this.placeAdditional(); // place additional nodes linked to this component
	                    this.unvisitedNodes(); // update unvisited nodes
	                }
	                this.components.current_component++;
	            }
	            this.components.vertical_nodes = 0;
	            for (var i = 0; i < this.components.current_component; i++) {
	                this.components.vertical_nodes += this.components[i].vertical_nodes;
	            }
	
	            // layerNodes should populate the dictionary this.components of components and aux variables:
	            // components[x] is a component, x is an integer
	            // components[x].vertical_nodes is the maximum number of nodes in a layer for the component
	            // components[x].layer[j] is the j-th layer on the component, j can be fractional
	            // components[x].index_offset is the number of nodes positioned in above components
	            // components.ncomponents is the number of components
	            // components.vertical_nodes is the sum of the max nodes in any layer of each component
	            // components.depth is the maximum number of layers
	
	            // each layer of tree xy = [0+alpha,1-alpha]
	            var stepx = (1 - 2 * this.alphax) / this.components.depth;
	            var stepy = (1 - 2 * this.alphay) / this.components.vertical_nodes;
	            for (var _i4 = 0; _i4 < this.components.current_component; _i4++) {
	                var component = this.components[_i4];
	                for (var layer_val in component.layers) {
	                    var layer = component.layers[layer_val];
	                    if (layer.length == 1) {
	                        var node = layer[0];
	                        node.x = this.alphax + stepx * layer_val;
	                        node.y = this.alphay + stepy * (component.index_offset + component.vertical_nodes / 2);
	                    } else {
	                        for (var k = 0; k < layer.length; ++k) {
	                            var _node = layer[k];
	                            _node.x = this.alphax + stepx * layer_val;
	                            _node.y = this.alphay + stepy * (component.index_offset + k);
	                        }
	                    }
	                }
	            }
	            this.placeOrphans(this.orphans);
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2017, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Author: Renato Fabbri
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _mlMatrix = __webpack_require__(20);
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function twoSmallest(arr) {
	    var min = Math.min.apply(null, arr),
	        // get the max of the array
	    mini = arr.indexOf(min);
	    arr[mini] = Infinity; // replace max in the array with -infinity
	    var second_min = Math.min.apply(null, arr),
	        // get the new max 
	    second_mini = arr.indexOf(second_min);
	    arr[second_mini] = Infinity; // replace max in the array with -infinity
	    var third_min = Math.min.apply(null, arr),
	        // get the new max 
	    third_mini = arr.indexOf(third_min);
	    return [second_mini, third_mini];
	}
	
	function normalize(x, y) {
	    var maxx = Math.max.apply(null, x.map(Math.abs)),
	        maxy = Math.max.apply(null, y.map(Math.abs));
	    var minx = Math.min.apply(null, x),
	        miny = Math.min.apply(null, y);
	    for (var i = 0; i < x.length; ++i) {
	        x[i] = 0.1 + (x[i] - minx) / ((maxx - minx) * 1.25);
	        y[i] = 0.1 + (y[i] - miny) / ((maxy - miny) * 1.25);
	    }
	    return [x, y];
	}
	
	var _class = function () {
	    // get degree of all nodes
	    // let user define at least: starting angle and radius and
	    // clock/cclock direction
	    // size of vertices
	    // more: a ratio of compactness for the more/less connected nodes
	    // a spiral ratio with a rotation ratio for having more than 2pi
	    // distribution of nodes when spiriling
	    // use some other ordering criterion than degree? Strength?
	    // defined by user and found as attribute of each node?
	    // random ordering, minimal crossing of edges?
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	    }
	
	    _createClass(_class, [{
	        key: 'apply',
	        value: function apply() {
	            var A = (0, _utils.create2dArray)(this._nodes.length, this._nodes.length);
	            // build the adjacency matrix
	            for (var i = 0; i < this._edges.length; ++i) {
	                var ii = this._edges[i].source.index;
	                var j = this._edges[i].target.index;
	                A[ii][j] = -1; // not considering edge weight for now (the example json files don't have weight)
	                A[j][ii] = -1; // not considering edge weight for now (the example json files don't have weight)
	            }
	            // build the diagonal of degrees
	            // NOT subtract adjacency from degrees but:
	            // substitute diagonal by degrees
	            for (var _i = 0; _i < this._nodes.length; ++_i) {
	                A[_i][_i] = -A[_i].reduce(function (a, b) {
	                    return a + b;
	                }, 0);
	            }
	            var foo = new _mlMatrix.EigenvalueDecomposition(A);
	            var iii = twoSmallest(foo.realEigenvalues);
	            var foo_ = foo.eigenvectorMatrix.transpose();
	            var x = foo_[iii[0]];
	            var y = foo_[iii[1]];
	            var xy = normalize(x, y);
	            // var fooo = new Matrix.EigenvalueDecomposition(A);
	            // var fooo = new Matrix.EigenvalueDecomposition(A);
	            // recipe from http://www.sfu.ca/personal/archives/richards/Pages/NAS.AJS-WDR.pdf
	            // and implemented in networkx/drawing/layout.py
	            this._nodes.forEach(function (node, i) {
	                node.x = xy[0][i];
	                node.y = xy[1][i];
	            });
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
	
	var rescale = _interopDefault(__webpack_require__(21));
	
	if (!Symbol.species) {
	    Symbol.species = Symbol.for('@@species');
	}
	
	/**
	 * @class LuDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
	 * @param {Matrix} matrix
	 */
	class LuDecomposition$$1 {
	    constructor(matrix) {
	        matrix = WrapperMatrix2D.checkMatrix(matrix);
	
	        var lu = matrix.clone();
	        var rows = lu.rows;
	        var columns = lu.columns;
	        var pivotVector = new Array(rows);
	        var pivotSign = 1;
	        var i, j, k, p, s, t, v;
	        var LUcolj, kmax;
	
	        for (i = 0; i < rows; i++) {
	            pivotVector[i] = i;
	        }
	
	        LUcolj = new Array(rows);
	
	        for (j = 0; j < columns; j++) {
	
	            for (i = 0; i < rows; i++) {
	                LUcolj[i] = lu.get(i, j);
	            }
	
	            for (i = 0; i < rows; i++) {
	                kmax = Math.min(i, j);
	                s = 0;
	                for (k = 0; k < kmax; k++) {
	                    s += lu.get(i, k) * LUcolj[k];
	                }
	                LUcolj[i] -= s;
	                lu.set(i, j, LUcolj[i]);
	            }
	
	            p = j;
	            for (i = j + 1; i < rows; i++) {
	                if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
	                    p = i;
	                }
	            }
	
	            if (p !== j) {
	                for (k = 0; k < columns; k++) {
	                    t = lu.get(p, k);
	                    lu.set(p, k, lu.get(j, k));
	                    lu.set(j, k, t);
	                }
	
	                v = pivotVector[p];
	                pivotVector[p] = pivotVector[j];
	                pivotVector[j] = v;
	
	                pivotSign = -pivotSign;
	            }
	
	            if (j < rows && lu.get(j, j) !== 0) {
	                for (i = j + 1; i < rows; i++) {
	                    lu.set(i, j, lu.get(i, j) / lu.get(j, j));
	                }
	            }
	        }
	
	        this.LU = lu;
	        this.pivotVector = pivotVector;
	        this.pivotSign = pivotSign;
	    }
	
	    /**
	     *
	     * @return {boolean}
	     */
	    isSingular() {
	        var data = this.LU;
	        var col = data.columns;
	        for (var j = 0; j < col; j++) {
	            if (data[j][j] === 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    /**
	     *
	     * @param {Matrix} value
	     * @return {Matrix}
	     */
	    solve(value) {
	        value = Matrix.checkMatrix(value);
	
	        var lu = this.LU;
	        var rows = lu.rows;
	
	        if (rows !== value.rows) {
	            throw new Error('Invalid matrix dimensions');
	        }
	        if (this.isSingular()) {
	            throw new Error('LU matrix is singular');
	        }
	
	        var count = value.columns;
	        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);
	        var columns = lu.columns;
	        var i, j, k;
	
	        for (k = 0; k < columns; k++) {
	            for (i = k + 1; i < columns; i++) {
	                for (j = 0; j < count; j++) {
	                    X[i][j] -= X[k][j] * lu[i][k];
	                }
	            }
	        }
	        for (k = columns - 1; k >= 0; k--) {
	            for (j = 0; j < count; j++) {
	                X[k][j] /= lu[k][k];
	            }
	            for (i = 0; i < k; i++) {
	                for (j = 0; j < count; j++) {
	                    X[i][j] -= X[k][j] * lu[i][k];
	                }
	            }
	        }
	        return X;
	    }
	
	    /**
	     *
	     * @return {number}
	     */
	    get determinant() {
	        var data = this.LU;
	        if (!data.isSquare()) {
	            throw new Error('Matrix must be square');
	        }
	        var determinant = this.pivotSign;
	        var col = data.columns;
	        for (var j = 0; j < col; j++) {
	            determinant *= data[j][j];
	        }
	        return determinant;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get lowerTriangularMatrix() {
	        var data = this.LU;
	        var rows = data.rows;
	        var columns = data.columns;
	        var X = new Matrix(rows, columns);
	        for (var i = 0; i < rows; i++) {
	            for (var j = 0; j < columns; j++) {
	                if (i > j) {
	                    X[i][j] = data[i][j];
	                } else if (i === j) {
	                    X[i][j] = 1;
	                } else {
	                    X[i][j] = 0;
	                }
	            }
	        }
	        return X;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get upperTriangularMatrix() {
	        var data = this.LU;
	        var rows = data.rows;
	        var columns = data.columns;
	        var X = new Matrix(rows, columns);
	        for (var i = 0; i < rows; i++) {
	            for (var j = 0; j < columns; j++) {
	                if (i <= j) {
	                    X[i][j] = data[i][j];
	                } else {
	                    X[i][j] = 0;
	                }
	            }
	        }
	        return X;
	    }
	
	    /**
	     *
	     * @return {Array<number>}
	     */
	    get pivotPermutationVector() {
	        return this.pivotVector.slice();
	    }
	}
	
	function hypotenuse(a, b) {
	    var r = 0;
	    if (Math.abs(a) > Math.abs(b)) {
	        r = b / a;
	        return Math.abs(a) * Math.sqrt(1 + r * r);
	    }
	    if (b !== 0) {
	        r = a / b;
	        return Math.abs(b) * Math.sqrt(1 + r * r);
	    }
	    return 0;
	}
	
	function getFilled2DArray(rows, columns, value) {
	    var array = new Array(rows);
	    for (var i = 0; i < rows; i++) {
	        array[i] = new Array(columns);
	        for (var j = 0; j < columns; j++) {
	            array[i][j] = value;
	        }
	    }
	    return array;
	}
	
	/**
	 * @class SingularValueDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs
	 * @param {Matrix} value
	 * @param {object} [options]
	 * @param {boolean} [options.computeLeftSingularVectors=true]
	 * @param {boolean} [options.computeRightSingularVectors=true]
	 * @param {boolean} [options.autoTranspose=false]
	 */
	class SingularValueDecomposition$$1 {
	    constructor(value, options = {}) {
	        value = WrapperMatrix2D.checkMatrix(value);
	
	        var m = value.rows;
	        var n = value.columns;
	        var nu = Math.min(m, n);
	
	        const {
	            computeLeftSingularVectors = true,
	            computeRightSingularVectors = true,
	            autoTranspose = false
	        } = options;
	
	        var wantu = Boolean(computeLeftSingularVectors);
	        var wantv = Boolean(computeRightSingularVectors);
	
	        var swapped = false;
	        var a;
	        if (m < n) {
	            if (!autoTranspose) {
	                a = value.clone();
	                // eslint-disable-next-line no-console
	                console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');
	            } else {
	                a = value.transpose();
	                m = a.rows;
	                n = a.columns;
	                swapped = true;
	                var aux = wantu;
	                wantu = wantv;
	                wantv = aux;
	            }
	        } else {
	            a = value.clone();
	        }
	
	        var s = new Array(Math.min(m + 1, n));
	        var U = getFilled2DArray(m, nu, 0);
	        var V = getFilled2DArray(n, n, 0);
	        var e = new Array(n);
	        var work = new Array(m);
	
	        var nct = Math.min(m - 1, n);
	        var nrt = Math.max(0, Math.min(n - 2, m));
	
	        var i, j, k, p, t, ks, f, cs, sn, max, kase,
	            scale, sp, spm1, epm1, sk, ek, b, c, shift, g;
	
	        for (k = 0, max = Math.max(nct, nrt); k < max; k++) {
	            if (k < nct) {
	                s[k] = 0;
	                for (i = k; i < m; i++) {
	                    s[k] = hypotenuse(s[k], a[i][k]);
	                }
	                if (s[k] !== 0) {
	                    if (a[k][k] < 0) {
	                        s[k] = -s[k];
	                    }
	                    for (i = k; i < m; i++) {
	                        a[i][k] /= s[k];
	                    }
	                    a[k][k] += 1;
	                }
	                s[k] = -s[k];
	            }
	
	            for (j = k + 1; j < n; j++) {
	                if ((k < nct) && (s[k] !== 0)) {
	                    t = 0;
	                    for (i = k; i < m; i++) {
	                        t += a[i][k] * a[i][j];
	                    }
	                    t = -t / a[k][k];
	                    for (i = k; i < m; i++) {
	                        a[i][j] += t * a[i][k];
	                    }
	                }
	                e[j] = a[k][j];
	            }
	
	            if (wantu && (k < nct)) {
	                for (i = k; i < m; i++) {
	                    U[i][k] = a[i][k];
	                }
	            }
	
	            if (k < nrt) {
	                e[k] = 0;
	                for (i = k + 1; i < n; i++) {
	                    e[k] = hypotenuse(e[k], e[i]);
	                }
	                if (e[k] !== 0) {
	                    if (e[k + 1] < 0) {
	                        e[k] = 0 - e[k];
	                    }
	                    for (i = k + 1; i < n; i++) {
	                        e[i] /= e[k];
	                    }
	                    e[k + 1] += 1;
	                }
	                e[k] = -e[k];
	                if ((k + 1 < m) && (e[k] !== 0)) {
	                    for (i = k + 1; i < m; i++) {
	                        work[i] = 0;
	                    }
	                    for (j = k + 1; j < n; j++) {
	                        for (i = k + 1; i < m; i++) {
	                            work[i] += e[j] * a[i][j];
	                        }
	                    }
	                    for (j = k + 1; j < n; j++) {
	                        t = -e[j] / e[k + 1];
	                        for (i = k + 1; i < m; i++) {
	                            a[i][j] += t * work[i];
	                        }
	                    }
	                }
	                if (wantv) {
	                    for (i = k + 1; i < n; i++) {
	                        V[i][k] = e[i];
	                    }
	                }
	            }
	        }
	
	        p = Math.min(n, m + 1);
	        if (nct < n) {
	            s[nct] = a[nct][nct];
	        }
	        if (m < p) {
	            s[p - 1] = 0;
	        }
	        if (nrt + 1 < p) {
	            e[nrt] = a[nrt][p - 1];
	        }
	        e[p - 1] = 0;
	
	        if (wantu) {
	            for (j = nct; j < nu; j++) {
	                for (i = 0; i < m; i++) {
	                    U[i][j] = 0;
	                }
	                U[j][j] = 1;
	            }
	            for (k = nct - 1; k >= 0; k--) {
	                if (s[k] !== 0) {
	                    for (j = k + 1; j < nu; j++) {
	                        t = 0;
	                        for (i = k; i < m; i++) {
	                            t += U[i][k] * U[i][j];
	                        }
	                        t = -t / U[k][k];
	                        for (i = k; i < m; i++) {
	                            U[i][j] += t * U[i][k];
	                        }
	                    }
	                    for (i = k; i < m; i++) {
	                        U[i][k] = -U[i][k];
	                    }
	                    U[k][k] = 1 + U[k][k];
	                    for (i = 0; i < k - 1; i++) {
	                        U[i][k] = 0;
	                    }
	                } else {
	                    for (i = 0; i < m; i++) {
	                        U[i][k] = 0;
	                    }
	                    U[k][k] = 1;
	                }
	            }
	        }
	
	        if (wantv) {
	            for (k = n - 1; k >= 0; k--) {
	                if ((k < nrt) && (e[k] !== 0)) {
	                    for (j = k + 1; j < n; j++) {
	                        t = 0;
	                        for (i = k + 1; i < n; i++) {
	                            t += V[i][k] * V[i][j];
	                        }
	                        t = -t / V[k + 1][k];
	                        for (i = k + 1; i < n; i++) {
	                            V[i][j] += t * V[i][k];
	                        }
	                    }
	                }
	                for (i = 0; i < n; i++) {
	                    V[i][k] = 0;
	                }
	                V[k][k] = 1;
	            }
	        }
	
	        var pp = p - 1;
	        var iter = 0;
	        var eps = Number.EPSILON;
	        while (p > 0) {
	            for (k = p - 2; k >= -1; k--) {
	                if (k === -1) {
	                    break;
	                }
	                if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
	                    e[k] = 0;
	                    break;
	                }
	            }
	            if (k === p - 2) {
	                kase = 4;
	            } else {
	                for (ks = p - 1; ks >= k; ks--) {
	                    if (ks === k) {
	                        break;
	                    }
	                    t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
	                    if (Math.abs(s[ks]) <= eps * t) {
	                        s[ks] = 0;
	                        break;
	                    }
	                }
	                if (ks === k) {
	                    kase = 3;
	                } else if (ks === p - 1) {
	                    kase = 1;
	                } else {
	                    kase = 2;
	                    k = ks;
	                }
	            }
	
	            k++;
	
	            switch (kase) {
	                case 1: {
	                    f = e[p - 2];
	                    e[p - 2] = 0;
	                    for (j = p - 2; j >= k; j--) {
	                        t = hypotenuse(s[j], f);
	                        cs = s[j] / t;
	                        sn = f / t;
	                        s[j] = t;
	                        if (j !== k) {
	                            f = -sn * e[j - 1];
	                            e[j - 1] = cs * e[j - 1];
	                        }
	                        if (wantv) {
	                            for (i = 0; i < n; i++) {
	                                t = cs * V[i][j] + sn * V[i][p - 1];
	                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
	                                V[i][j] = t;
	                            }
	                        }
	                    }
	                    break;
	                }
	                case 2 : {
	                    f = e[k - 1];
	                    e[k - 1] = 0;
	                    for (j = k; j < p; j++) {
	                        t = hypotenuse(s[j], f);
	                        cs = s[j] / t;
	                        sn = f / t;
	                        s[j] = t;
	                        f = -sn * e[j];
	                        e[j] = cs * e[j];
	                        if (wantu) {
	                            for (i = 0; i < m; i++) {
	                                t = cs * U[i][j] + sn * U[i][k - 1];
	                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
	                                U[i][j] = t;
	                            }
	                        }
	                    }
	                    break;
	                }
	                case 3 : {
	                    scale = Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2]), Math.abs(e[p - 2]), Math.abs(s[k]), Math.abs(e[k]));
	                    sp = s[p - 1] / scale;
	                    spm1 = s[p - 2] / scale;
	                    epm1 = e[p - 2] / scale;
	                    sk = s[k] / scale;
	                    ek = e[k] / scale;
	                    b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
	                    c = (sp * epm1) * (sp * epm1);
	                    shift = 0;
	                    if ((b !== 0) || (c !== 0)) {
	                        shift = Math.sqrt(b * b + c);
	                        if (b < 0) {
	                            shift = -shift;
	                        }
	                        shift = c / (b + shift);
	                    }
	                    f = (sk + sp) * (sk - sp) + shift;
	                    g = sk * ek;
	                    for (j = k; j < p - 1; j++) {
	                        t = hypotenuse(f, g);
	                        cs = f / t;
	                        sn = g / t;
	                        if (j !== k) {
	                            e[j - 1] = t;
	                        }
	                        f = cs * s[j] + sn * e[j];
	                        e[j] = cs * e[j] - sn * s[j];
	                        g = sn * s[j + 1];
	                        s[j + 1] = cs * s[j + 1];
	                        if (wantv) {
	                            for (i = 0; i < n; i++) {
	                                t = cs * V[i][j] + sn * V[i][j + 1];
	                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
	                                V[i][j] = t;
	                            }
	                        }
	                        t = hypotenuse(f, g);
	                        cs = f / t;
	                        sn = g / t;
	                        s[j] = t;
	                        f = cs * e[j] + sn * s[j + 1];
	                        s[j + 1] = -sn * e[j] + cs * s[j + 1];
	                        g = sn * e[j + 1];
	                        e[j + 1] = cs * e[j + 1];
	                        if (wantu && (j < m - 1)) {
	                            for (i = 0; i < m; i++) {
	                                t = cs * U[i][j] + sn * U[i][j + 1];
	                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
	                                U[i][j] = t;
	                            }
	                        }
	                    }
	                    e[p - 2] = f;
	                    iter = iter + 1;
	                    break;
	                }
	                case 4: {
	                    if (s[k] <= 0) {
	                        s[k] = (s[k] < 0 ? -s[k] : 0);
	                        if (wantv) {
	                            for (i = 0; i <= pp; i++) {
	                                V[i][k] = -V[i][k];
	                            }
	                        }
	                    }
	                    while (k < pp) {
	                        if (s[k] >= s[k + 1]) {
	                            break;
	                        }
	                        t = s[k];
	                        s[k] = s[k + 1];
	                        s[k + 1] = t;
	                        if (wantv && (k < n - 1)) {
	                            for (i = 0; i < n; i++) {
	                                t = V[i][k + 1];
	                                V[i][k + 1] = V[i][k];
	                                V[i][k] = t;
	                            }
	                        }
	                        if (wantu && (k < m - 1)) {
	                            for (i = 0; i < m; i++) {
	                                t = U[i][k + 1];
	                                U[i][k + 1] = U[i][k];
	                                U[i][k] = t;
	                            }
	                        }
	                        k++;
	                    }
	                    iter = 0;
	                    p--;
	                    break;
	                }
	                // no default
	            }
	        }
	
	        if (swapped) {
	            var tmp = V;
	            V = U;
	            U = tmp;
	        }
	
	        this.m = m;
	        this.n = n;
	        this.s = s;
	        this.U = U;
	        this.V = V;
	    }
	
	    /**
	     * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
	     * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
	     * var svd = SingularValueDecomposition(A);
	     * var x = svd.solve(b);
	     * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
	     * @return {Matrix} - The vector x
	     */
	    solve(value) {
	
	        var Y = value;
	        var e = this.threshold;
	        var scols = this.s.length;
	        var Ls = Matrix.zeros(scols, scols);
	        var i;
	
	        for (i = 0; i < scols; i++) {
	            if (Math.abs(this.s[i]) <= e) {
	                Ls[i][i] = 0;
	            } else {
	                Ls[i][i] = 1 / this.s[i];
	            }
	        }
	
	        var U = this.U;
	        var V = this.rightSingularVectors;
	
	        var VL = V.mmul(Ls);
	        var vrows = V.rows;
	        var urows = U.length;
	        var VLU = Matrix.zeros(vrows, urows);
	        var j, k, sum;
	
	        for (i = 0; i < vrows; i++) {
	            for (j = 0; j < urows; j++) {
	                sum = 0;
	                for (k = 0; k < scols; k++) {
	                    sum += VL[i][k] * U[j][k];
	                }
	                VLU[i][j] = sum;
	            }
	        }
	
	        return VLU.mmul(Y);
	    }
	
	    /**
	     *
	     * @param {Array<number>} value
	     * @return {Matrix}
	     */
	    solveForDiagonal(value) {
	        return this.solve(Matrix.diag(value));
	    }
	
	    /**
	     * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
	     * var svd = SingularValueDecomposition(A);
	     * var inverseA = svd.inverse();
	     * @return {Matrix} - The approximation of the inverse of the matrix
	     */
	    inverse() {
	        var V = this.V;
	        var e = this.threshold;
	        var vrows = V.length;
	        var vcols = V[0].length;
	        var X = new Matrix(vrows, this.s.length);
	        var i, j;
	
	        for (i = 0; i < vrows; i++) {
	            for (j = 0; j < vcols; j++) {
	                if (Math.abs(this.s[j]) > e) {
	                    X[i][j] = V[i][j] / this.s[j];
	                } else {
	                    X[i][j] = 0;
	                }
	            }
	        }
	
	        var U = this.U;
	
	        var urows = U.length;
	        var ucols = U[0].length;
	        var Y = new Matrix(vrows, urows);
	        var k, sum;
	
	        for (i = 0; i < vrows; i++) {
	            for (j = 0; j < urows; j++) {
	                sum = 0;
	                for (k = 0; k < ucols; k++) {
	                    sum += X[i][k] * U[j][k];
	                }
	                Y[i][j] = sum;
	            }
	        }
	
	        return Y;
	    }
	
	    /**
	     *
	     * @return {number}
	     */
	    get condition() {
	        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
	    }
	
	    /**
	     *
	     * @return {number}
	     */
	    get norm2() {
	        return this.s[0];
	    }
	
	    /**
	     *
	     * @return {number}
	     */
	    get rank() {
	        var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
	        var r = 0;
	        var s = this.s;
	        for (var i = 0, ii = s.length; i < ii; i++) {
	            if (s[i] > tol) {
	                r++;
	            }
	        }
	        return r;
	    }
	
	    /**
	     *
	     * @return {Array<number>}
	     */
	    get diagonal() {
	        return this.s;
	    }
	
	    /**
	     *
	     * @return {number}
	     */
	    get threshold() {
	        return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get leftSingularVectors() {
	        if (!Matrix.isMatrix(this.U)) {
	            this.U = new Matrix(this.U);
	        }
	        return this.U;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get rightSingularVectors() {
	        if (!Matrix.isMatrix(this.V)) {
	            this.V = new Matrix(this.V);
	        }
	        return this.V;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get diagonalMatrix() {
	        return Matrix.diag(this.s);
	    }
	}
	
	/**
	 * @private
	 * Check that a row index is not out of bounds
	 * @param {Matrix} matrix
	 * @param {number} index
	 * @param {boolean} [outer]
	 */
	function checkRowIndex(matrix, index, outer) {
	    var max = outer ? matrix.rows : matrix.rows - 1;
	    if (index < 0 || index > max) {
	        throw new RangeError('Row index out of range');
	    }
	}
	
	/**
	 * @private
	 * Check that a column index is not out of bounds
	 * @param {Matrix} matrix
	 * @param {number} index
	 * @param {boolean} [outer]
	 */
	function checkColumnIndex(matrix, index, outer) {
	    var max = outer ? matrix.columns : matrix.columns - 1;
	    if (index < 0 || index > max) {
	        throw new RangeError('Column index out of range');
	    }
	}
	
	/**
	 * @private
	 * Check that the provided vector is an array with the right length
	 * @param {Matrix} matrix
	 * @param {Array|Matrix} vector
	 * @return {Array}
	 * @throws {RangeError}
	 */
	function checkRowVector(matrix, vector) {
	    if (vector.to1DArray) {
	        vector = vector.to1DArray();
	    }
	    if (vector.length !== matrix.columns) {
	        throw new RangeError('vector size must be the same as the number of columns');
	    }
	    return vector;
	}
	
	/**
	 * @private
	 * Check that the provided vector is an array with the right length
	 * @param {Matrix} matrix
	 * @param {Array|Matrix} vector
	 * @return {Array}
	 * @throws {RangeError}
	 */
	function checkColumnVector(matrix, vector) {
	    if (vector.to1DArray) {
	        vector = vector.to1DArray();
	    }
	    if (vector.length !== matrix.rows) {
	        throw new RangeError('vector size must be the same as the number of rows');
	    }
	    return vector;
	}
	
	function checkIndices(matrix, rowIndices, columnIndices) {
	    return {
	        row: checkRowIndices(matrix, rowIndices),
	        column: checkColumnIndices(matrix, columnIndices)
	    };
	}
	
	function checkRowIndices(matrix, rowIndices) {
	    if (typeof rowIndices !== 'object') {
	        throw new TypeError('unexpected type for row indices');
	    }
	
	    var rowOut = rowIndices.some(r => {
	        return r < 0 || r >= matrix.rows;
	
	    });
	
	    if (rowOut) {
	        throw new RangeError('row indices are out of range');
	    }
	
	    if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);
	
	    return rowIndices;
	}
	
	function checkColumnIndices(matrix, columnIndices) {
	    if (typeof columnIndices !== 'object') {
	        throw new TypeError('unexpected type for column indices');
	    }
	
	    var columnOut = columnIndices.some(c => {
	        return c < 0 || c >= matrix.columns;
	    });
	
	    if (columnOut) {
	        throw new RangeError('column indices are out of range');
	    }
	    if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);
	
	    return columnIndices;
	}
	
	function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
	    if (arguments.length !== 5) throw new TypeError('Invalid argument type');
	    var notAllNumbers = Array.from(arguments).slice(1).some(function (arg) {
	        return typeof arg !== 'number';
	    });
	    if (notAllNumbers) throw new TypeError('Invalid argument type');
	    if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {
	        throw new RangeError('Submatrix indices are out of range');
	    }
	}
	
	
	
	function sumByRow(matrix) {
	    var sum = Matrix.zeros(matrix.rows, 1);
	    for (var i = 0; i < matrix.rows; ++i) {
	        for (var j = 0; j < matrix.columns; ++j) {
	            sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
	        }
	    }
	    return sum;
	}
	
	function sumByColumn(matrix) {
	    var sum = Matrix.zeros(1, matrix.columns);
	    for (var i = 0; i < matrix.rows; ++i) {
	        for (var j = 0; j < matrix.columns; ++j) {
	            sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
	        }
	    }
	    return sum;
	}
	
	function sumAll(matrix) {
	    var v = 0;
	    for (var i = 0; i < matrix.rows; i++) {
	        for (var j = 0; j < matrix.columns; j++) {
	            v += matrix.get(i, j);
	        }
	    }
	    return v;
	}
	
	class BaseView extends AbstractMatrix() {
	    constructor(matrix, rows, columns) {
	        super();
	        this.matrix = matrix;
	        this.rows = rows;
	        this.columns = columns;
	    }
	
	    static get [Symbol.species]() {
	        return Matrix;
	    }
	}
	
	class MatrixTransposeView extends BaseView {
	    constructor(matrix) {
	        super(matrix, matrix.columns, matrix.rows);
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(columnIndex, rowIndex, value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(columnIndex, rowIndex);
	    }
	}
	
	class MatrixRowView extends BaseView {
	    constructor(matrix, row) {
	        super(matrix, 1, matrix.columns);
	        this.row = row;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(this.row, columnIndex, value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(this.row, columnIndex);
	    }
	}
	
	class MatrixSubView extends BaseView {
	    constructor(matrix, startRow, endRow, startColumn, endColumn) {
	        checkRange(matrix, startRow, endRow, startColumn, endColumn);
	        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
	        this.startRow = startRow;
	        this.startColumn = startColumn;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(this.startRow + rowIndex, this.startColumn + columnIndex, value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(this.startRow + rowIndex, this.startColumn + columnIndex);
	    }
	}
	
	class MatrixSelectionView extends BaseView {
	    constructor(matrix, rowIndices, columnIndices) {
	        var indices = checkIndices(matrix, rowIndices, columnIndices);
	        super(matrix, indices.row.length, indices.column.length);
	        this.rowIndices = indices.row;
	        this.columnIndices = indices.column;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(this.rowIndices[rowIndex], this.columnIndices[columnIndex], value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(this.rowIndices[rowIndex], this.columnIndices[columnIndex]);
	    }
	}
	
	class MatrixRowSelectionView extends BaseView {
	    constructor(matrix, rowIndices) {
	        rowIndices = checkRowIndices(matrix, rowIndices);
	        super(matrix, rowIndices.length, matrix.columns);
	        this.rowIndices = rowIndices;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
	    }
	}
	
	class MatrixColumnSelectionView extends BaseView {
	    constructor(matrix, columnIndices) {
	        columnIndices = checkColumnIndices(matrix, columnIndices);
	        super(matrix, matrix.rows, columnIndices.length);
	        this.columnIndices = columnIndices;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
	    }
	}
	
	class MatrixColumnView extends BaseView {
	    constructor(matrix, column) {
	        super(matrix, matrix.rows, 1);
	        this.column = column;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(rowIndex, this.column, value);
	        return this;
	    }
	
	    get(rowIndex) {
	        return this.matrix.get(rowIndex, this.column);
	    }
	}
	
	class MatrixFlipRowView extends BaseView {
	    constructor(matrix) {
	        super(matrix, matrix.rows, matrix.columns);
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
	    }
	}
	
	class MatrixFlipColumnView extends BaseView {
	    constructor(matrix) {
	        super(matrix, matrix.rows, matrix.columns);
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
	    }
	}
	
	function AbstractMatrix(superCtor) {
	    if (superCtor === undefined) superCtor = Object;
	
	    /**
	     * Real matrix
	     * @class Matrix
	     * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
	     * 2D array containing the data or Matrix instance to clone
	     * @param {number} [nColumns] - Number of columns of the new matrix
	     */
	    class Matrix extends superCtor {
	        static get [Symbol.species]() {
	            return this;
	        }
	
	        /**
	         * Constructs a Matrix with the chosen dimensions from a 1D array
	         * @param {number} newRows - Number of rows
	         * @param {number} newColumns - Number of columns
	         * @param {Array} newData - A 1D array containing data for the matrix
	         * @return {Matrix} - The new matrix
	         */
	        static from1DArray(newRows, newColumns, newData) {
	            var length = newRows * newColumns;
	            if (length !== newData.length) {
	                throw new RangeError('Data length does not match given dimensions');
	            }
	            var newMatrix = new this(newRows, newColumns);
	            for (var row = 0; row < newRows; row++) {
	                for (var column = 0; column < newColumns; column++) {
	                    newMatrix.set(row, column, newData[row * newColumns + column]);
	                }
	            }
	            return newMatrix;
	        }
	
	        /**
	         * Creates a row vector, a matrix with only one row.
	         * @param {Array} newData - A 1D array containing data for the vector
	         * @return {Matrix} - The new matrix
	         */
	        static rowVector(newData) {
	            var vector = new this(1, newData.length);
	            for (var i = 0; i < newData.length; i++) {
	                vector.set(0, i, newData[i]);
	            }
	            return vector;
	        }
	
	        /**
	         * Creates a column vector, a matrix with only one column.
	         * @param {Array} newData - A 1D array containing data for the vector
	         * @return {Matrix} - The new matrix
	         */
	        static columnVector(newData) {
	            var vector = new this(newData.length, 1);
	            for (var i = 0; i < newData.length; i++) {
	                vector.set(i, 0, newData[i]);
	            }
	            return vector;
	        }
	
	        /**
	         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @return {Matrix} - The new matrix
	         */
	        static empty(rows, columns) {
	            return new this(rows, columns);
	        }
	
	        /**
	         * Creates a matrix with the given dimensions. Values will be set to zero.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @return {Matrix} - The new matrix
	         */
	        static zeros(rows, columns) {
	            return this.empty(rows, columns).fill(0);
	        }
	
	        /**
	         * Creates a matrix with the given dimensions. Values will be set to one.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @return {Matrix} - The new matrix
	         */
	        static ones(rows, columns) {
	            return this.empty(rows, columns).fill(1);
	        }
	
	        /**
	         * Creates a matrix with the given dimensions. Values will be randomly set.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @param {function} [rng=Math.random] - Random number generator
	         * @return {Matrix} The new matrix
	         */
	        static rand(rows, columns, rng) {
	            if (rng === undefined) rng = Math.random;
	            var matrix = this.empty(rows, columns);
	            for (var i = 0; i < rows; i++) {
	                for (var j = 0; j < columns; j++) {
	                    matrix.set(i, j, rng());
	                }
	            }
	            return matrix;
	        }
	
	        /**
	         * Creates a matrix with the given dimensions. Values will be random integers.
	         * @param {number} rows - Number of rows
	         * @param {number} columns - Number of columns
	         * @param {number} [maxValue=1000] - Maximum value
	         * @param {function} [rng=Math.random] - Random number generator
	         * @return {Matrix} The new matrix
	         */
	        static randInt(rows, columns, maxValue, rng) {
	            if (maxValue === undefined) maxValue = 1000;
	            if (rng === undefined) rng = Math.random;
	            var matrix = this.empty(rows, columns);
	            for (var i = 0; i < rows; i++) {
	                for (var j = 0; j < columns; j++) {
	                    var value = Math.floor(rng() * maxValue);
	                    matrix.set(i, j, value);
	                }
	            }
	            return matrix;
	        }
	
	        /**
	         * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
	         * @param {number} rows - Number of rows
	         * @param {number} [columns=rows] - Number of columns
	         * @param {number} [value=1] - Value to fill the diagonal with
	         * @return {Matrix} - The new identity matrix
	         */
	        static eye(rows, columns, value) {
	            if (columns === undefined) columns = rows;
	            if (value === undefined) value = 1;
	            var min = Math.min(rows, columns);
	            var matrix = this.zeros(rows, columns);
	            for (var i = 0; i < min; i++) {
	                matrix.set(i, i, value);
	            }
	            return matrix;
	        }
	
	        /**
	         * Creates a diagonal matrix based on the given array.
	         * @param {Array} data - Array containing the data for the diagonal
	         * @param {number} [rows] - Number of rows (Default: data.length)
	         * @param {number} [columns] - Number of columns (Default: rows)
	         * @return {Matrix} - The new diagonal matrix
	         */
	        static diag(data, rows, columns) {
	            var l = data.length;
	            if (rows === undefined) rows = l;
	            if (columns === undefined) columns = rows;
	            var min = Math.min(l, rows, columns);
	            var matrix = this.zeros(rows, columns);
	            for (var i = 0; i < min; i++) {
	                matrix.set(i, i, data[i]);
	            }
	            return matrix;
	        }
	
	        /**
	         * Returns a matrix whose elements are the minimum between matrix1 and matrix2
	         * @param {Matrix} matrix1
	         * @param {Matrix} matrix2
	         * @return {Matrix}
	         */
	        static min(matrix1, matrix2) {
	            matrix1 = this.checkMatrix(matrix1);
	            matrix2 = this.checkMatrix(matrix2);
	            var rows = matrix1.rows;
	            var columns = matrix1.columns;
	            var result = new this(rows, columns);
	            for (var i = 0; i < rows; i++) {
	                for (var j = 0; j < columns; j++) {
	                    result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
	                }
	            }
	            return result;
	        }
	
	        /**
	         * Returns a matrix whose elements are the maximum between matrix1 and matrix2
	         * @param {Matrix} matrix1
	         * @param {Matrix} matrix2
	         * @return {Matrix}
	         */
	        static max(matrix1, matrix2) {
	            matrix1 = this.checkMatrix(matrix1);
	            matrix2 = this.checkMatrix(matrix2);
	            var rows = matrix1.rows;
	            var columns = matrix1.columns;
	            var result = new this(rows, columns);
	            for (var i = 0; i < rows; i++) {
	                for (var j = 0; j < columns; j++) {
	                    result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
	                }
	            }
	            return result;
	        }
	
	        /**
	         * Check that the provided value is a Matrix and tries to instantiate one if not
	         * @param {*} value - The value to check
	         * @return {Matrix}
	         */
	        static checkMatrix(value) {
	            return Matrix.isMatrix(value) ? value : new this(value);
	        }
	
	        /**
	         * Returns true if the argument is a Matrix, false otherwise
	         * @param {*} value - The value to check
	         * @return {boolean}
	         */
	        static isMatrix(value) {
	            return (value != null) && (value.klass === 'Matrix');
	        }
	
	        /**
	         * @prop {number} size - The number of elements in the matrix.
	         */
	        get size() {
	            return this.rows * this.columns;
	        }
	
	        /**
	         * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
	         * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
	         * @return {Matrix} this
	         */
	        apply(callback) {
	            if (typeof callback !== 'function') {
	                throw new TypeError('callback must be a function');
	            }
	            var ii = this.rows;
	            var jj = this.columns;
	            for (var i = 0; i < ii; i++) {
	                for (var j = 0; j < jj; j++) {
	                    callback.call(this, i, j);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Returns a new 1D array filled row by row with the matrix values
	         * @return {Array}
	         */
	        to1DArray() {
	            var array = new Array(this.size);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    array[i * this.columns + j] = this.get(i, j);
	                }
	            }
	            return array;
	        }
	
	        /**
	         * Returns a 2D array containing a copy of the data
	         * @return {Array}
	         */
	        to2DArray() {
	            var copy = new Array(this.rows);
	            for (var i = 0; i < this.rows; i++) {
	                copy[i] = new Array(this.columns);
	                for (var j = 0; j < this.columns; j++) {
	                    copy[i][j] = this.get(i, j);
	                }
	            }
	            return copy;
	        }
	
	        /**
	         * @return {boolean} true if the matrix has one row
	         */
	        isRowVector() {
	            return this.rows === 1;
	        }
	
	        /**
	         * @return {boolean} true if the matrix has one column
	         */
	        isColumnVector() {
	            return this.columns === 1;
	        }
	
	        /**
	         * @return {boolean} true if the matrix has one row or one column
	         */
	        isVector() {
	            return (this.rows === 1) || (this.columns === 1);
	        }
	
	        /**
	         * @return {boolean} true if the matrix has the same number of rows and columns
	         */
	        isSquare() {
	            return this.rows === this.columns;
	        }
	
	        /**
	         * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal
	         */
	        isSymmetric() {
	            if (this.isSquare()) {
	                for (var i = 0; i < this.rows; i++) {
	                    for (var j = 0; j <= i; j++) {
	                        if (this.get(i, j) !== this.get(j, i)) {
	                            return false;
	                        }
	                    }
	                }
	                return true;
	            }
	            return false;
	        }
	
	        /**
	         * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
	         * @abstract
	         * @param {number} rowIndex - Index of the row
	         * @param {number} columnIndex - Index of the column
	         * @param {number} value - The new value for the element
	         * @return {Matrix} this
	         */
	        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars
	            throw new Error('set method is unimplemented');
	        }
	
	        /**
	         * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
	         * @abstract
	         * @param {number} rowIndex - Index of the row
	         * @param {number} columnIndex - Index of the column
	         * @return {number}
	         */
	        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars
	            throw new Error('get method is unimplemented');
	        }
	
	        /**
	         * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of
	         * rows of the matrix, and colRep times the number of columns of the matrix
	         * @param {number} rowRep - Number of times the rows should be repeated
	         * @param {number} colRep - Number of times the columns should be re
	         * @return {Matrix}
	         * @example
	         * var matrix = new Matrix([[1,2]]);
	         * matrix.repeat(2); // [[1,2],[1,2]]
	         */
	        repeat(rowRep, colRep) {
	            rowRep = rowRep || 1;
	            colRep = colRep || 1;
	            var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);
	            for (var i = 0; i < rowRep; i++) {
	                for (var j = 0; j < colRep; j++) {
	                    matrix.setSubMatrix(this, this.rows * i, this.columns * j);
	                }
	            }
	            return matrix;
	        }
	
	        /**
	         * Fills the matrix with a given value. All elements will be set to this value.
	         * @param {number} value - New value
	         * @return {Matrix} this
	         */
	        fill(value) {
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, value);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Negates the matrix. All elements will be multiplied by (-1)
	         * @return {Matrix} this
	         */
	        neg() {
	            return this.mulS(-1);
	        }
	
	        /**
	         * Returns a new array from the given row index
	         * @param {number} index - Row index
	         * @return {Array}
	         */
	        getRow(index) {
	            checkRowIndex(this, index);
	            var row = new Array(this.columns);
	            for (var i = 0; i < this.columns; i++) {
	                row[i] = this.get(index, i);
	            }
	            return row;
	        }
	
	        /**
	         * Returns a new row vector from the given row index
	         * @param {number} index - Row index
	         * @return {Matrix}
	         */
	        getRowVector(index) {
	            return this.constructor.rowVector(this.getRow(index));
	        }
	
	        /**
	         * Sets a row at the given index
	         * @param {number} index - Row index
	         * @param {Array|Matrix} array - Array or vector
	         * @return {Matrix} this
	         */
	        setRow(index, array) {
	            checkRowIndex(this, index);
	            array = checkRowVector(this, array);
	            for (var i = 0; i < this.columns; i++) {
	                this.set(index, i, array[i]);
	            }
	            return this;
	        }
	
	        /**
	         * Swaps two rows
	         * @param {number} row1 - First row index
	         * @param {number} row2 - Second row index
	         * @return {Matrix} this
	         */
	        swapRows(row1, row2) {
	            checkRowIndex(this, row1);
	            checkRowIndex(this, row2);
	            for (var i = 0; i < this.columns; i++) {
	                var temp = this.get(row1, i);
	                this.set(row1, i, this.get(row2, i));
	                this.set(row2, i, temp);
	            }
	            return this;
	        }
	
	        /**
	         * Returns a new array from the given column index
	         * @param {number} index - Column index
	         * @return {Array}
	         */
	        getColumn(index) {
	            checkColumnIndex(this, index);
	            var column = new Array(this.rows);
	            for (var i = 0; i < this.rows; i++) {
	                column[i] = this.get(i, index);
	            }
	            return column;
	        }
	
	        /**
	         * Returns a new column vector from the given column index
	         * @param {number} index - Column index
	         * @return {Matrix}
	         */
	        getColumnVector(index) {
	            return this.constructor.columnVector(this.getColumn(index));
	        }
	
	        /**
	         * Sets a column at the given index
	         * @param {number} index - Column index
	         * @param {Array|Matrix} array - Array or vector
	         * @return {Matrix} this
	         */
	        setColumn(index, array) {
	            checkColumnIndex(this, index);
	            array = checkColumnVector(this, array);
	            for (var i = 0; i < this.rows; i++) {
	                this.set(i, index, array[i]);
	            }
	            return this;
	        }
	
	        /**
	         * Swaps two columns
	         * @param {number} column1 - First column index
	         * @param {number} column2 - Second column index
	         * @return {Matrix} this
	         */
	        swapColumns(column1, column2) {
	            checkColumnIndex(this, column1);
	            checkColumnIndex(this, column2);
	            for (var i = 0; i < this.rows; i++) {
	                var temp = this.get(i, column1);
	                this.set(i, column1, this.get(i, column2));
	                this.set(i, column2, temp);
	            }
	            return this;
	        }
	
	        /**
	         * Adds the values of a vector to each row
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        addRowVector(vector) {
	            vector = checkRowVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) + vector[j]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Subtracts the values of a vector from each row
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        subRowVector(vector) {
	            vector = checkRowVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) - vector[j]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Multiplies the values of a vector with each row
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        mulRowVector(vector) {
	            vector = checkRowVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) * vector[j]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Divides the values of each row by those of a vector
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        divRowVector(vector) {
	            vector = checkRowVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) / vector[j]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Adds the values of a vector to each column
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        addColumnVector(vector) {
	            vector = checkColumnVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) + vector[i]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Subtracts the values of a vector from each column
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        subColumnVector(vector) {
	            vector = checkColumnVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) - vector[i]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Multiplies the values of a vector with each column
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        mulColumnVector(vector) {
	            vector = checkColumnVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) * vector[i]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Divides the values of each column by those of a vector
	         * @param {Array|Matrix} vector - Array or vector
	         * @return {Matrix} this
	         */
	        divColumnVector(vector) {
	            vector = checkColumnVector(this, vector);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    this.set(i, j, this.get(i, j) / vector[i]);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Multiplies the values of a row with a scalar
	         * @param {number} index - Row index
	         * @param {number} value
	         * @return {Matrix} this
	         */
	        mulRow(index, value) {
	            checkRowIndex(this, index);
	            for (var i = 0; i < this.columns; i++) {
	                this.set(index, i, this.get(index, i) * value);
	            }
	            return this;
	        }
	
	        /**
	         * Multiplies the values of a column with a scalar
	         * @param {number} index - Column index
	         * @param {number} value
	         * @return {Matrix} this
	         */
	        mulColumn(index, value) {
	            checkColumnIndex(this, index);
	            for (var i = 0; i < this.rows; i++) {
	                this.set(i, index, this.get(i, index) * value);
	            }
	            return this;
	        }
	
	        /**
	         * Returns the maximum value of the matrix
	         * @return {number}
	         */
	        max() {
	            var v = this.get(0, 0);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    if (this.get(i, j) > v) {
	                        v = this.get(i, j);
	                    }
	                }
	            }
	            return v;
	        }
	
	        /**
	         * Returns the index of the maximum value
	         * @return {Array}
	         */
	        maxIndex() {
	            var v = this.get(0, 0);
	            var idx = [0, 0];
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    if (this.get(i, j) > v) {
	                        v = this.get(i, j);
	                        idx[0] = i;
	                        idx[1] = j;
	                    }
	                }
	            }
	            return idx;
	        }
	
	        /**
	         * Returns the minimum value of the matrix
	         * @return {number}
	         */
	        min() {
	            var v = this.get(0, 0);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    if (this.get(i, j) < v) {
	                        v = this.get(i, j);
	                    }
	                }
	            }
	            return v;
	        }
	
	        /**
	         * Returns the index of the minimum value
	         * @return {Array}
	         */
	        minIndex() {
	            var v = this.get(0, 0);
	            var idx = [0, 0];
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    if (this.get(i, j) < v) {
	                        v = this.get(i, j);
	                        idx[0] = i;
	                        idx[1] = j;
	                    }
	                }
	            }
	            return idx;
	        }
	
	        /**
	         * Returns the maximum value of one row
	         * @param {number} row - Row index
	         * @return {number}
	         */
	        maxRow(row) {
	            checkRowIndex(this, row);
	            var v = this.get(row, 0);
	            for (var i = 1; i < this.columns; i++) {
	                if (this.get(row, i) > v) {
	                    v = this.get(row, i);
	                }
	            }
	            return v;
	        }
	
	        /**
	         * Returns the index of the maximum value of one row
	         * @param {number} row - Row index
	         * @return {Array}
	         */
	        maxRowIndex(row) {
	            checkRowIndex(this, row);
	            var v = this.get(row, 0);
	            var idx = [row, 0];
	            for (var i = 1; i < this.columns; i++) {
	                if (this.get(row, i) > v) {
	                    v = this.get(row, i);
	                    idx[1] = i;
	                }
	            }
	            return idx;
	        }
	
	        /**
	         * Returns the minimum value of one row
	         * @param {number} row - Row index
	         * @return {number}
	         */
	        minRow(row) {
	            checkRowIndex(this, row);
	            var v = this.get(row, 0);
	            for (var i = 1; i < this.columns; i++) {
	                if (this.get(row, i) < v) {
	                    v = this.get(row, i);
	                }
	            }
	            return v;
	        }
	
	        /**
	         * Returns the index of the maximum value of one row
	         * @param {number} row - Row index
	         * @return {Array}
	         */
	        minRowIndex(row) {
	            checkRowIndex(this, row);
	            var v = this.get(row, 0);
	            var idx = [row, 0];
	            for (var i = 1; i < this.columns; i++) {
	                if (this.get(row, i) < v) {
	                    v = this.get(row, i);
	                    idx[1] = i;
	                }
	            }
	            return idx;
	        }
	
	        /**
	         * Returns the maximum value of one column
	         * @param {number} column - Column index
	         * @return {number}
	         */
	        maxColumn(column) {
	            checkColumnIndex(this, column);
	            var v = this.get(0, column);
	            for (var i = 1; i < this.rows; i++) {
	                if (this.get(i, column) > v) {
	                    v = this.get(i, column);
	                }
	            }
	            return v;
	        }
	
	        /**
	         * Returns the index of the maximum value of one column
	         * @param {number} column - Column index
	         * @return {Array}
	         */
	        maxColumnIndex(column) {
	            checkColumnIndex(this, column);
	            var v = this.get(0, column);
	            var idx = [0, column];
	            for (var i = 1; i < this.rows; i++) {
	                if (this.get(i, column) > v) {
	                    v = this.get(i, column);
	                    idx[0] = i;
	                }
	            }
	            return idx;
	        }
	
	        /**
	         * Returns the minimum value of one column
	         * @param {number} column - Column index
	         * @return {number}
	         */
	        minColumn(column) {
	            checkColumnIndex(this, column);
	            var v = this.get(0, column);
	            for (var i = 1; i < this.rows; i++) {
	                if (this.get(i, column) < v) {
	                    v = this.get(i, column);
	                }
	            }
	            return v;
	        }
	
	        /**
	         * Returns the index of the minimum value of one column
	         * @param {number} column - Column index
	         * @return {Array}
	         */
	        minColumnIndex(column) {
	            checkColumnIndex(this, column);
	            var v = this.get(0, column);
	            var idx = [0, column];
	            for (var i = 1; i < this.rows; i++) {
	                if (this.get(i, column) < v) {
	                    v = this.get(i, column);
	                    idx[0] = i;
	                }
	            }
	            return idx;
	        }
	
	        /**
	         * Returns an array containing the diagonal values of the matrix
	         * @return {Array}
	         */
	        diag() {
	            var min = Math.min(this.rows, this.columns);
	            var diag = new Array(min);
	            for (var i = 0; i < min; i++) {
	                diag[i] = this.get(i, i);
	            }
	            return diag;
	        }
	
	        /**
	         * Returns the sum by the argument given, if no argument given,
	         * it returns the sum of all elements of the matrix.
	         * @param {string} by - sum by 'row' or 'column'.
	         * @return {Matrix|number}
	         */
	        sum(by) {
	            switch (by) {
	                case 'row':
	                    return sumByRow(this);
	                case 'column':
	                    return sumByColumn(this);
	                default:
	                    return sumAll(this);
	            }
	        }
	
	        /**
	         * Returns the mean of all elements of the matrix
	         * @return {number}
	         */
	        mean() {
	            return this.sum() / this.size;
	        }
	
	        /**
	         * Returns the product of all elements of the matrix
	         * @return {number}
	         */
	        prod() {
	            var prod = 1;
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    prod *= this.get(i, j);
	                }
	            }
	            return prod;
	        }
	
	        /**
	         * Returns the norm of a matrix.
	         * @param {string} type - "frobenius" (default) or "max" return resp. the Frobenius norm and the max norm.
	         * @return {number}
	         */
	        norm(type = 'frobenius') {
	            var result = 0;
	            if (type === 'max') {
	                return this.max();
	            } else if (type === 'frobenius') {
	                for (var i = 0; i < this.rows; i++) {
	                    for (var j = 0; j < this.columns; j++) {
	                        result = result + this.get(i, j) * this.get(i, j);
	                    }
	                }
	                return Math.sqrt(result);
	            } else {
	                throw new RangeError(`unknown norm type: ${type}`);
	            }
	        }
	
	        /**
	         * Computes the cumulative sum of the matrix elements (in place, row by row)
	         * @return {Matrix} this
	         */
	        cumulativeSum() {
	            var sum = 0;
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    sum += this.get(i, j);
	                    this.set(i, j, sum);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Computes the dot (scalar) product between the matrix and another
	         * @param {Matrix} vector2 vector
	         * @return {number}
	         */
	        dot(vector2) {
	            if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
	            var vector1 = this.to1DArray();
	            if (vector1.length !== vector2.length) {
	                throw new RangeError('vectors do not have the same size');
	            }
	            var dot = 0;
	            for (var i = 0; i < vector1.length; i++) {
	                dot += vector1[i] * vector2[i];
	            }
	            return dot;
	        }
	
	        /**
	         * Returns the matrix product between this and other
	         * @param {Matrix} other
	         * @return {Matrix}
	         */
	        mmul(other) {
	            other = this.constructor.checkMatrix(other);
	            if (this.columns !== other.rows) {
	                // eslint-disable-next-line no-console
	                console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
	            }
	
	            var m = this.rows;
	            var n = this.columns;
	            var p = other.columns;
	
	            var result = new this.constructor[Symbol.species](m, p);
	
	            var Bcolj = new Array(n);
	            for (var j = 0; j < p; j++) {
	                for (var k = 0; k < n; k++) {
	                    Bcolj[k] = other.get(k, j);
	                }
	
	                for (var i = 0; i < m; i++) {
	                    var s = 0;
	                    for (k = 0; k < n; k++) {
	                        s += this.get(i, k) * Bcolj[k];
	                    }
	
	                    result.set(i, j, s);
	                }
	            }
	            return result;
	        }
	
	        strassen2x2(other) {
	            var result = new this.constructor[Symbol.species](2, 2);
	            const a11 = this.get(0, 0);
	            const b11 = other.get(0, 0);
	            const a12 = this.get(0, 1);
	            const b12 = other.get(0, 1);
	            const a21 = this.get(1, 0);
	            const b21 = other.get(1, 0);
	            const a22 = this.get(1, 1);
	            const b22 = other.get(1, 1);
	
	            // Compute intermediate values.
	            const m1 = (a11 + a22) * (b11 + b22);
	            const m2 = (a21 + a22) * b11;
	            const m3 = a11 * (b12 - b22);
	            const m4 = a22 * (b21 - b11);
	            const m5 = (a11 + a12) * b22;
	            const m6 = (a21 - a11) * (b11 + b12);
	            const m7 = (a12 - a22) * (b21 + b22);
	
	            // Combine intermediate values into the output.
	            const c00 = m1 + m4 - m5 + m7;
	            const c01 = m3 + m5;
	            const c10 = m2 + m4;
	            const c11 = m1 - m2 + m3 + m6;
	
	            result.set(0, 0, c00);
	            result.set(0, 1, c01);
	            result.set(1, 0, c10);
	            result.set(1, 1, c11);
	            return result;
	        }
	
	        strassen3x3(other) {
	            var result = new this.constructor[Symbol.species](3, 3);
	
	            const a00 = this.get(0, 0);
	            const a01 = this.get(0, 1);
	            const a02 = this.get(0, 2);
	            const a10 = this.get(1, 0);
	            const a11 = this.get(1, 1);
	            const a12 = this.get(1, 2);
	            const a20 = this.get(2, 0);
	            const a21 = this.get(2, 1);
	            const a22 = this.get(2, 2);
	
	            const b00 = other.get(0, 0);
	            const b01 = other.get(0, 1);
	            const b02 = other.get(0, 2);
	            const b10 = other.get(1, 0);
	            const b11 = other.get(1, 1);
	            const b12 = other.get(1, 2);
	            const b20 = other.get(2, 0);
	            const b21 = other.get(2, 1);
	            const b22 = other.get(2, 2);
	
	            const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
	            const m2 = (a00 - a10) * (-b01 + b11);
	            const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
	            const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
	            const m5 = (a10 + a11) * (-b00 + b01);
	            const m6 = a00 * b00;
	            const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
	            const m8 = (-a00 + a20) * (b02 - b12);
	            const m9 = (a20 + a21) * (-b00 + b02);
	            const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
	            const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
	            const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
	            const m13 = (a02 - a22) * (b11 - b21);
	            const m14 = a02 * b20;
	            const m15 = (a21 + a22) * (-b20 + b21);
	            const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
	            const m17 = (a02 - a12) * (b12 - b22);
	            const m18 = (a11 + a12) * (-b20 + b22);
	            const m19 = a01 * b10;
	            const m20 = a12 * b21;
	            const m21 = a10 * b02;
	            const m22 = a20 * b01;
	            const m23 = a22 * b22;
	
	            const c00 = m6 + m14 + m19;
	            const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
	            const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
	            const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
	            const c11 = m2 + m4 + m5 + m6 + m20;
	            const c12 = m14 + m16 + m17 + m18 + m21;
	            const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
	            const c21 = m12 + m13 + m14 + m15 + m22;
	            const c22 = m6 + m7 + m8 + m9 + m23;
	
	            result.set(0, 0, c00);
	            result.set(0, 1, c01);
	            result.set(0, 2, c02);
	            result.set(1, 0, c10);
	            result.set(1, 1, c11);
	            result.set(1, 2, c12);
	            result.set(2, 0, c20);
	            result.set(2, 1, c21);
	            result.set(2, 2, c22);
	            return result;
	        }
	
	        /**
	         * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.
	         * @param {Matrix} y
	         * @return {Matrix}
	         */
	        mmulStrassen(y) {
	            var x = this.clone();
	            var r1 = x.rows;
	            var c1 = x.columns;
	            var r2 = y.rows;
	            var c2 = y.columns;
	            if (c1 !== r2) {
	                // eslint-disable-next-line no-console
	                console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);
	            }
	
	            // Put a matrix into the top left of a matrix of zeros.
	            // `rows` and `cols` are the dimensions of the output matrix.
	            function embed(mat, rows, cols) {
	                var r = mat.rows;
	                var c = mat.columns;
	                if ((r === rows) && (c === cols)) {
	                    return mat;
	                } else {
	                    var resultat = Matrix.zeros(rows, cols);
	                    resultat = resultat.setSubMatrix(mat, 0, 0);
	                    return resultat;
	                }
	            }
	
	
	            // Make sure both matrices are the same size.
	            // This is exclusively for simplicity:
	            // this algorithm can be implemented with matrices of different sizes.
	
	            var r = Math.max(r1, r2);
	            var c = Math.max(c1, c2);
	            x = embed(x, r, c);
	            y = embed(y, r, c);
	
	            // Our recursive multiplication function.
	            function blockMult(a, b, rows, cols) {
	                // For small matrices, resort to naive multiplication.
	                if (rows <= 512 || cols <= 512) {
	                    return a.mmul(b); // a is equivalent to this
	                }
	
	                // Apply dynamic padding.
	                if ((rows % 2 === 1) && (cols % 2 === 1)) {
	                    a = embed(a, rows + 1, cols + 1);
	                    b = embed(b, rows + 1, cols + 1);
	                } else if (rows % 2 === 1) {
	                    a = embed(a, rows + 1, cols);
	                    b = embed(b, rows + 1, cols);
	                } else if (cols % 2 === 1) {
	                    a = embed(a, rows, cols + 1);
	                    b = embed(b, rows, cols + 1);
	                }
	
	                var halfRows = parseInt(a.rows / 2);
	                var halfCols = parseInt(a.columns / 2);
	                // Subdivide input matrices.
	                var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
	                var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);
	
	                var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
	                var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);
	
	                var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
	                var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);
	
	                var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
	                var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);
	
	                // Compute intermediate values.
	                var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);
	                var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);
	                var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);
	                var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);
	                var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);
	                var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);
	                var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);
	
	                // Combine intermediate values into the output.
	                var c11 = Matrix.add(m1, m4);
	                c11.sub(m5);
	                c11.add(m7);
	                var c12 = Matrix.add(m3, m5);
	                var c21 = Matrix.add(m2, m4);
	                var c22 = Matrix.sub(m1, m2);
	                c22.add(m3);
	                c22.add(m6);
	
	                //Crop output to the desired size (undo dynamic padding).
	                var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);
	                resultat = resultat.setSubMatrix(c11, 0, 0);
	                resultat = resultat.setSubMatrix(c12, c11.rows, 0);
	                resultat = resultat.setSubMatrix(c21, 0, c11.columns);
	                resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
	                return resultat.subMatrix(0, rows - 1, 0, cols - 1);
	            }
	            return blockMult(x, y, r, c);
	        }
	
	        /**
	         * Returns a row-by-row scaled matrix
	         * @param {number} [min=0] - Minimum scaled value
	         * @param {number} [max=1] - Maximum scaled value
	         * @return {Matrix} - The scaled matrix
	         */
	        scaleRows(min, max) {
	            min = min === undefined ? 0 : min;
	            max = max === undefined ? 1 : max;
	            if (min >= max) {
	                throw new RangeError('min should be strictly smaller than max');
	            }
	            var newMatrix = this.constructor.empty(this.rows, this.columns);
	            for (var i = 0; i < this.rows; i++) {
	                var scaled = rescale(this.getRow(i), {min, max});
	                newMatrix.setRow(i, scaled);
	            }
	            return newMatrix;
	        }
	
	        /**
	         * Returns a new column-by-column scaled matrix
	         * @param {number} [min=0] - Minimum scaled value
	         * @param {number} [max=1] - Maximum scaled value
	         * @return {Matrix} - The new scaled matrix
	         * @example
	         * var matrix = new Matrix([[1,2],[-1,0]]);
	         * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]
	         */
	        scaleColumns(min, max) {
	            min = min === undefined ? 0 : min;
	            max = max === undefined ? 1 : max;
	            if (min >= max) {
	                throw new RangeError('min should be strictly smaller than max');
	            }
	            var newMatrix = this.constructor.empty(this.rows, this.columns);
	            for (var i = 0; i < this.columns; i++) {
	                var scaled = rescale(this.getColumn(i), {
	                    min: min,
	                    max: max
	                });
	                newMatrix.setColumn(i, scaled);
	            }
	            return newMatrix;
	        }
	
	
	        /**
	         * Returns the Kronecker product (also known as tensor product) between this and other
	         * See https://en.wikipedia.org/wiki/Kronecker_product
	         * @param {Matrix} other
	         * @return {Matrix}
	         */
	        kroneckerProduct(other) {
	            other = this.constructor.checkMatrix(other);
	
	            var m = this.rows;
	            var n = this.columns;
	            var p = other.rows;
	            var q = other.columns;
	
	            var result = new this.constructor[Symbol.species](m * p, n * q);
	            for (var i = 0; i < m; i++) {
	                for (var j = 0; j < n; j++) {
	                    for (var k = 0; k < p; k++) {
	                        for (var l = 0; l < q; l++) {
	                            result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);
	                        }
	                    }
	                }
	            }
	            return result;
	        }
	
	        /**
	         * Transposes the matrix and returns a new one containing the result
	         * @return {Matrix}
	         */
	        transpose() {
	            var result = new this.constructor[Symbol.species](this.columns, this.rows);
	            for (var i = 0; i < this.rows; i++) {
	                for (var j = 0; j < this.columns; j++) {
	                    result.set(j, i, this.get(i, j));
	                }
	            }
	            return result;
	        }
	
	        /**
	         * Sorts the rows (in place)
	         * @param {function} compareFunction - usual Array.prototype.sort comparison function
	         * @return {Matrix} this
	         */
	        sortRows(compareFunction) {
	            if (compareFunction === undefined) compareFunction = compareNumbers;
	            for (var i = 0; i < this.rows; i++) {
	                this.setRow(i, this.getRow(i).sort(compareFunction));
	            }
	            return this;
	        }
	
	        /**
	         * Sorts the columns (in place)
	         * @param {function} compareFunction - usual Array.prototype.sort comparison function
	         * @return {Matrix} this
	         */
	        sortColumns(compareFunction) {
	            if (compareFunction === undefined) compareFunction = compareNumbers;
	            for (var i = 0; i < this.columns; i++) {
	                this.setColumn(i, this.getColumn(i).sort(compareFunction));
	            }
	            return this;
	        }
	
	        /**
	         * Returns a subset of the matrix
	         * @param {number} startRow - First row index
	         * @param {number} endRow - Last row index
	         * @param {number} startColumn - First column index
	         * @param {number} endColumn - Last column index
	         * @return {Matrix}
	         */
	        subMatrix(startRow, endRow, startColumn, endColumn) {
	            checkRange(this, startRow, endRow, startColumn, endColumn);
	            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);
	            for (var i = startRow; i <= endRow; i++) {
	                for (var j = startColumn; j <= endColumn; j++) {
	                    newMatrix[i - startRow][j - startColumn] = this.get(i, j);
	                }
	            }
	            return newMatrix;
	        }
	
	        /**
	         * Returns a subset of the matrix based on an array of row indices
	         * @param {Array} indices - Array containing the row indices
	         * @param {number} [startColumn = 0] - First column index
	         * @param {number} [endColumn = this.columns-1] - Last column index
	         * @return {Matrix}
	         */
	        subMatrixRow(indices, startColumn, endColumn) {
	            if (startColumn === undefined) startColumn = 0;
	            if (endColumn === undefined) endColumn = this.columns - 1;
	            if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
	                throw new RangeError('Argument out of range');
	            }
	
	            var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);
	            for (var i = 0; i < indices.length; i++) {
	                for (var j = startColumn; j <= endColumn; j++) {
	                    if (indices[i] < 0 || indices[i] >= this.rows) {
	                        throw new RangeError('Row index out of range: ' + indices[i]);
	                    }
	                    newMatrix.set(i, j - startColumn, this.get(indices[i], j));
	                }
	            }
	            return newMatrix;
	        }
	
	        /**
	         * Returns a subset of the matrix based on an array of column indices
	         * @param {Array} indices - Array containing the column indices
	         * @param {number} [startRow = 0] - First row index
	         * @param {number} [endRow = this.rows-1] - Last row index
	         * @return {Matrix}
	         */
	        subMatrixColumn(indices, startRow, endRow) {
	            if (startRow === undefined) startRow = 0;
	            if (endRow === undefined) endRow = this.rows - 1;
	            if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
	                throw new RangeError('Argument out of range');
	            }
	
	            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);
	            for (var i = 0; i < indices.length; i++) {
	                for (var j = startRow; j <= endRow; j++) {
	                    if (indices[i] < 0 || indices[i] >= this.columns) {
	                        throw new RangeError('Column index out of range: ' + indices[i]);
	                    }
	                    newMatrix.set(j - startRow, i, this.get(j, indices[i]));
	                }
	            }
	            return newMatrix;
	        }
	
	        /**
	         * Set a part of the matrix to the given sub-matrix
	         * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.
	         * @param {number} startRow - The index of the first row to set
	         * @param {number} startColumn - The index of the first column to set
	         * @return {Matrix}
	         */
	        setSubMatrix(matrix, startRow, startColumn) {
	            matrix = this.constructor.checkMatrix(matrix);
	            var endRow = startRow + matrix.rows - 1;
	            var endColumn = startColumn + matrix.columns - 1;
	            checkRange(this, startRow, endRow, startColumn, endColumn);
	            for (var i = 0; i < matrix.rows; i++) {
	                for (var j = 0; j < matrix.columns; j++) {
	                    this[startRow + i][startColumn + j] = matrix.get(i, j);
	                }
	            }
	            return this;
	        }
	
	        /**
	         * Return a new matrix based on a selection of rows and columns
	         * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.
	         * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.
	         * @return {Matrix} The new matrix
	         */
	        selection(rowIndices, columnIndices) {
	            var indices = checkIndices(this, rowIndices, columnIndices);
	            var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);
	            for (var i = 0; i < indices.row.length; i++) {
	                var rowIndex = indices.row[i];
	                for (var j = 0; j < indices.column.length; j++) {
	                    var columnIndex = indices.column[j];
	                    newMatrix[i][j] = this.get(rowIndex, columnIndex);
	                }
	            }
	            return newMatrix;
	        }
	
	        /**
	         * Returns the trace of the matrix (sum of the diagonal elements)
	         * @return {number}
	         */
	        trace() {
	            var min = Math.min(this.rows, this.columns);
	            var trace = 0;
	            for (var i = 0; i < min; i++) {
	                trace += this.get(i, i);
	            }
	            return trace;
	        }
	
	        /*
	         Matrix views
	         */
	
	        /**
	         * Returns a view of the transposition of the matrix
	         * @return {MatrixTransposeView}
	         */
	        transposeView() {
	            return new MatrixTransposeView(this);
	        }
	
	        /**
	         * Returns a view of the row vector with the given index
	         * @param {number} row - row index of the vector
	         * @return {MatrixRowView}
	         */
	        rowView(row) {
	            checkRowIndex(this, row);
	            return new MatrixRowView(this, row);
	        }
	
	        /**
	         * Returns a view of the column vector with the given index
	         * @param {number} column - column index of the vector
	         * @return {MatrixColumnView}
	         */
	        columnView(column) {
	            checkColumnIndex(this, column);
	            return new MatrixColumnView(this, column);
	        }
	
	        /**
	         * Returns a view of the matrix flipped in the row axis
	         * @return {MatrixFlipRowView}
	         */
	        flipRowView() {
	            return new MatrixFlipRowView(this);
	        }
	
	        /**
	         * Returns a view of the matrix flipped in the column axis
	         * @return {MatrixFlipColumnView}
	         */
	        flipColumnView() {
	            return new MatrixFlipColumnView(this);
	        }
	
	        /**
	         * Returns a view of a submatrix giving the index boundaries
	         * @param {number} startRow - first row index of the submatrix
	         * @param {number} endRow - last row index of the submatrix
	         * @param {number} startColumn - first column index of the submatrix
	         * @param {number} endColumn - last column index of the submatrix
	         * @return {MatrixSubView}
	         */
	        subMatrixView(startRow, endRow, startColumn, endColumn) {
	            return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);
	        }
	
	        /**
	         * Returns a view of the cross of the row indices and the column indices
	         * @example
	         * // resulting vector is [[2], [2]]
	         * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])
	         * @param {Array<number>} rowIndices
	         * @param {Array<number>} columnIndices
	         * @return {MatrixSelectionView}
	         */
	        selectionView(rowIndices, columnIndices) {
	            return new MatrixSelectionView(this, rowIndices, columnIndices);
	        }
	
	        /**
	         * Returns a view of the row indices
	         * @example
	         * // resulting vector is [[1,2,3], [1,2,3]]
	         * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])
	         * @param {Array<number>} rowIndices
	         * @return {MatrixRowSelectionView}
	         */
	        rowSelectionView(rowIndices) {
	            return new MatrixRowSelectionView(this, rowIndices);
	        }
	
	        /**
	         * Returns a view of the column indices
	         * @example
	         * // resulting vector is [[2, 2], [5, 5]]
	         * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])
	         * @param {Array<number>} columnIndices
	         * @return {MatrixColumnSelectionView}
	         */
	        columnSelectionView(columnIndices) {
	            return new MatrixColumnSelectionView(this, columnIndices);
	        }
	
	
	        /**
	        * Calculates and returns the determinant of a matrix as a Number
	        * @example
	        *   new Matrix([[1,2,3], [4,5,6]]).det()
	        * @return {number}
	        */
	        det() {
	            if (this.isSquare()) {
	                var a, b, c, d;
	                if (this.columns === 2) {
	                    // 2 x 2 matrix
	                    a = this.get(0, 0);
	                    b = this.get(0, 1);
	                    c = this.get(1, 0);
	                    d = this.get(1, 1);
	
	                    return a * d - (b * c);
	                } else if (this.columns === 3) {
	                    // 3 x 3 matrix
	                    var subMatrix0, subMatrix1, subMatrix2;
	                    subMatrix0 = this.selectionView([1, 2], [1, 2]);
	                    subMatrix1 = this.selectionView([1, 2], [0, 2]);
	                    subMatrix2 = this.selectionView([1, 2], [0, 1]);
	                    a = this.get(0, 0);
	                    b = this.get(0, 1);
	                    c = this.get(0, 2);
	
	                    return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();
	                } else {
	                    // general purpose determinant using the LU decomposition
	                    return new LuDecomposition$$1(this).determinant;
	                }
	
	            } else {
	                throw Error('Determinant can only be calculated for a square matrix.');
	            }
	        }
	
	        /**
	         * Returns inverse of a matrix if it exists or the pseudoinverse
	         * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)
	         * @return {Matrix} the (pseudo)inverted matrix.
	         */
	        pseudoInverse(threshold) {
	            if (threshold === undefined) threshold = Number.EPSILON;
	            var svdSolution = new SingularValueDecomposition$$1(this, {autoTranspose: true});
	
	            var U = svdSolution.leftSingularVectors;
	            var V = svdSolution.rightSingularVectors;
	            var s = svdSolution.diagonal;
	
	            for (var i = 0; i < s.length; i++) {
	                if (Math.abs(s[i]) > threshold) {
	                    s[i] = 1.0 / s[i];
	                } else {
	                    s[i] = 0.0;
	                }
	            }
	
	            // convert list to diagonal
	            s = this.constructor[Symbol.species].diag(s);
	            return V.mmul(s.mmul(U.transposeView()));
	        }
	
	        /**
	         * Creates an exact and independent copy of the matrix
	         * @return {Matrix}
	         */
	        clone() {
	            var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
	            for (var row = 0; row < this.rows; row++) {
	                for (var column = 0; column < this.columns; column++) {
	                    newMatrix.set(row, column, this.get(row, column));
	                }
	            }
	            return newMatrix;
	        }
	    }
	
	    Matrix.prototype.klass = 'Matrix';
	
	    function compareNumbers(a, b) {
	        return a - b;
	    }
	
	    /*
	     Synonyms
	     */
	
	    Matrix.random = Matrix.rand;
	    Matrix.diagonal = Matrix.diag;
	    Matrix.prototype.diagonal = Matrix.prototype.diag;
	    Matrix.identity = Matrix.eye;
	    Matrix.prototype.negate = Matrix.prototype.neg;
	    Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;
	    Matrix.prototype.determinant = Matrix.prototype.det;
	
	    /*
	     Add dynamically instance and static methods for mathematical operations
	     */
	
	    var inplaceOperator = `
	(function %name%(value) {
	    if (typeof value === 'number') return this.%name%S(value);
	    return this.%name%M(value);
	})
	`;
	
	    var inplaceOperatorScalar = `
	(function %name%S(value) {
	    for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	            this.set(i, j, this.get(i, j) %op% value);
	        }
	    }
	    return this;
	})
	`;
	
	    var inplaceOperatorMatrix = `
	(function %name%M(matrix) {
	    matrix = this.constructor.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	        this.columns !== matrix.columns) {
	        throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));
	        }
	    }
	    return this;
	})
	`;
	
	    var staticOperator = `
	(function %name%(matrix, value) {
	    var newMatrix = new this[Symbol.species](matrix);
	    return newMatrix.%name%(value);
	})
	`;
	
	    var inplaceMethod = `
	(function %name%() {
	    for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	            this.set(i, j, %method%(this.get(i, j)));
	        }
	    }
	    return this;
	})
	`;
	
	    var staticMethod = `
	(function %name%(matrix) {
	    var newMatrix = new this[Symbol.species](matrix);
	    return newMatrix.%name%();
	})
	`;
	
	    var inplaceMethodWithArgs = `
	(function %name%(%args%) {
	    for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	            this.set(i, j, %method%(this.get(i, j), %args%));
	        }
	    }
	    return this;
	})
	`;
	
	    var staticMethodWithArgs = `
	(function %name%(matrix, %args%) {
	    var newMatrix = new this[Symbol.species](matrix);
	    return newMatrix.%name%(%args%);
	})
	`;
	
	
	    var inplaceMethodWithOneArgScalar = `
	(function %name%S(value) {
	    for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	            this.set(i, j, %method%(this.get(i, j), value));
	        }
	    }
	    return this;
	})
	`;
	    var inplaceMethodWithOneArgMatrix = `
	(function %name%M(matrix) {
	    matrix = this.constructor.checkMatrix(matrix);
	    if (this.rows !== matrix.rows ||
	        this.columns !== matrix.columns) {
	        throw new RangeError('Matrices dimensions must be equal');
	    }
	    for (var i = 0; i < this.rows; i++) {
	        for (var j = 0; j < this.columns; j++) {
	            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));
	        }
	    }
	    return this;
	})
	`;
	
	    var inplaceMethodWithOneArg = `
	(function %name%(value) {
	    if (typeof value === 'number') return this.%name%S(value);
	    return this.%name%M(value);
	})
	`;
	
	    var staticMethodWithOneArg = staticMethodWithArgs;
	
	    var operators = [
	        // Arithmetic operators
	        ['+', 'add'],
	        ['-', 'sub', 'subtract'],
	        ['*', 'mul', 'multiply'],
	        ['/', 'div', 'divide'],
	        ['%', 'mod', 'modulus'],
	        // Bitwise operators
	        ['&', 'and'],
	        ['|', 'or'],
	        ['^', 'xor'],
	        ['<<', 'leftShift'],
	        ['>>', 'signPropagatingRightShift'],
	        ['>>>', 'rightShift', 'zeroFillRightShift']
	    ];
	
	    var i;
	    var eval2 = eval;
	    for (var operator of operators) {
	        var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, {name: operator[1], op: operator[0]}));
	        var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, {name: operator[1] + 'S', op: operator[0]}));
	        var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, {name: operator[1] + 'M', op: operator[0]}));
	        var staticOp = eval2(fillTemplateFunction(staticOperator, {name: operator[1]}));
	        for (i = 1; i < operator.length; i++) {
	            Matrix.prototype[operator[i]] = inplaceOp;
	            Matrix.prototype[operator[i] + 'S'] = inplaceOpS;
	            Matrix.prototype[operator[i] + 'M'] = inplaceOpM;
	            Matrix[operator[i]] = staticOp;
	        }
	    }
	
	    var methods = [
	        ['~', 'not']
	    ];
	
	    [
	        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',
	        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',
	        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'
	    ].forEach(function (mathMethod) {
	        methods.push(['Math.' + mathMethod, mathMethod]);
	    });
	
	    for (var method of methods) {
	        var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, {name: method[1], method: method[0]}));
	        var staticMeth = eval2(fillTemplateFunction(staticMethod, {name: method[1]}));
	        for (i = 1; i < method.length; i++) {
	            Matrix.prototype[method[i]] = inplaceMeth;
	            Matrix[method[i]] = staticMeth;
	        }
	    }
	
	    var methodsWithArgs = [
	        ['Math.pow', 1, 'pow']
	    ];
	
	    for (var methodWithArg of methodsWithArgs) {
	        var args = 'arg0';
	        for (i = 1; i < methodWithArg[1]; i++) {
	            args += `, arg${i}`;
	        }
	        if (methodWithArg[1] !== 1) {
	            var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, {
	                name: methodWithArg[2],
	                method: methodWithArg[0],
	                args: args
	            }));
	            var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, {name: methodWithArg[2], args: args}));
	            for (i = 2; i < methodWithArg.length; i++) {
	                Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;
	                Matrix[methodWithArg[i]] = staticMethWithArgs;
	            }
	        } else {
	            var tmplVar = {
	                name: methodWithArg[2],
	                args: args,
	                method: methodWithArg[0]
	            };
	            var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));
	            var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));
	            var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));
	            var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));
	            for (i = 2; i < methodWithArg.length; i++) {
	                Matrix.prototype[methodWithArg[i]] = inplaceMethod2;
	                Matrix.prototype[methodWithArg[i] + 'M'] = inplaceMethodM;
	                Matrix.prototype[methodWithArg[i] + 'S'] = inplaceMethodS;
	                Matrix[methodWithArg[i]] = staticMethod2;
	            }
	        }
	    }
	
	    function fillTemplateFunction(template, values) {
	        for (var value in values) {
	            template = template.replace(new RegExp('%' + value + '%', 'g'), values[value]);
	        }
	        return template;
	    }
	
	    return Matrix;
	}
	
	class Matrix extends AbstractMatrix(Array) {
	    constructor(nRows, nColumns) {
	        var i;
	        if (arguments.length === 1 && typeof nRows === 'number') {
	            return new Array(nRows);
	        }
	        if (Matrix.isMatrix(nRows)) {
	            return nRows.clone();
	        } else if (Number.isInteger(nRows) && nRows > 0) { // Create an empty matrix
	            super(nRows);
	            if (Number.isInteger(nColumns) && nColumns > 0) {
	                for (i = 0; i < nRows; i++) {
	                    this[i] = new Array(nColumns);
	                }
	            } else {
	                throw new TypeError('nColumns must be a positive integer');
	            }
	        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array
	            const matrix = nRows;
	            nRows = matrix.length;
	            nColumns = matrix[0].length;
	            if (typeof nColumns !== 'number' || nColumns === 0) {
	                throw new TypeError('Data must be a 2D array with at least one element');
	            }
	            super(nRows);
	            for (i = 0; i < nRows; i++) {
	                if (matrix[i].length !== nColumns) {
	                    throw new RangeError('Inconsistent array dimensions');
	                }
	                this[i] = [].concat(matrix[i]);
	            }
	        } else {
	            throw new TypeError('First argument must be a positive number or an array');
	        }
	        this.rows = nRows;
	        this.columns = nColumns;
	        return this;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this[rowIndex][columnIndex] = value;
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this[rowIndex][columnIndex];
	    }
	
	    /**
	     * Removes a row from the given index
	     * @param {number} index - Row index
	     * @return {Matrix} this
	     */
	    removeRow(index) {
	        checkRowIndex(this, index);
	        if (this.rows === 1) {
	            throw new RangeError('A matrix cannot have less than one row');
	        }
	        this.splice(index, 1);
	        this.rows -= 1;
	        return this;
	    }
	
	    /**
	     * Adds a row at the given index
	     * @param {number} [index = this.rows] - Row index
	     * @param {Array|Matrix} array - Array or vector
	     * @return {Matrix} this
	     */
	    addRow(index, array) {
	        if (array === undefined) {
	            array = index;
	            index = this.rows;
	        }
	        checkRowIndex(this, index, true);
	        array = checkRowVector(this, array, true);
	        this.splice(index, 0, array);
	        this.rows += 1;
	        return this;
	    }
	
	    /**
	     * Removes a column from the given index
	     * @param {number} index - Column index
	     * @return {Matrix} this
	     */
	    removeColumn(index) {
	        checkColumnIndex(this, index);
	        if (this.columns === 1) {
	            throw new RangeError('A matrix cannot have less than one column');
	        }
	        for (var i = 0; i < this.rows; i++) {
	            this[i].splice(index, 1);
	        }
	        this.columns -= 1;
	        return this;
	    }
	
	    /**
	     * Adds a column at the given index
	     * @param {number} [index = this.columns] - Column index
	     * @param {Array|Matrix} array - Array or vector
	     * @return {Matrix} this
	     */
	    addColumn(index, array) {
	        if (typeof array === 'undefined') {
	            array = index;
	            index = this.columns;
	        }
	        checkColumnIndex(this, index, true);
	        array = checkColumnVector(this, array);
	        for (var i = 0; i < this.rows; i++) {
	            this[i].splice(index, 0, array[i]);
	        }
	        this.columns += 1;
	        return this;
	    }
	}
	
	class WrapperMatrix1D extends AbstractMatrix() {
	    /**
	     * @class WrapperMatrix1D
	     * @param {Array<number>} data
	     * @param {object} [options]
	     * @param {object} [options.rows = 1]
	     */
	    constructor(data, options = {}) {
	        const {
	            rows = 1
	        } = options;
	
	        if (data.length % rows !== 0) {
	            throw new Error('the data length is not divisible by the number of rows');
	        }
	        super();
	        this.rows = rows;
	        this.columns = data.length / rows;
	        this.data = data;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        var index = this._calculateIndex(rowIndex, columnIndex);
	        this.data[index] = value;
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        var index = this._calculateIndex(rowIndex, columnIndex);
	        return this.data[index];
	    }
	
	    _calculateIndex(row, column) {
	        return (row * this.columns) + column;
	    }
	
	    static get [Symbol.species]() {
	        return Matrix;
	    }
	}
	
	class WrapperMatrix2D extends AbstractMatrix() {
	    /**
	     * @class WrapperMatrix2D
	     * @param {Array<Array<number>>} data
	     */
	    constructor(data) {
	        super();
	        this.data = data;
	        this.rows = data.length;
	        this.columns = data[0].length;
	    }
	
	    set(rowIndex, columnIndex, value) {
	        this.data[rowIndex][columnIndex] = value;
	        return this;
	    }
	
	    get(rowIndex, columnIndex) {
	        return this.data[rowIndex][columnIndex];
	    }
	
	    static get [Symbol.species]() {
	        return Matrix;
	    }
	}
	
	/**
	 * @param {Array<Array<number>>|Array<number>} array
	 * @param {object} [options]
	 * @param {object} [options.rows = 1]
	 * @return {WrapperMatrix1D|WrapperMatrix2D}
	 */
	function wrap(array, options) {
	    if (Array.isArray(array)) {
	        if (array[0] && Array.isArray(array[0])) {
	            return new WrapperMatrix2D(array);
	        } else {
	            return new WrapperMatrix1D(array, options);
	        }
	    } else {
	        throw new Error('the argument is not an array');
	    }
	}
	
	/**
	 * @class QrDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
	 * @param {Matrix} value
	 */
	class QrDecomposition$$1 {
	    constructor(value) {
	        value = WrapperMatrix2D.checkMatrix(value);
	
	        var qr = value.clone();
	        var m = value.rows;
	        var n = value.columns;
	        var rdiag = new Array(n);
	        var i, j, k, s;
	
	        for (k = 0; k < n; k++) {
	            var nrm = 0;
	            for (i = k; i < m; i++) {
	                nrm = hypotenuse(nrm, qr.get(i, k));
	            }
	            if (nrm !== 0) {
	                if (qr.get(k, k) < 0) {
	                    nrm = -nrm;
	                }
	                for (i = k; i < m; i++) {
	                    qr.set(i, k, qr.get(i, k) / nrm);
	                }
	                qr.set(k, k, qr.get(k, k) + 1);
	                for (j = k + 1; j < n; j++) {
	                    s = 0;
	                    for (i = k; i < m; i++) {
	                        s += qr.get(i, k) * qr.get(i, j);
	                    }
	                    s = -s / qr.get(k, k);
	                    for (i = k; i < m; i++) {
	                        qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
	                    }
	                }
	            }
	            rdiag[k] = -nrm;
	        }
	
	        this.QR = qr;
	        this.Rdiag = rdiag;
	    }
	
	    /**
	     * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.
	     * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
	     * var qr = QrDecomposition(A);
	     * var x = qr.solve(b);
	     * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
	     * @return {Matrix} - The vector x
	     */
	    solve(value) {
	        value = Matrix.checkMatrix(value);
	
	        var qr = this.QR;
	        var m = qr.rows;
	
	        if (value.rows !== m) {
	            throw new Error('Matrix row dimensions must agree');
	        }
	        if (!this.isFullRank()) {
	            throw new Error('Matrix is rank deficient');
	        }
	
	        var count = value.columns;
	        var X = value.clone();
	        var n = qr.columns;
	        var i, j, k, s;
	
	        for (k = 0; k < n; k++) {
	            for (j = 0; j < count; j++) {
	                s = 0;
	                for (i = k; i < m; i++) {
	                    s += qr[i][k] * X[i][j];
	                }
	                s = -s / qr[k][k];
	                for (i = k; i < m; i++) {
	                    X[i][j] += s * qr[i][k];
	                }
	            }
	        }
	        for (k = n - 1; k >= 0; k--) {
	            for (j = 0; j < count; j++) {
	                X[k][j] /= this.Rdiag[k];
	            }
	            for (i = 0; i < k; i++) {
	                for (j = 0; j < count; j++) {
	                    X[i][j] -= X[k][j] * qr[i][k];
	                }
	            }
	        }
	
	        return X.subMatrix(0, n - 1, 0, count - 1);
	    }
	
	    /**
	     *
	     * @return {boolean}
	     */
	    isFullRank() {
	        var columns = this.QR.columns;
	        for (var i = 0; i < columns; i++) {
	            if (this.Rdiag[i] === 0) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get upperTriangularMatrix() {
	        var qr = this.QR;
	        var n = qr.columns;
	        var X = new Matrix(n, n);
	        var i, j;
	        for (i = 0; i < n; i++) {
	            for (j = 0; j < n; j++) {
	                if (i < j) {
	                    X[i][j] = qr[i][j];
	                } else if (i === j) {
	                    X[i][j] = this.Rdiag[i];
	                } else {
	                    X[i][j] = 0;
	                }
	            }
	        }
	        return X;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get orthogonalMatrix() {
	        var qr = this.QR;
	        var rows = qr.rows;
	        var columns = qr.columns;
	        var X = new Matrix(rows, columns);
	        var i, j, k, s;
	
	        for (k = columns - 1; k >= 0; k--) {
	            for (i = 0; i < rows; i++) {
	                X[i][k] = 0;
	            }
	            X[k][k] = 1;
	            for (j = k; j < columns; j++) {
	                if (qr[k][k] !== 0) {
	                    s = 0;
	                    for (i = k; i < rows; i++) {
	                        s += qr[i][k] * X[i][j];
	                    }
	
	                    s = -s / qr[k][k];
	
	                    for (i = k; i < rows; i++) {
	                        X[i][j] += s * qr[i][k];
	                    }
	                }
	            }
	        }
	        return X;
	    }
	}
	
	/**
	 * Computes the inverse of a Matrix
	 * @param {Matrix} matrix
	 * @param {boolean} [useSVD=false]
	 * @return {Matrix}
	 */
	function inverse$$1(matrix, useSVD = false) {
	    matrix = WrapperMatrix2D.checkMatrix(matrix);
	    if (useSVD) {
	        return new SingularValueDecomposition$$1(matrix).inverse();
	    } else {
	        return solve$$1(matrix, Matrix.eye(matrix.rows));
	    }
	}
	
	/**
	 *
	 * @param {Matrix} leftHandSide
	 * @param {Matrix} rightHandSide
	 * @param {boolean} [useSVD = false]
	 * @return {Matrix}
	 */
	function solve$$1(leftHandSide, rightHandSide, useSVD = false) {
	    leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
	    rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
	    if (useSVD) {
	        return new SingularValueDecomposition$$1(leftHandSide).solve(rightHandSide);
	    } else {
	        return leftHandSide.isSquare() ? new LuDecomposition$$1(leftHandSide).solve(rightHandSide) : new QrDecomposition$$1(leftHandSide).solve(rightHandSide);
	    }
	}
	
	/**
	 * @class EigenvalueDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs
	 * @param {Matrix} matrix
	 * @param {object} [options]
	 * @param {boolean} [options.assumeSymmetric=false]
	 */
	class EigenvalueDecomposition$$1 {
	    constructor(matrix, options = {}) {
	        const {
	            assumeSymmetric = false
	        } = options;
	
	        matrix = WrapperMatrix2D.checkMatrix(matrix);
	        if (!matrix.isSquare()) {
	            throw new Error('Matrix is not a square matrix');
	        }
	
	        var n = matrix.columns;
	        var V = getFilled2DArray(n, n, 0);
	        var d = new Array(n);
	        var e = new Array(n);
	        var value = matrix;
	        var i, j;
	
	        var isSymmetric = false;
	        if (assumeSymmetric) {
	            isSymmetric = true;
	        } else {
	            isSymmetric = matrix.isSymmetric();
	        }
	
	        if (isSymmetric) {
	            for (i = 0; i < n; i++) {
	                for (j = 0; j < n; j++) {
	                    V[i][j] = value.get(i, j);
	                }
	            }
	            tred2(n, e, d, V);
	            tql2(n, e, d, V);
	        } else {
	            var H = getFilled2DArray(n, n, 0);
	            var ort = new Array(n);
	            for (j = 0; j < n; j++) {
	                for (i = 0; i < n; i++) {
	                    H[i][j] = value.get(i, j);
	                }
	            }
	            orthes(n, H, ort, V);
	            hqr2(n, e, d, V, H);
	        }
	
	        this.n = n;
	        this.e = e;
	        this.d = d;
	        this.V = V;
	    }
	
	    /**
	     *
	     * @return {Array<number>}
	     */
	    get realEigenvalues() {
	        return this.d;
	    }
	
	    /**
	     *
	     * @return {Array<number>}
	     */
	    get imaginaryEigenvalues() {
	        return this.e;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get eigenvectorMatrix() {
	        if (!Matrix.isMatrix(this.V)) {
	            this.V = new Matrix(this.V);
	        }
	        return this.V;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get diagonalMatrix() {
	        var n = this.n;
	        var e = this.e;
	        var d = this.d;
	        var X = new Matrix(n, n);
	        var i, j;
	        for (i = 0; i < n; i++) {
	            for (j = 0; j < n; j++) {
	                X[i][j] = 0;
	            }
	            X[i][i] = d[i];
	            if (e[i] > 0) {
	                X[i][i + 1] = e[i];
	            } else if (e[i] < 0) {
	                X[i][i - 1] = e[i];
	            }
	        }
	        return X;
	    }
	}
	
	function tred2(n, e, d, V) {
	    var f, g, h, i, j, k,
	        hh, scale;
	
	    for (j = 0; j < n; j++) {
	        d[j] = V[n - 1][j];
	    }
	
	    for (i = n - 1; i > 0; i--) {
	        scale = 0;
	        h = 0;
	        for (k = 0; k < i; k++) {
	            scale = scale + Math.abs(d[k]);
	        }
	
	        if (scale === 0) {
	            e[i] = d[i - 1];
	            for (j = 0; j < i; j++) {
	                d[j] = V[i - 1][j];
	                V[i][j] = 0;
	                V[j][i] = 0;
	            }
	        } else {
	            for (k = 0; k < i; k++) {
	                d[k] /= scale;
	                h += d[k] * d[k];
	            }
	
	            f = d[i - 1];
	            g = Math.sqrt(h);
	            if (f > 0) {
	                g = -g;
	            }
	
	            e[i] = scale * g;
	            h = h - f * g;
	            d[i - 1] = f - g;
	            for (j = 0; j < i; j++) {
	                e[j] = 0;
	            }
	
	            for (j = 0; j < i; j++) {
	                f = d[j];
	                V[j][i] = f;
	                g = e[j] + V[j][j] * f;
	                for (k = j + 1; k <= i - 1; k++) {
	                    g += V[k][j] * d[k];
	                    e[k] += V[k][j] * f;
	                }
	                e[j] = g;
	            }
	
	            f = 0;
	            for (j = 0; j < i; j++) {
	                e[j] /= h;
	                f += e[j] * d[j];
	            }
	
	            hh = f / (h + h);
	            for (j = 0; j < i; j++) {
	                e[j] -= hh * d[j];
	            }
	
	            for (j = 0; j < i; j++) {
	                f = d[j];
	                g = e[j];
	                for (k = j; k <= i - 1; k++) {
	                    V[k][j] -= (f * e[k] + g * d[k]);
	                }
	                d[j] = V[i - 1][j];
	                V[i][j] = 0;
	            }
	        }
	        d[i] = h;
	    }
	
	    for (i = 0; i < n - 1; i++) {
	        V[n - 1][i] = V[i][i];
	        V[i][i] = 1;
	        h = d[i + 1];
	        if (h !== 0) {
	            for (k = 0; k <= i; k++) {
	                d[k] = V[k][i + 1] / h;
	            }
	
	            for (j = 0; j <= i; j++) {
	                g = 0;
	                for (k = 0; k <= i; k++) {
	                    g += V[k][i + 1] * V[k][j];
	                }
	                for (k = 0; k <= i; k++) {
	                    V[k][j] -= g * d[k];
	                }
	            }
	        }
	
	        for (k = 0; k <= i; k++) {
	            V[k][i + 1] = 0;
	        }
	    }
	
	    for (j = 0; j < n; j++) {
	        d[j] = V[n - 1][j];
	        V[n - 1][j] = 0;
	    }
	
	    V[n - 1][n - 1] = 1;
	    e[0] = 0;
	}
	
	function tql2(n, e, d, V) {
	
	    var g, h, i, j, k, l, m, p, r,
	        dl1, c, c2, c3, el1, s, s2,
	        iter;
	
	    for (i = 1; i < n; i++) {
	        e[i - 1] = e[i];
	    }
	
	    e[n - 1] = 0;
	
	    var f = 0;
	    var tst1 = 0;
	    var eps = Number.EPSILON;
	
	    for (l = 0; l < n; l++) {
	        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
	        m = l;
	        while (m < n) {
	            if (Math.abs(e[m]) <= eps * tst1) {
	                break;
	            }
	            m++;
	        }
	
	        if (m > l) {
	            iter = 0;
	            do {
	                iter = iter + 1;
	
	                g = d[l];
	                p = (d[l + 1] - g) / (2 * e[l]);
	                r = hypotenuse(p, 1);
	                if (p < 0) {
	                    r = -r;
	                }
	
	                d[l] = e[l] / (p + r);
	                d[l + 1] = e[l] * (p + r);
	                dl1 = d[l + 1];
	                h = g - d[l];
	                for (i = l + 2; i < n; i++) {
	                    d[i] -= h;
	                }
	
	                f = f + h;
	
	                p = d[m];
	                c = 1;
	                c2 = c;
	                c3 = c;
	                el1 = e[l + 1];
	                s = 0;
	                s2 = 0;
	                for (i = m - 1; i >= l; i--) {
	                    c3 = c2;
	                    c2 = c;
	                    s2 = s;
	                    g = c * e[i];
	                    h = c * p;
	                    r = hypotenuse(p, e[i]);
	                    e[i + 1] = s * r;
	                    s = e[i] / r;
	                    c = p / r;
	                    p = c * d[i] - s * g;
	                    d[i + 1] = h + s * (c * g + s * d[i]);
	
	                    for (k = 0; k < n; k++) {
	                        h = V[k][i + 1];
	                        V[k][i + 1] = s * V[k][i] + c * h;
	                        V[k][i] = c * V[k][i] - s * h;
	                    }
	                }
	
	                p = -s * s2 * c3 * el1 * e[l] / dl1;
	                e[l] = s * p;
	                d[l] = c * p;
	
	            }
	            while (Math.abs(e[l]) > eps * tst1);
	        }
	        d[l] = d[l] + f;
	        e[l] = 0;
	    }
	
	    for (i = 0; i < n - 1; i++) {
	        k = i;
	        p = d[i];
	        for (j = i + 1; j < n; j++) {
	            if (d[j] < p) {
	                k = j;
	                p = d[j];
	            }
	        }
	
	        if (k !== i) {
	            d[k] = d[i];
	            d[i] = p;
	            for (j = 0; j < n; j++) {
	                p = V[j][i];
	                V[j][i] = V[j][k];
	                V[j][k] = p;
	            }
	        }
	    }
	}
	
	function orthes(n, H, ort, V) {
	
	    var low = 0;
	    var high = n - 1;
	    var f, g, h, i, j, m;
	    var scale;
	
	    for (m = low + 1; m <= high - 1; m++) {
	        scale = 0;
	        for (i = m; i <= high; i++) {
	            scale = scale + Math.abs(H[i][m - 1]);
	        }
	
	        if (scale !== 0) {
	            h = 0;
	            for (i = high; i >= m; i--) {
	                ort[i] = H[i][m - 1] / scale;
	                h += ort[i] * ort[i];
	            }
	
	            g = Math.sqrt(h);
	            if (ort[m] > 0) {
	                g = -g;
	            }
	
	            h = h - ort[m] * g;
	            ort[m] = ort[m] - g;
	
	            for (j = m; j < n; j++) {
	                f = 0;
	                for (i = high; i >= m; i--) {
	                    f += ort[i] * H[i][j];
	                }
	
	                f = f / h;
	                for (i = m; i <= high; i++) {
	                    H[i][j] -= f * ort[i];
	                }
	            }
	
	            for (i = 0; i <= high; i++) {
	                f = 0;
	                for (j = high; j >= m; j--) {
	                    f += ort[j] * H[i][j];
	                }
	
	                f = f / h;
	                for (j = m; j <= high; j++) {
	                    H[i][j] -= f * ort[j];
	                }
	            }
	
	            ort[m] = scale * ort[m];
	            H[m][m - 1] = scale * g;
	        }
	    }
	
	    for (i = 0; i < n; i++) {
	        for (j = 0; j < n; j++) {
	            V[i][j] = (i === j ? 1 : 0);
	        }
	    }
	
	    for (m = high - 1; m >= low + 1; m--) {
	        if (H[m][m - 1] !== 0) {
	            for (i = m + 1; i <= high; i++) {
	                ort[i] = H[i][m - 1];
	            }
	
	            for (j = m; j <= high; j++) {
	                g = 0;
	                for (i = m; i <= high; i++) {
	                    g += ort[i] * V[i][j];
	                }
	
	                g = (g / ort[m]) / H[m][m - 1];
	                for (i = m; i <= high; i++) {
	                    V[i][j] += g * ort[i];
	                }
	            }
	        }
	    }
	}
	
	function hqr2(nn, e, d, V, H) {
	    var n = nn - 1;
	    var low = 0;
	    var high = nn - 1;
	    var eps = Number.EPSILON;
	    var exshift = 0;
	    var norm = 0;
	    var p = 0;
	    var q = 0;
	    var r = 0;
	    var s = 0;
	    var z = 0;
	    var iter = 0;
	    var i, j, k, l, m, t, w, x, y;
	    var ra, sa, vr, vi;
	    var notlast, cdivres;
	
	    for (i = 0; i < nn; i++) {
	        if (i < low || i > high) {
	            d[i] = H[i][i];
	            e[i] = 0;
	        }
	
	        for (j = Math.max(i - 1, 0); j < nn; j++) {
	            norm = norm + Math.abs(H[i][j]);
	        }
	    }
	
	    while (n >= low) {
	        l = n;
	        while (l > low) {
	            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
	            if (s === 0) {
	                s = norm;
	            }
	            if (Math.abs(H[l][l - 1]) < eps * s) {
	                break;
	            }
	            l--;
	        }
	
	        if (l === n) {
	            H[n][n] = H[n][n] + exshift;
	            d[n] = H[n][n];
	            e[n] = 0;
	            n--;
	            iter = 0;
	        } else if (l === n - 1) {
	            w = H[n][n - 1] * H[n - 1][n];
	            p = (H[n - 1][n - 1] - H[n][n]) / 2;
	            q = p * p + w;
	            z = Math.sqrt(Math.abs(q));
	            H[n][n] = H[n][n] + exshift;
	            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
	            x = H[n][n];
	
	            if (q >= 0) {
	                z = (p >= 0) ? (p + z) : (p - z);
	                d[n - 1] = x + z;
	                d[n] = d[n - 1];
	                if (z !== 0) {
	                    d[n] = x - w / z;
	                }
	                e[n - 1] = 0;
	                e[n] = 0;
	                x = H[n][n - 1];
	                s = Math.abs(x) + Math.abs(z);
	                p = x / s;
	                q = z / s;
	                r = Math.sqrt(p * p + q * q);
	                p = p / r;
	                q = q / r;
	
	                for (j = n - 1; j < nn; j++) {
	                    z = H[n - 1][j];
	                    H[n - 1][j] = q * z + p * H[n][j];
	                    H[n][j] = q * H[n][j] - p * z;
	                }
	
	                for (i = 0; i <= n; i++) {
	                    z = H[i][n - 1];
	                    H[i][n - 1] = q * z + p * H[i][n];
	                    H[i][n] = q * H[i][n] - p * z;
	                }
	
	                for (i = low; i <= high; i++) {
	                    z = V[i][n - 1];
	                    V[i][n - 1] = q * z + p * V[i][n];
	                    V[i][n] = q * V[i][n] - p * z;
	                }
	            } else {
	                d[n - 1] = x + p;
	                d[n] = x + p;
	                e[n - 1] = z;
	                e[n] = -z;
	            }
	
	            n = n - 2;
	            iter = 0;
	        } else {
	            x = H[n][n];
	            y = 0;
	            w = 0;
	            if (l < n) {
	                y = H[n - 1][n - 1];
	                w = H[n][n - 1] * H[n - 1][n];
	            }
	
	            if (iter === 10) {
	                exshift += x;
	                for (i = low; i <= n; i++) {
	                    H[i][i] -= x;
	                }
	                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
	                x = y = 0.75 * s;
	                w = -0.4375 * s * s;
	            }
	
	            if (iter === 30) {
	                s = (y - x) / 2;
	                s = s * s + w;
	                if (s > 0) {
	                    s = Math.sqrt(s);
	                    if (y < x) {
	                        s = -s;
	                    }
	                    s = x - w / ((y - x) / 2 + s);
	                    for (i = low; i <= n; i++) {
	                        H[i][i] -= s;
	                    }
	                    exshift += s;
	                    x = y = w = 0.964;
	                }
	            }
	
	            iter = iter + 1;
	
	            m = n - 2;
	            while (m >= l) {
	                z = H[m][m];
	                r = x - z;
	                s = y - z;
	                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
	                q = H[m + 1][m + 1] - z - r - s;
	                r = H[m + 2][m + 1];
	                s = Math.abs(p) + Math.abs(q) + Math.abs(r);
	                p = p / s;
	                q = q / s;
	                r = r / s;
	                if (m === l) {
	                    break;
	                }
	                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {
	                    break;
	                }
	                m--;
	            }
	
	            for (i = m + 2; i <= n; i++) {
	                H[i][i - 2] = 0;
	                if (i > m + 2) {
	                    H[i][i - 3] = 0;
	                }
	            }
	
	            for (k = m; k <= n - 1; k++) {
	                notlast = (k !== n - 1);
	                if (k !== m) {
	                    p = H[k][k - 1];
	                    q = H[k + 1][k - 1];
	                    r = (notlast ? H[k + 2][k - 1] : 0);
	                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);
	                    if (x !== 0) {
	                        p = p / x;
	                        q = q / x;
	                        r = r / x;
	                    }
	                }
	
	                if (x === 0) {
	                    break;
	                }
	
	                s = Math.sqrt(p * p + q * q + r * r);
	                if (p < 0) {
	                    s = -s;
	                }
	
	                if (s !== 0) {
	                    if (k !== m) {
	                        H[k][k - 1] = -s * x;
	                    } else if (l !== m) {
	                        H[k][k - 1] = -H[k][k - 1];
	                    }
	
	                    p = p + s;
	                    x = p / s;
	                    y = q / s;
	                    z = r / s;
	                    q = q / p;
	                    r = r / p;
	
	                    for (j = k; j < nn; j++) {
	                        p = H[k][j] + q * H[k + 1][j];
	                        if (notlast) {
	                            p = p + r * H[k + 2][j];
	                            H[k + 2][j] = H[k + 2][j] - p * z;
	                        }
	
	                        H[k][j] = H[k][j] - p * x;
	                        H[k + 1][j] = H[k + 1][j] - p * y;
	                    }
	
	                    for (i = 0; i <= Math.min(n, k + 3); i++) {
	                        p = x * H[i][k] + y * H[i][k + 1];
	                        if (notlast) {
	                            p = p + z * H[i][k + 2];
	                            H[i][k + 2] = H[i][k + 2] - p * r;
	                        }
	
	                        H[i][k] = H[i][k] - p;
	                        H[i][k + 1] = H[i][k + 1] - p * q;
	                    }
	
	                    for (i = low; i <= high; i++) {
	                        p = x * V[i][k] + y * V[i][k + 1];
	                        if (notlast) {
	                            p = p + z * V[i][k + 2];
	                            V[i][k + 2] = V[i][k + 2] - p * r;
	                        }
	
	                        V[i][k] = V[i][k] - p;
	                        V[i][k + 1] = V[i][k + 1] - p * q;
	                    }
	                }
	            }
	        }
	    }
	
	    if (norm === 0) {
	        return;
	    }
	
	    for (n = nn - 1; n >= 0; n--) {
	        p = d[n];
	        q = e[n];
	
	        if (q === 0) {
	            l = n;
	            H[n][n] = 1;
	            for (i = n - 1; i >= 0; i--) {
	                w = H[i][i] - p;
	                r = 0;
	                for (j = l; j <= n; j++) {
	                    r = r + H[i][j] * H[j][n];
	                }
	
	                if (e[i] < 0) {
	                    z = w;
	                    s = r;
	                } else {
	                    l = i;
	                    if (e[i] === 0) {
	                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));
	                    } else {
	                        x = H[i][i + 1];
	                        y = H[i + 1][i];
	                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
	                        t = (x * s - z * r) / q;
	                        H[i][n] = t;
	                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);
	                    }
	
	                    t = Math.abs(H[i][n]);
	                    if ((eps * t) * t > 1) {
	                        for (j = i; j <= n; j++) {
	                            H[j][n] = H[j][n] / t;
	                        }
	                    }
	                }
	            }
	        } else if (q < 0) {
	            l = n - 1;
	
	            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
	                H[n - 1][n - 1] = q / H[n][n - 1];
	                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
	            } else {
	                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
	                H[n - 1][n - 1] = cdivres[0];
	                H[n - 1][n] = cdivres[1];
	            }
	
	            H[n][n - 1] = 0;
	            H[n][n] = 1;
	            for (i = n - 2; i >= 0; i--) {
	                ra = 0;
	                sa = 0;
	                for (j = l; j <= n; j++) {
	                    ra = ra + H[i][j] * H[j][n - 1];
	                    sa = sa + H[i][j] * H[j][n];
	                }
	
	                w = H[i][i] - p;
	
	                if (e[i] < 0) {
	                    z = w;
	                    r = ra;
	                    s = sa;
	                } else {
	                    l = i;
	                    if (e[i] === 0) {
	                        cdivres = cdiv(-ra, -sa, w, q);
	                        H[i][n - 1] = cdivres[0];
	                        H[i][n] = cdivres[1];
	                    } else {
	                        x = H[i][i + 1];
	                        y = H[i + 1][i];
	                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
	                        vi = (d[i] - p) * 2 * q;
	                        if (vr === 0 && vi === 0) {
	                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));
	                        }
	                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
	                        H[i][n - 1] = cdivres[0];
	                        H[i][n] = cdivres[1];
	                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
	                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
	                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
	                        } else {
	                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
	                            H[i + 1][n - 1] = cdivres[0];
	                            H[i + 1][n] = cdivres[1];
	                        }
	                    }
	
	                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
	                    if ((eps * t) * t > 1) {
	                        for (j = i; j <= n; j++) {
	                            H[j][n - 1] = H[j][n - 1] / t;
	                            H[j][n] = H[j][n] / t;
	                        }
	                    }
	                }
	            }
	        }
	    }
	
	    for (i = 0; i < nn; i++) {
	        if (i < low || i > high) {
	            for (j = i; j < nn; j++) {
	                V[i][j] = H[i][j];
	            }
	        }
	    }
	
	    for (j = nn - 1; j >= low; j--) {
	        for (i = low; i <= high; i++) {
	            z = 0;
	            for (k = low; k <= Math.min(j, high); k++) {
	                z = z + V[i][k] * H[k][j];
	            }
	            V[i][j] = z;
	        }
	    }
	}
	
	function cdiv(xr, xi, yr, yi) {
	    var r, d;
	    if (Math.abs(yr) > Math.abs(yi)) {
	        r = yi / yr;
	        d = yr + r * yi;
	        return [(xr + r * xi) / d, (xi - r * xr) / d];
	    } else {
	        r = yr / yi;
	        d = yi + r * yr;
	        return [(r * xr + xi) / d, (r * xi - xr) / d];
	    }
	}
	
	/**
	 * @class CholeskyDecomposition
	 * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
	 * @param {Matrix} value
	 */
	class CholeskyDecomposition$$1 {
	    constructor(value) {
	        value = WrapperMatrix2D.checkMatrix(value);
	        if (!value.isSymmetric()) {
	            throw new Error('Matrix is not symmetric');
	        }
	
	        var a = value;
	        var dimension = a.rows;
	        var l = new Matrix(dimension, dimension);
	        var positiveDefinite = true;
	        var i, j, k;
	
	        for (j = 0; j < dimension; j++) {
	            var Lrowj = l[j];
	            var d = 0;
	            for (k = 0; k < j; k++) {
	                var Lrowk = l[k];
	                var s = 0;
	                for (i = 0; i < k; i++) {
	                    s += Lrowk[i] * Lrowj[i];
	                }
	                Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];
	                d = d + s * s;
	            }
	
	            d = a.get(j, j) - d;
	
	            positiveDefinite &= (d > 0);
	            l[j][j] = Math.sqrt(Math.max(d, 0));
	            for (k = j + 1; k < dimension; k++) {
	                l[j][k] = 0;
	            }
	        }
	
	        if (!positiveDefinite) {
	            throw new Error('Matrix is not positive definite');
	        }
	
	        this.L = l;
	    }
	
	    /**
	     *
	     * @param {Matrix} value
	     * @return {Matrix}
	     */
	    solve(value) {
	        value = WrapperMatrix2D.checkMatrix(value);
	
	        var l = this.L;
	        var dimension = l.rows;
	
	        if (value.rows !== dimension) {
	            throw new Error('Matrix dimensions do not match');
	        }
	
	        var count = value.columns;
	        var B = value.clone();
	        var i, j, k;
	
	        for (k = 0; k < dimension; k++) {
	            for (j = 0; j < count; j++) {
	                for (i = 0; i < k; i++) {
	                    B[k][j] -= B[i][j] * l[k][i];
	                }
	                B[k][j] /= l[k][k];
	            }
	        }
	
	        for (k = dimension - 1; k >= 0; k--) {
	            for (j = 0; j < count; j++) {
	                for (i = k + 1; i < dimension; i++) {
	                    B[k][j] -= B[i][j] * l[i][k];
	                }
	                B[k][j] /= l[k][k];
	            }
	        }
	
	        return B;
	    }
	
	    /**
	     *
	     * @return {Matrix}
	     */
	    get lowerTriangularMatrix() {
	        return this.L;
	    }
	}
	
	exports['default'] = Matrix;
	exports.Matrix = Matrix;
	exports.abstractMatrix = AbstractMatrix;
	exports.wrap = wrap;
	exports.WrapperMatrix2D = WrapperMatrix2D;
	exports.WrapperMatrix1D = WrapperMatrix1D;
	exports.solve = solve$$1;
	exports.inverse = inverse$$1;
	exports.SingularValueDecomposition = SingularValueDecomposition$$1;
	exports.SVD = SingularValueDecomposition$$1;
	exports.EigenvalueDecomposition = EigenvalueDecomposition$$1;
	exports.EVD = EigenvalueDecomposition$$1;
	exports.CholeskyDecomposition = CholeskyDecomposition$$1;
	exports.CHO = CholeskyDecomposition$$1;
	exports.LuDecomposition = LuDecomposition$$1;
	exports.LU = LuDecomposition$$1;
	exports.QrDecomposition = QrDecomposition$$1;
	exports.QR = QrDecomposition$$1;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
	
	var max = _interopDefault(__webpack_require__(22));
	var min = _interopDefault(__webpack_require__(23));
	
	function rescale(input, options = {}) {
	    if (!Array.isArray(input)) {
	        throw new TypeError('input must be an array');
	    } else if (input.length === 0) {
	        throw new TypeError('input must not be empty');
	    }
	
	    let output;
	    if (options.output !== undefined) {
	        if (!Array.isArray(options.output)) {
	            throw new TypeError('output option must be an array if specified');
	        }
	        output = options.output;
	    } else {
	        output = new Array(input.length);
	    }
	
	    const currentMin = min(input);
	    const currentMax = max(input);
	
	    if (currentMin === currentMax) {
	        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
	    }
	
	    const {
	        min: minValue = options.autoMinMax ? currentMin : 0,
	        max: maxValue = options.autoMinMax ? currentMax : 1
	    } = options;
	
	    if (minValue >= maxValue) {
	        throw new RangeError('min option must be smaller than max option');
	    }
	
	    const factor = (maxValue - minValue) / (currentMax - currentMin);
	    for (var i = 0; i < input.length; i++) {
	        output[i] = (input[i] - currentMin) * factor + minValue;
	    }
	
	    return output;
	}
	
	module.exports = rescale;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Computes the maximum of the given values
	 * @param {Array<number>} input
	 * @return {number}
	 */
	function max(input) {
	    if (!Array.isArray(input)) {
	        throw new Error('input must be an array');
	    }
	
	    if (input.length === 0) {
	        throw new Error('input must not be empty');
	    }
	
	    var max = input[0];
	    for (var i = 1; i < input.length; i++) {
	        if (input[i] > max) max = input[i];
	    }
	    return max;
	}
	
	module.exports = max;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Computes the minimum of the given values
	 * @param {Array<number>} input
	 * @return {number}
	 */
	function min(input) {
	    if (!Array.isArray(input)) {
	        throw new Error('input must be an array');
	    }
	
	    if (input.length === 0) {
	        throw new Error('input must not be empty');
	    }
	
	    var min = input[0];
	    for (var i = 1; i < input.length; i++) {
	        if (input[i] < min) min = input[i];
	    }
	    return min;
	}
	
	module.exports = min;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2017, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Author: Renato Fabbri
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	// inspired in Matlab implementation
	// and JS transcription in
	// https://github.com/alanmeeson/spectral-graph-layout
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	        this._epsilon = 1e-8; // tolerance
	        this._MAX_ITTERATIONS = 100; //We use power iteration, this is analogous to wall time to avoid infinite loops.
	        this._num_elements = nodes.length; //number of nodes in graph
	        this._dims = 2;
	    }
	
	    _createClass(_class, [{
	        key: 'apply',
	        value: function apply() {
	            var A = (0, _utils.create2dArray)(this._nodes.length, this._nodes.length);
	            // build the adjacency matrix
	            for (var i = 0; i < this._edges.length; ++i) {
	                var ii = this._edges[i].source.index;
	                var j = this._edges[i].target.index;
	                A[ii][j] = 1; // not considering edge weight for now (the example json files don't have weight)
	            }
	            var D = deg(A); //degree of each node in graph (number of connections).
	
	            var dims = this._dims + 1; //add one to the dims to allow for the first eigen vector
	            var u = new Array(dims); //declare the eigen vector matrix
	            u[0] = normalize(ones(this._num_elements)); //create & normalize the first eigen vector
	            for (var _i = 1; _i < dims; _i++) {
	                u[_i] = zeros(this._num_elements);
	            } //create empty space for the other eigen vectors
	
	            //Power iteration to determine the remaining eigen vectors.
	            for (var k = 1; k < dims; k++) {
	                //for each eigen vector after the first, 
	                //initialize eigen vector with random values
	                var uhk = normalize(rand(this._num_elements));
	
	                var itt_count = 0; //we are allowing a max of 100 iterations, to avoid hanging and infinite loops. (specified above in constants)
	                var stop = false; //stopping criterion flag.
	                while (!stop) {
	                    // do...while using flags to keep it consistent with my matlab implementation
	
	                    //D-orthogonalize against previous eigenvectors
	                    var uk = uhk.slice();
	                    for (var l = 0; l < k; l++) {
	                        var ul = u[l]; //extract the l-th eigen vector
	
	                        //Calculate (uk'.D.ul)/(ul'.D.ul)
	                        var top_ = 0;
	                        var bottom = 0;
	                        for (var vmi = 0; vmi < uk.length; vmi++) {
	                            top_ += uk[vmi] * D[vmi] * ul[vmi];
	                            bottom += ul[vmi] * D[vmi] * ul[vmi];
	                        }
	                        var ratio = top_ / bottom;
	
	                        //uk = uk - ((uk' . D . ul) / (ul' . D ul)) . ul
	                        for (var vsi = 0; vsi < uk.length; vsi++) {
	                            uk[vsi] = uk[vsi] - ratio * ul[vsi];
	                        }
	                    }
	
	                    //multiply with .5(I+D^-1 A)
	                    for (var _i2 = 0; _i2 < uhk.length; _i2++) {
	                        uhk[_i2] = 0.5 * (uk[_i2] + dot(A[_i2], uk) / D[_i2]);
	                    }
	
	                    uhk = normalize(uhk);
	
	                    itt_count = itt_count + 1;
	                    stop = itt_count > 100 | !(dot(uhk, uk) < 1 - this._epsilon);
	                }
	                u[k] = uhk.slice();
	            }
	
	            //discard the first eigenvector which should be [ones].
	            // var v = new Array(u.length);
	            // for (var i=0; i < u.length; i++) {
	            //     v[i] = new Array(u[i].length);
	            //     for (var j=0; j < u[i].length; j++) v[i][j] = u[i][j];
	            // }
	            var x = normalize2(u[1]);
	            var y = normalize2(u[2]);
	            this._nodes.forEach(function (node, i) {
	                node.x = x[i];
	                node.y = y[i];
	            });
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;
	
	function deg(graph) {
	    //Calculate the degree of each node from the graph matrix.
	    var d = zeros(graph.length);
	
	    //degree of node i is the sum of the weights of all edges connected to it.
	    for (var i = 0; i < graph.length; i++) {
	        var node_degree = 0;
	        for (var j = 0; j < graph[i].length; j++) {
	            node_degree += graph[i][j];
	        }
	        d[i] = node_degree + 1;
	    }
	
	    return d;
	}
	
	function dot(a, b) {
	    //inner product of two vectors
	    var d = 0;
	    for (var i = 0; i < a.length; i++) {
	        d += a[i] * b[i];
	    }
	    return d;
	}
	
	function euclideanDistance(coordinates) {
	    //calculate the euclidean distance between two points/vectors.
	    // used for normalization.
	    var d = 0;
	
	    for (var i = 0; i < coordinates.length; i++) {
	        d += Math.pow(coordinates[i], 2);
	    }
	    return Math.sqrt(d);
	}
	
	function normalize(arr) {
	    //normalizes a vector = arr/||arr||
	    var d = euclideanDistance(arr);
	    var narr = new Array(arr.length);
	    for (var i = 0; i < arr.length; i++) {
	        narr[i] = arr[i] / d;
	    }
	
	    return narr;
	}
	
	function rand(n) {
	    //create a vector of length n and fill with random numbers.
	    var arr = new Array(n);
	    for (var i = 0; i < n; i++) {
	        arr[i] = Math.random();
	    }return arr;
	}
	
	function add(a, b) {
	    var c = new Array(a.length);
	    for (var i = 0; i < a.length; i++) {
	        c[i] = new Array(a[i].length);
	        for (var j = 0; j < a[i].length; j++) {
	            c[i][j] = a[i][j] + b[i][j];
	        }
	    }
	    return c;
	}
	
	function symmetricRandMatrix(n, ulim) {
	    var mat = new Array(n);
	    for (var i = 0; i < n; i++) {
	        mat[i] = new Array(n);
	        mat[i][i] = 0;
	    }
	    for (var _i3 = 0; _i3 < n; _i3++) {
	        for (var j = _i3 + 1; j < n; j++) {
	            mat[_i3][j] = ulim * Math.random();
	            mat[j][_i3] = mat[_i3][j];
	        }
	    }
	    return mat;
	}
	
	function zeros(n) {
	    //create a vector filled with zeros
	    var arr = new Array(n);
	    for (var i = 0; i < n; i++) {
	        arr[i] = 0;
	    }return arr;
	}
	
	function ones(n) {
	    //create a vector filled with ones
	    var arr = new Array(n);
	    for (var i = 0; i < n; i++) {
	        arr[i] = 1;
	    }return arr;
	}
	
	function normalize2(x) {
	    var maxx = Math.max.apply(null, x.map(Math.abs));
	    var minx = Math.min.apply(null, x);
	    for (var i = 0; i < x.length; ++i) {
	        x[i] = 0.1 + (x[i] - minx) / ((maxx - minx) * 1.25);
	    }
	    return x;
	}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2017, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Author: Renato Fabbri
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	    // get degree of all nodes
	    function _class(nodes, edges) {
	        _classCallCheck(this, _class);
	
	        this._nodes = nodes;
	        this._edges = edges;
	        this._margin = 0.05; // from [0,1] borders
	        this._radius = 0.05; // of the empty circle on the center
	        this._nlines = 5;
	    }
	
	    _createClass(_class, [{
	        key: 'apply',
	        value: function apply() {
	            var nd = (0, _utils.degrees)(this._nodes, this._edges);
	            var nodes_segment = this._nodes.length / this._nlines;
	            var segment = 0.5 - (this._margin + this._radius);
	            var step = segment / nodes_segment;
	            var angle = 2 * Math.PI / this._nlines;
	            var j = 0;
	            for (var i = 0; i < this._nodes.length; ++i) {
	                var ii = nd.nodes[i].index;
	                this._nodes[ii].x = 0.5 + (this._radius + step * (i - j * nodes_segment)) * Math.cos(angle * j + Math.PI / 2);
	                this._nodes[ii].y = 0.5 + (this._radius + step * (i - j * nodes_segment)) * Math.sin(angle * j + Math.PI / 2);
	                j = Math.floor(i / nodes_segment);
	            }
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	     value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	     function _class(nodes, edges) {
	          _classCallCheck(this, _class);
	
	          this._nodes = nodes;
	          this._edges = edges;
	          this._margin = 0.05;
	     }
	
	     _createClass(_class, [{
	          key: 'apply',
	          value: function apply() {
	               var nd = (0, _utils.degrees)(this._nodes, this._edges);
	               var sq = Math.sqrt(this._nodes.length);
	               var reminder = sq - Math.floor(sq);
	               if (reminder > 0) var nnodes = Math.floor(sq) + 1;else var nnodes = sq;
	               var step = (1 - this._margin * 2) / nnodes;
	
	               var nlines = this._nodes.length / nnodes;
	               var reminder2 = nlines - Math.floor(nlines);
	               if (reminder2 > 0) var nlines2 = Math.floor(nlines) + 1;else var nlines2 = nlines;
	               var stepy = (1 - 2 * this._margin) / (nlines2 - 2);
	               for (var i = 0; i < this._nodes.length; ++i) {
	                    var j = Math.floor(i / (nnodes + 1));
	                    this._nodes[nd.nodes[i].index].x = this._margin + step * (i - j * (nnodes + 1));
	                    this._nodes[nd.nodes[i].index].y = this._margin + stepy * j;
	                    this._nodes[nd.nodes[i].index].weight = nd.degrees[i];
	               }
	          }
	     }]);
	
	     return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(14);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	  // the hubs are on the first half of the sinusoid period
	  // the intermediary are on the second half
	  // and the periphery are on the upper straight line
	  // further versions should enable the choice of other
	  // fractions of hubs, intermediary and peripheral vertices
	  // or the ErdÃ¶s sectioning.
	  // maybe also let the user set the endpoints of the periphery segment
	  function _class(nodes, edges) {
	    _classCallCheck(this, _class);
	
	    this._nodes = nodes;
	    this._edges = edges;
	    this._margin = 0.05;
	    this._hubs = 0.1; // 10%
	    this._intermediary = 0.2;
	  }
	
	  _createClass(_class, [{
	    key: 'apply',
	    value: function apply() {
	      var nd = (0, _utils.degrees)(this._nodes, this._edges);
	      var nhubs_intermediary = Math.floor(this._nodes.length * (this._hubs + this._intermediary));
	      var nhubs = Math.floor(this._nodes.length * this._hubs);
	      var stepx1 = (1 - 2 * this._margin) / 2 / (nhubs - 1);
	      var steprad = Math.PI / (nhubs - 1);
	      var i = 0;
	      while (i < nhubs) {
	        this._nodes[nd.nodes[i].index].x = this._margin + stepx1 * i;
	        this._nodes[nd.nodes[i].index].y = this._margin + 0.4 + 0.4 * Math.sin(i * steprad);
	        ++i;
	      }
	      var nintermediary = nhubs_intermediary - nhubs;
	      var steprad2 = Math.PI / nintermediary;
	      var stepx2 = (1 - 2 * this._margin) / 2 / nintermediary;
	      i = 0;
	      while (i < nintermediary) {
	        this._nodes[nd.nodes[i + nhubs].index].x = 0.5 + stepx2 * (i + 1);
	        this._nodes[nd.nodes[i + nhubs].index].y = this._margin + 0.4 + 0.4 * Math.sin(Math.PI + (i + 1) * steprad2);
	        ++i;
	      }
	      var p0 = [0.85, 0.75];
	      var p1 = [0.4, 1 - this._margin];
	      var nperipheral = this._nodes.length - nhubs_intermediary;
	      var stepxx = (p1[0] - p0[0]) / (nperipheral - 1);
	      var stepy = (p1[1] - p0[1]) / (nperipheral - 1);
	      i = 0;
	      while (i < nperipheral) {
	        this._nodes[nd.nodes[i + nhubs_intermediary].index].x = p0[0] + stepxx * i;
	        this._nodes[nd.nodes[i + nhubs_intermediary].index].y = p0[1] + stepy * i;
	        ++i;
	      }
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: AleÅ¡ Saska - http://alessaska.cz/
	 */
	
	var _class = function () {
	  function _class() {
	    _classCallCheck(this, _class);
	  }
	
	  _createClass(_class, null, [{
	    key: "edgeSource",
	    value: function edgeSource(e) {
	      if (e.source.source) {
	        //source is edge
	        var s = this.edgeSource(e.source);
	        var t = this.edgeTarget(e.source);
	
	        return {
	          x: (s.x + t.x) / 2,
	          y: (s.y + t.y) / 2,
	          uniqid: e.uniqid,
	          index: e.index,
	          is_edge: true,
	          e: e.source
	        };
	      }
	
	      return e.source;
	    }
	  }, {
	    key: "edgeTarget",
	    value: function edgeTarget(e) {
	      if (e.target.source) {
	        //target is edge
	        var s = this.edgeSource(e.target);
	        var t = this.edgeTarget(e.target);
	
	        return {
	          x: (s.x + t.x) / 2,
	          y: (s.y + t.y) / 2,
	          uniqid: e.uniqid,
	          index: e.index,
	          is_edge: true,
	          e: e.target
	        };
	      }
	
	      return e.target;
	    }
	  }, {
	    key: "getCurveShift",
	    value: function getCurveShift(e, r) {
	      r = r || {};
	      r.x = r.y = r.cx = r.cy = 0;
	      if (!e) return r;
	      if (e.t && e.t >= 1) {
	        //curve or circle
	        if (e.t >= 2) {
	          //circle
	          var s = this.edgeSource(e);
	          var d = s.y < 0.5 ? 1 : -1;
	
	          r.cx = d * 1.25;
	          r.cy = 0;
	        } else {
	          var se = this.edgeSource(e);
	          var te = this.edgeTarget(e);
	
	          r.x = se.x - te.x;
	          r.y = se.y - te.y;
	        }
	      }
	      return r;
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _rbush = __webpack_require__(30);
	
	var _rbush2 = _interopRequireDefault(_rbush);
	
	var _geomutils = __webpack_require__(28);
	
	var _geomutils2 = _interopRequireDefault(_geomutils);
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _primitiveTools = __webpack_require__(8);
	
	var _geomtools = __webpack_require__(31);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: AleÅ¡ Saska - http://alessaska.cz/
	 */
	
	var ct = {};
	function getEdgeShift(context, screensize, e, ct) {
	  _geomutils2.default.getCurveShift(e, ct); //get shift because of edge-to-edge functionality
	
	
	  //compute all transformations made in the vertex shader
	  var ctx = void 0,
	      cty = void 0,
	      citx = void 0,
	      city = void 0;
	
	  ctx = -ct.y;
	  cty = ct.x * context.aspect2;
	
	  var len2 = ctx * context.width * ctx * context.width + cty * context.height * cty * context.height;
	
	  if ((0, _geomtools.eq)(len2, 0)) {
	    ctx = 0;
	    cty = 0;
	  } else {
	    var len = Math.sqrt(len2);
	    ctx *= context.curveExc * 0.25 * screensize / len;
	    cty *= context.curveExc * 0.25 * screensize / len;
	  }
	
	  var sizex = 2.5 * context.nodeSize * screensize / context.width;
	  var sizey = 2.5 * context.nodeSize * screensize / context.height;
	  citx = -ct.cy * 0.5 * sizex;
	  city = ct.cx * 0.5 * sizey;
	
	  ct.x = ctx + citx;
	  ct.y = cty + city;
	}
	
	var Node = function () {
	  function Node(n) {
	    _classCallCheck(this, Node);
	
	    this.e = n;
	  }
	
	  _createClass(Node, [{
	    key: 'getBBox',
	    value: function getBBox() {
	      return [this.e.x - _geomtools.EPS, this.e.y - _geomtools.EPS, this.e.x + _geomtools.EPS, this.e.y + _geomtools.EPS];
	    }
	  }, {
	    key: 'intersectsRect',
	    value: function intersectsRect(x1, y1, x2, y2) {
	      return (0, _geomtools.pointInRect)(this.e.x, this.e.y, x1, y1, x2, y2);
	    }
	  }, {
	    key: 'dist2',
	    value: function dist2(x, y, context) {
	      return (0, _geomtools.distance2)(x, y, this.e.x, this.e.y);
	    }
	  }, {
	    key: 'isNode',
	    get: function get() {
	      return true;
	    }
	  }]);
	
	  return Node;
	}();
	
	var Label = function () {
	  function Label(n, textpos, style, fontSize, isSDF, getLabelSize) {
	    _classCallCheck(this, Label);
	
	    this.e = n;
	    this.pos = textpos;
	    this.style = style;
	    this.fontSize = fontSize;
	    this.isSDF = isSDF;
	    this.getLabelSize = getLabelSize;
	  }
	
	  _createClass(Label, [{
	    key: 'getTextPos',
	    value: function getTextPos(context, size) {
	      var x = this.e.x;
	      var y = this.e.y;
	
	      var x1 = void 0,
	          y1 = void 0,
	          x2 = void 0,
	          y2 = void 0;
	      x1 = x2 = x;
	      y1 = y2 = y;
	
	      var wantedSize = this.isSDF ? this.getLabelSize(context, this.style.label || {}) : this.fontSize;
	
	      var fontScale = wantedSize / this.fontSize;
	      if (wantedSize === 0) {
	        fontScale = 0;
	      };
	
	      var step = function step(edge, x) {
	        return x < edge ? 0 : 1;
	      };
	
	      var offset = 0.5 * context.nodeSize;
	      var MAX = 10.;
	      var MIN = -10.;
	      var bbox = [MAX, MAX, MIN, MIN];
	
	      this.pos.forEach(function (c) {
	        var offsety = (2.0 * step(y, 0.5) - 1.0) * offset;
	        x1 = x + size * (c.dx * fontScale) / context.width / 2;
	        y1 = y + size * (c.dy * fontScale + offsety) / context.height / 2;
	        x2 = x + size * ((c.dx + c.width) * fontScale) / context.width / 2;
	        y2 = y + size * ((c.dy + c.height) * fontScale + offsety) / context.height / 2;
	
	        bbox[0] = Math.min(x1, bbox[0]);
	        bbox[1] = Math.min(y1, bbox[1]);
	        bbox[2] = Math.max(x2, bbox[2]);
	        bbox[3] = Math.max(y2, bbox[3]);
	      });
	
	      return bbox;
	    }
	  }, {
	    key: 'getBBox',
	    value: function getBBox(context) {
	      var bb = this.getTextPos(context, 1);
	      bb[0] = Math.min(bb[0], this.e.x);
	      bb[1] = Math.min(bb[1], this.e.y);
	      bb[2] = Math.max(bb[2], this.e.x);
	      bb[3] = Math.max(bb[3], this.e.y);
	      return bb;
	    }
	  }, {
	    key: 'intersectsRect',
	    value: function intersectsRect(x1, y1, x2, y2, context, size) {
	      var t = this.getTextPos(context, size);
	      return (0, _geomtools.rectIntersectsRect)(x1, y1, x2, y2, t[0], t[1], t[2], t[3]);
	    }
	  }, {
	    key: 'dist2',
	    value: function dist2(x, y, context, size) {
	      var t = this.getTextPos(context, size);
	
	      if ((0, _geomtools.pointInRect)(x, y, t[0], t[1], t[2], t[3])) return 0;
	
	      //minimum from distance from corners or distance from borders
	      return Math.min((0, _geomtools.distance2)(t[0], t[1]), (0, _geomtools.distance2)(t[2], t[3]), (0, _geomtools.distance2)(t[0], t[3]), (0, _geomtools.distance2)(t[2], t[1]), (0, _geomtools.pDistance2)(x, y, t[0], t[1], t[2], t[1]), (0, _geomtools.pDistance2)(x, y, t[0], t[3], t[2], t[3]), (0, _geomtools.pDistance2)(x, y, t[0], t[1], t[0], t[3]), (0, _geomtools.pDistance2)(x, y, t[2], t[1], t[2], t[3]));
	    }
	  }, {
	    key: 'isLabel',
	    get: function get() {
	      return true;
	    }
	  }]);
	
	  return Label;
	}();
	
	var Line = function () {
	  function Line(l) {
	    _classCallCheck(this, Line);
	
	    this.e = l;
	  }
	
	  _createClass(Line, [{
	    key: 'getPoints',
	    value: function getPoints(context, size) {
	      var x1 = void 0,
	          y1 = void 0,
	          x2 = void 0,
	          y2 = void 0;
	
	      var s = _geomutils2.default.edgeSource(this.e);
	      var t = _geomutils2.default.edgeTarget(this.e);
	
	      x1 = s.x;
	      y1 = s.y;
	      x2 = t.x;
	      y2 = t.y;
	
	      getEdgeShift(context, size, s.e, ct);
	      x1 += ct.x;
	      y1 += ct.y;
	      getEdgeShift(context, size, t.e, ct);
	      x2 += ct.x;
	      y2 += ct.y;
	
	      return [x1, y1, x2, y2];
	    }
	  }, {
	    key: 'getBBox',
	    value: function getBBox(context, size) {
	      var p = this.getPoints(context, size);
	
	      return [Math.min(p[0], p[2]), Math.min(p[1], p[3]), Math.max(p[0], p[2]), Math.max(p[1], p[3])];
	    }
	  }, {
	    key: 'intersectsRect',
	    value: function intersectsRect(x1, y1, x2, y2, context, size) {
	      var p = this.getPoints(context, size);
	
	      return (0, _geomtools.lineIntersectsRect)(p[0], p[1], p[2], p[3], x1, y1, x2, y2);
	    }
	  }, {
	    key: 'dist2',
	    value: function dist2(x, y, context, size) {
	      var p = this.getPoints(context, size);
	
	      return (0, _geomtools.pDistance2)(x, y, p[0], p[1], p[2], p[3]);
	    }
	  }, {
	    key: 'isEdge',
	    get: function get() {
	      return true;
	    }
	  }]);
	
	  return Line;
	}();
	
	var Circle = function () {
	  function Circle(c) {
	    _classCallCheck(this, Circle);
	
	    this.e = c;
	  }
	
	  _createClass(Circle, [{
	    key: 'getBezierPoints',
	    value: function getBezierPoints(context, screensize) {
	      var x1 = void 0,
	          y1 = void 0,
	          s = void 0;
	      s = _geomutils2.default.edgeSource(this.e);
	      x1 = s.x;
	      y1 = s.y;
	
	      var size = 2.5 * context.nodeSize * screensize;
	      var xsize = size / context.width / 2;
	      var ysize = size / context.height / 2;
	
	      var d = s.y < 0.5 ? 1 : -1;
	
	      getEdgeShift(context, screensize, s.e, ct);
	      x1 += ct.x;
	      y1 += ct.y;
	
	      return [x1, y1, x1 + xsize * 1, y1 + ysize * d, x1, y1 + ysize * 1.25 * d, x1 - xsize * 1, y1 + ysize * d];
	    }
	  }, {
	    key: 'getBBox',
	    value: function getBBox(context, size) {
	      var v = this.getBezierPoints(context, size);
	
	      return (0, _geomtools.getBBFromPoints)(v);
	    }
	  }, {
	    key: 'intersectsRect',
	    value: function intersectsRect(x1, y1, x2, y2, context, size, normalize) {
	      var v = this.getBezierPoints(context, size);
	      return (0, _geomtools.bezierIntersectsRect)(v[0], v[1], v[2], v[3], v[4], v[5], x1, y1, x2, y2) || (0, _geomtools.bezierIntersectsRect)(v[2], v[3], v[4], v[5], v[6], v[7], x1, y1, x2, y2);
	    }
	  }, {
	    key: 'dist2',
	    value: function dist2(x, y, context, size) {
	      var v = this.getBezierPoints(context, size);
	
	      //circle is just 2 bezier curves :)
	      var d1 = (0, _geomtools.distance2ToBezier)(x, y, v[0], v[1], v[2], v[3], v[4], v[5]);
	      var d2 = (0, _geomtools.distance2ToBezier)(x, y, v[2], v[3], v[4], v[5], v[6], v[7]);
	
	      return Math.min(d1, d2);
	    }
	  }, {
	    key: 'isEdge',
	    get: function get() {
	      return true;
	    }
	  }]);
	
	  return Circle;
	}();
	
	var Curve = function () {
	  function Curve(c) {
	    _classCallCheck(this, Curve);
	
	    this.e = c;
	  }
	
	  _createClass(Curve, [{
	    key: 'getBezierPoints',
	    value: function getBezierPoints(context, size, normalize) {
	      var x1 = void 0,
	          x2 = void 0,
	          y1 = void 0,
	          y2 = void 0;
	      var s = _geomutils2.default.edgeSource(this.e);
	      var t = _geomutils2.default.edgeTarget(this.e);
	
	      x1 = s.x;
	      y1 = s.y;
	      x2 = t.x;
	      y2 = t.y;
	
	      var d = normalize(s, t);
	
	      var n2 = d.y;
	      var n3 = context.aspect2 * -d.x;
	
	      var x = context.width * n2;
	      var y = context.height * n3;
	      var l = Math.sqrt(x * x + y * y) * 2;
	
	      n2 *= context.curveExc * size / l;
	      n3 *= context.curveExc * size / l;
	
	      getEdgeShift(context, size, s.e, ct);
	      x1 += ct.x;
	      y1 += ct.y;
	      getEdgeShift(context, size, t.e, ct);
	      x2 += ct.x;
	      y2 += ct.y;
	
	      var ret = [x1, y1, (x1 + x2) / 2 + n2, (y1 + y2) / 2 + n3, x2, y2];
	      return ret;
	    }
	  }, {
	    key: 'intersectsRect',
	    value: function intersectsRect(x1, y1, x2, y2, context, size, normalize) {
	      var v = this.getBezierPoints(context, size, normalize);
	      return (0, _geomtools.bezierIntersectsRect)(v[0], v[1], v[2], v[3], v[4], v[5], x1, y1, x2, y2);
	    }
	  }, {
	    key: 'getBBox',
	    value: function getBBox(context, size, normalize) {
	      var v = this.getBezierPoints(context, size, normalize);
	      return (0, _geomtools.getBBFromPoints)(v);
	    }
	  }, {
	    key: 'dist2',
	    value: function dist2(x, y, context, size, normalize) {
	      var v = this.getBezierPoints(context, size, normalize);
	      return (0, _geomtools.distance2ToBezier)(x, y, v[0], v[1], v[2], v[3], v[4], v[5]);
	    }
	  }, {
	    key: 'isEdge',
	    get: function get() {
	      return true;
	    }
	  }]);
	
	  return Curve;
	}();
	
	function sortByDistances(e1, e2) {
	  return e1.dist2 - e2.dist2;
	}
	
	var tConst = { nodes: Node, lines: Line, circles: Circle, curves: Curve, labels: Label };
	
	var spatialIndex = function () {
	  function spatialIndex(c, texts, options, nodes, nodesParts, lines, linesParts, curves, curvesParts, circles, circlesParts, normalize, nodeStyle, getLabelSize, getLabelHideScreen) {
	    _classCallCheck(this, spatialIndex);
	
	    //init all elements into rbush tree with size 1 (outer bound - the worst case)
	    var size = 1;var oldsize = c.size || 1;c.size = 1.;
	
	    this.texts = texts;
	    this.normalize = normalize;
	    var t = this.types = { nodes: [], lines: [], circles: [], curves: [], labels: [] };
	    var i = 0,
	        d = [];
	
	    var addEntity = function addEntity(e, d, i) {
	      d[i] = e.getBBox(c, size, normalize);
	      d[i].push(e);
	      return e;
	    };
	
	    nodes.forEach(function (n) {
	      t.nodes.push(addEntity(new Node(n), d, i++));
	    });
	
	    lines.forEach(function (l) {
	      t.lines.push(addEntity(new Line(l), d, i++));
	    });
	
	    circles.forEach(function (c) {
	      t.circles.push(addEntity(new Circle(c), d, i++));
	    });
	
	    curves.forEach(function (c) {
	      t.curves.push(addEntity(new Curve(c), d, i++));
	    });
	
	    var sd = {};
	    var sdi = {};
	
	    //labels position could differ by style >> must partition by it
	
	    var _loop = function _loop(style) {
	      var nodes = nodesParts[style];
	
	      var ns = (0, _primitiveTools.getPartitionStyle)(options.styles[style], nodeStyle, "label");
	      var textEngine = texts.getEngine(ns.font);
	      textEngine.setFont(ns.font);
	      var fontSize = textEngine.fontSize;
	      var isSDF = textEngine.isSDF;
	
	      var sd_n = sd[style] || (sd[style] = []);
	      var sdi_n = sdi[style] || (sdi[style] = 0);
	
	      //biggest size in which the text is shown
	      c.size = getLabelHideScreen(c, ns.label || {});
	      nodes.forEach(function (n) {
	        var textpos = textEngine.get(n.label, n.x, n.y);
	        t.labels.push(addEntity(new Label(n, textpos, ns, fontSize, isSDF, getLabelSize), sd_n, sdi_n++));
	      });
	
	      sdi[style] = sdi_n;
	    };
	
	    for (var style in nodesParts) {
	      _loop(style);
	    }
	
	    this.rbushtree_s = {};
	    for (var style in sd) {
	      var rb = this.rbushtree_s[style] = (0, _rbush2.default)();
	      rb.load(sd[style]);
	    }
	
	    //tree initialization
	    this.rbushtree = (0, _rbush2.default)();
	    this.rbushtree.load(d);
	
	    //restore the size of scale (loosen outer the upper bound)
	    c.size = oldsize;
	  }
	
	  _createClass(spatialIndex, [{
	    key: '_tryAddEl',
	    value: function _tryAddEl(ret, e, dist2, nodes, edges, labels) {
	      if (nodes && e.isNode) {
	        ret.nodes.push({ node: e.e, dist: Math.sqrt(dist2), dist2: dist2 });
	      }
	      if (edges && e.isEdge) {
	        ret.edges.push({ edge: e.e, dist: Math.sqrt(dist2), dist2: dist2 });
	      }
	      if (labels && e.isLabel) {
	        ret.labels.push({ label: e.e, dist: Math.sqrt(dist2), dist2: dist2 });
	      }
	    }
	  }, {
	    key: 'findArea',
	    value: function findArea(context, x1, y1, x2, y2, size, nodes, edges, labels) {
	      if (x1 > x2) {
	        var p = x1;
	        x1 = x2;
	        x2 = p;
	      }
	      if (y1 > y2) {
	        var _p = y1;
	        y1 = y2;
	        y2 = _p;
	      }
	
	      var ret = {};
	      if (edges) ret.edges = [];
	      if (nodes) ret.nodes = [];
	      if (labels) ret.labels = [];
	
	      var x = (x1 + x2) / 2;
	      var y = (y1 + y2) / 2;
	
	      var data = this.rbushtree.search([x1 - _geomtools.EPS, y1 - _geomtools.EPS, x2 + _geomtools.EPS, y2 + _geomtools.EPS]);
	      if (labels) {
	        for (var s in this.rbushtree_s) {
	          data = data.concat(this.rbushtree_s[s].search([x1 - _geomtools.EPS, y1 - _geomtools.EPS, x2 + _geomtools.EPS, y2 + _geomtools.EPS]));
	        }
	      }
	
	      for (var i = 0; i < data.length; i++) {
	        var e = data[i][4];
	        var dist2 = e.dist2(x, y, context, size, this.normalize, this.texts);
	        if (!e.intersectsRect(x1, y1, x2, y2, context, size, this.normalize, this.texts)) continue;
	
	        this._tryAddEl(ret, e, dist2, nodes, edges, labels);
	      }
	
	      for (var k in ret) {
	        ret[k].sort(sortByDistances);
	      }
	
	      return ret;
	    }
	  }, {
	    key: 'find',
	    value: function find(context, x, y, radius, size, nodes, edges, labels) {
	      var ret = {};
	      if (edges) ret.edges = [];
	      if (nodes) ret.nodes = [];
	      if (labels) ret.labels = [];
	
	      var xradius = radius;
	      var yradius = radius;
	
	      var radius2 = radius * radius;
	
	      var data = this.rbushtree.search([x - xradius, y - yradius, x + xradius, y + yradius]);
	      if (labels) {
	        for (var s in this.rbushtree_s) {
	          data = data.concat(this.rbushtree_s[s].search([x - xradius, y - yradius, x + xradius, y + yradius]));
	        }
	      }
	
	      for (var i = 0; i < data.length; i++) {
	        var e = data[i][4];
	        var dist2 = e.dist2(x, y, context, size, this.normalize, this.texts);
	        if (dist2 > radius2) continue;
	
	        this._tryAddEl(ret, e, dist2, nodes, edges, labels);
	      }
	
	      for (var k in ret) {
	        ret[k].sort(sortByDistances);
	      }
	
	      return ret;
	    }
	  }, {
	    key: 'update',
	    value: function update(context, t, i, v) {
	      //init all elements into rbush tree with size 1 (the biggest possible - the worst case)
	      var size = 1;
	
	      this.rbushtree.remove(this.types[t][i]);
	
	      var e = new tConst[t](v);
	      var arr = e.getBBox(context, size, this.normalize, this.texts);
	      arr.push(e);
	
	      this.rbushtree.insert(this.types[t][i] = arr);
	    }
	  }]);
	
	  return spatialIndex;
	}();
	
	exports.default = spatialIndex;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 (c) 2015, Vladimir Agafonkin
	 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
	 https://github.com/mourner/rbush
	*/
	
	function rbush(maxEntries, format) {
	    if (!(this instanceof rbush)) return new rbush(maxEntries, format);
	
	    // max entries in a node is 9 by default; min node fill is 40% for best performance
	    this._maxEntries = Math.max(4, maxEntries || 9);
	    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
	
	    if (format) {
	        this._initFormat(format);
	    }
	
	    this.clear();
	}
	
	rbush.prototype = {
	
	    all: function all() {
	        return this._all(this.data, []);
	    },
	
	    search: function search(bbox) {
	
	        var node = this.data,
	            result = [],
	            toBBox = this.toBBox;
	
	        if (!intersects(bbox, node.bbox)) return result;
	
	        var nodesToSearch = [],
	            i,
	            len,
	            child,
	            childBBox;
	
	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {
	
	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child.bbox;
	
	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }
	
	        return result;
	    },
	
	    collides: function collides(bbox) {
	
	        var node = this.data,
	            toBBox = this.toBBox;
	
	        if (!intersects(bbox, node.bbox)) return false;
	
	        var nodesToSearch = [],
	            i,
	            len,
	            child,
	            childBBox;
	
	        while (node) {
	            for (i = 0, len = node.children.length; i < len; i++) {
	
	                child = node.children[i];
	                childBBox = node.leaf ? toBBox(child) : child.bbox;
	
	                if (intersects(bbox, childBBox)) {
	                    if (node.leaf || contains(bbox, childBBox)) return true;
	                    nodesToSearch.push(child);
	                }
	            }
	            node = nodesToSearch.pop();
	        }
	
	        return false;
	    },
	
	    load: function load(data) {
	        if (!(data && data.length)) return this;
	
	        if (data.length < this._minEntries) {
	            for (var i = 0, len = data.length; i < len; i++) {
	                this.insert(data[i]);
	            }
	            return this;
	        }
	
	        // recursively build the tree with the given data from stratch using OMT algorithm
	        var node = this._build(data.slice(), 0, data.length - 1, 0);
	
	        if (!this.data.children.length) {
	            // save as is if tree is empty
	            this.data = node;
	        } else if (this.data.height === node.height) {
	            // split root if trees have the same height
	            this._splitRoot(this.data, node);
	        } else {
	            if (this.data.height < node.height) {
	                // swap trees if inserted one is bigger
	                var tmpNode = this.data;
	                this.data = node;
	                node = tmpNode;
	            }
	
	            // insert the small tree into the large tree at appropriate level
	            this._insert(node, this.data.height - node.height - 1, true);
	        }
	
	        return this;
	    },
	
	    insert: function insert(item) {
	        if (item) this._insert(item, this.data.height - 1);
	        return this;
	    },
	
	    clear: function clear() {
	        this.data = {
	            children: [],
	            height: 1,
	            bbox: empty(),
	            leaf: true
	        };
	        return this;
	    },
	
	    remove: function remove(item) {
	        if (!item) return this;
	
	        var node = this.data,
	            bbox = this.toBBox(item),
	            path = [],
	            indexes = [],
	            i,
	            parent,
	            index,
	            goingUp;
	
	        // depth-first iterative tree traversal
	        while (node || path.length) {
	
	            if (!node) {
	                // go up
	                node = path.pop();
	                parent = path[path.length - 1];
	                i = indexes.pop();
	                goingUp = true;
	            }
	
	            if (node.leaf) {
	                // check current node
	                index = node.children.indexOf(item);
	
	                if (index !== -1) {
	                    // item found, remove the item and condense tree upwards
	                    node.children.splice(index, 1);
	                    path.push(node);
	                    this._condense(path);
	                    return this;
	                }
	            }
	
	            if (!goingUp && !node.leaf && contains(node.bbox, bbox)) {
	                // go down
	                path.push(node);
	                indexes.push(i);
	                i = 0;
	                parent = node;
	                node = node.children[0];
	            } else if (parent) {
	                // go right
	                i++;
	                node = parent.children[i];
	                goingUp = false;
	            } else node = null; // nothing found
	        }
	
	        return this;
	    },
	
	    toBBox: function toBBox(item) {
	        return item;
	    },
	
	    compareMinX: function compareMinX(a, b) {
	        return a[0] - b[0];
	    },
	    compareMinY: function compareMinY(a, b) {
	        return a[1] - b[1];
	    },
	
	    toJSON: function toJSON() {
	        return this.data;
	    },
	
	    fromJSON: function fromJSON(data) {
	        this.data = data;
	        return this;
	    },
	
	    _all: function _all(node, result) {
	        var nodesToSearch = [];
	        while (node) {
	            if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
	
	            node = nodesToSearch.pop();
	        }
	        return result;
	    },
	
	    _build: function _build(items, left, right, height) {
	
	        var N = right - left + 1,
	            M = this._maxEntries,
	            node;
	
	        if (N <= M) {
	            // reached leaf level; return leaf
	            node = {
	                children: items.slice(left, right + 1),
	                height: 1,
	                bbox: null,
	                leaf: true
	            };
	            calcBBox(node, this.toBBox);
	            return node;
	        }
	
	        if (!height) {
	            // target height of the bulk-loaded tree
	            height = Math.ceil(Math.log(N) / Math.log(M));
	
	            // target number of root entries to maximize storage utilization
	            M = Math.ceil(N / Math.pow(M, height - 1));
	        }
	
	        node = {
	            children: [],
	            height: height,
	            bbox: null,
	            leaf: false
	        };
	
	        // split the items into M mostly square tiles
	
	        var N2 = Math.ceil(N / M),
	            N1 = N2 * Math.ceil(Math.sqrt(M)),
	            i,
	            j,
	            right2,
	            right3;
	
	        multiSelect(items, left, right, N1, this.compareMinX);
	
	        for (i = left; i <= right; i += N1) {
	
	            right2 = Math.min(i + N1 - 1, right);
	
	            multiSelect(items, i, right2, N2, this.compareMinY);
	
	            for (j = i; j <= right2; j += N2) {
	
	                right3 = Math.min(j + N2 - 1, right2);
	
	                // pack each entry recursively
	                node.children.push(this._build(items, j, right3, height - 1));
	            }
	        }
	
	        calcBBox(node, this.toBBox);
	
	        return node;
	    },
	
	    _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
	
	        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
	
	        while (true) {
	            path.push(node);
	
	            if (node.leaf || path.length - 1 === level) break;
	
	            minArea = minEnlargement = Infinity;
	
	            for (i = 0, len = node.children.length; i < len; i++) {
	                child = node.children[i];
	                area = bboxArea(child.bbox);
	                enlargement = enlargedArea(bbox, child.bbox) - area;
	
	                // choose entry with the least area enlargement
	                if (enlargement < minEnlargement) {
	                    minEnlargement = enlargement;
	                    minArea = area < minArea ? area : minArea;
	                    targetNode = child;
	                } else if (enlargement === minEnlargement) {
	                    // otherwise choose one with the smallest area
	                    if (area < minArea) {
	                        minArea = area;
	                        targetNode = child;
	                    }
	                }
	            }
	
	            node = targetNode || node.children[0];
	        }
	
	        return node;
	    },
	
	    _insert: function _insert(item, level, isNode) {
	
	        var toBBox = this.toBBox,
	            bbox = isNode ? item.bbox : toBBox(item),
	            insertPath = [];
	
	        // find the best node for accommodating the item, saving all nodes along the path too
	        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
	
	        // put the item into the node
	        node.children.push(item);
	        extend(node.bbox, bbox);
	
	        // split on node overflow; propagate upwards if necessary
	        while (level >= 0) {
	            if (insertPath[level].children.length > this._maxEntries) {
	                this._split(insertPath, level);
	                level--;
	            } else break;
	        }
	
	        // adjust bboxes along the insertion path
	        this._adjustParentBBoxes(bbox, insertPath, level);
	    },
	
	    // split overflowed node into two
	    _split: function _split(insertPath, level) {
	
	        var node = insertPath[level],
	            M = node.children.length,
	            m = this._minEntries;
	
	        this._chooseSplitAxis(node, m, M);
	
	        var splitIndex = this._chooseSplitIndex(node, m, M);
	
	        var newNode = {
	            children: node.children.splice(splitIndex, node.children.length - splitIndex),
	            height: node.height,
	            bbox: null,
	            leaf: false
	        };
	
	        if (node.leaf) newNode.leaf = true;
	
	        calcBBox(node, this.toBBox);
	        calcBBox(newNode, this.toBBox);
	
	        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
	    },
	
	    _splitRoot: function _splitRoot(node, newNode) {
	        // split root node
	        this.data = {
	            children: [node, newNode],
	            height: node.height + 1,
	            bbox: null,
	            leaf: false
	        };
	        calcBBox(this.data, this.toBBox);
	    },
	
	    _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
	
	        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
	
	        minOverlap = minArea = Infinity;
	
	        for (i = m; i <= M - m; i++) {
	            bbox1 = distBBox(node, 0, i, this.toBBox);
	            bbox2 = distBBox(node, i, M, this.toBBox);
	
	            overlap = intersectionArea(bbox1, bbox2);
	            area = bboxArea(bbox1) + bboxArea(bbox2);
	
	            // choose distribution with minimum overlap
	            if (overlap < minOverlap) {
	                minOverlap = overlap;
	                index = i;
	
	                minArea = area < minArea ? area : minArea;
	            } else if (overlap === minOverlap) {
	                // otherwise choose distribution with minimum area
	                if (area < minArea) {
	                    minArea = area;
	                    index = i;
	                }
	            }
	        }
	
	        return index;
	    },
	
	    // sorts node children by the best axis for split
	    _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
	
	        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
	            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
	            xMargin = this._allDistMargin(node, m, M, compareMinX),
	            yMargin = this._allDistMargin(node, m, M, compareMinY);
	
	        // if total distributions margin value is minimal for x, sort by minX,
	        // otherwise it's already sorted by minY
	        if (xMargin < yMargin) node.children.sort(compareMinX);
	    },
	
	    // total margin of all possible split distributions where each node is at least m full
	    _allDistMargin: function _allDistMargin(node, m, M, compare) {
	
	        node.children.sort(compare);
	
	        var toBBox = this.toBBox,
	            leftBBox = distBBox(node, 0, m, toBBox),
	            rightBBox = distBBox(node, M - m, M, toBBox),
	            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
	            i,
	            child;
	
	        for (i = m; i < M - m; i++) {
	            child = node.children[i];
	            extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
	            margin += bboxMargin(leftBBox);
	        }
	
	        for (i = M - m - 1; i >= m; i--) {
	            child = node.children[i];
	            extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
	            margin += bboxMargin(rightBBox);
	        }
	
	        return margin;
	    },
	
	    _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
	        // adjust bboxes along the given tree path
	        for (var i = level; i >= 0; i--) {
	            extend(path[i].bbox, bbox);
	        }
	    },
	
	    _condense: function _condense(path) {
	        // go through the path, removing empty nodes and updating bboxes
	        for (var i = path.length - 1, siblings; i >= 0; i--) {
	            if (path[i].children.length === 0) {
	                if (i > 0) {
	                    siblings = path[i - 1].children;
	                    siblings.splice(siblings.indexOf(path[i]), 1);
	                } else this.clear();
	            } else calcBBox(path[i], this.toBBox);
	        }
	    },
	
	    _initFormat: function _initFormat(format) {
	        // data format (minX, minY, maxX, maxY accessors)
	
	        // uses eval-type function compilation instead of just accepting a toBBox function
	        // because the algorithms are very sensitive to sorting functions performance,
	        // so they should be dead simple and without inner calls
	
	        var compareArr = ['return a', ' - b', ';'];
	
	        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
	        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
	
	        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
	    }
	};
	
	// calculate node's bbox from bboxes of its children
	function calcBBox(node, toBBox) {
	    node.bbox = distBBox(node, 0, node.children.length, toBBox);
	}
	
	// min bounding rectangle of node children from k to p-1
	function distBBox(node, k, p, toBBox) {
	    var bbox = empty();
	
	    for (var i = k, child; i < p; i++) {
	        child = node.children[i];
	        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
	    }
	
	    return bbox;
	}
	
	function empty() {
	    return [Infinity, Infinity, -Infinity, -Infinity];
	}
	
	function extend(a, b) {
	    a[0] = Math.min(a[0], b[0]);
	    a[1] = Math.min(a[1], b[1]);
	    a[2] = Math.max(a[2], b[2]);
	    a[3] = Math.max(a[3], b[3]);
	    return a;
	}
	
	function compareNodeMinX(a, b) {
	    return a.bbox[0] - b.bbox[0];
	}
	function compareNodeMinY(a, b) {
	    return a.bbox[1] - b.bbox[1];
	}
	
	function bboxArea(a) {
	    return (a[2] - a[0]) * (a[3] - a[1]);
	}
	function bboxMargin(a) {
	    return a[2] - a[0] + (a[3] - a[1]);
	}
	
	function enlargedArea(a, b) {
	    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) * (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
	}
	
	function intersectionArea(a, b) {
	    var minX = Math.max(a[0], b[0]),
	        minY = Math.max(a[1], b[1]),
	        maxX = Math.min(a[2], b[2]),
	        maxY = Math.min(a[3], b[3]);
	
	    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
	}
	
	function contains(a, b) {
	    return a[0] <= b[0] && a[1] <= b[1] && b[2] <= a[2] && b[3] <= a[3];
	}
	
	function intersects(a, b) {
	    return b[0] <= a[2] && b[1] <= a[3] && b[2] >= a[0] && b[3] >= a[1];
	}
	
	// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
	// combines selection algorithm with binary divide & conquer approach
	
	function multiSelect(arr, left, right, n, compare) {
	    var stack = [left, right],
	        mid;
	
	    while (stack.length) {
	        right = stack.pop();
	        left = stack.pop();
	
	        if (right - left <= n) continue;
	
	        mid = left + Math.ceil((right - left) / n / 2) * n;
	        select(arr, left, right, mid, compare);
	
	        stack.push(left, mid, mid, right);
	    }
	}
	
	// Floyd-Rivest selection algorithm:
	// sort an array between left and right (inclusive) so that the smallest k elements come first (unordered)
	function select(arr, left, right, k, compare) {
	    var n, i, z, s, sd, newLeft, newRight, t, j;
	
	    while (right > left) {
	        if (right - left > 600) {
	            n = right - left + 1;
	            i = k - left + 1;
	            z = Math.log(n);
	            s = 0.5 * Math.exp(2 * z / 3);
	            sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);
	            newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
	            newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
	            select(arr, newLeft, newRight, k, compare);
	        }
	
	        t = arr[k];
	        i = left;
	        j = right;
	
	        swap(arr, left, k);
	        if (compare(arr[right], t) > 0) swap(arr, left, right);
	
	        while (i < j) {
	            swap(arr, i, j);
	            i++;
	            j--;
	            while (compare(arr[i], t) < 0) {
	                i++;
	            }while (compare(arr[j], t) > 0) {
	                j--;
	            }
	        }
	
	        if (compare(arr[left], t) === 0) swap(arr, left, j);else {
	            j++;
	            swap(arr, j, right);
	        }
	
	        if (j <= k) left = j + 1;
	        if (k <= j) right = j - 1;
	    }
	}
	
	function swap(arr, i, j) {
	    var tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}
	
	exports.default = rbush;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.neq = exports.eq = exports.getBBFromPoints = exports.pDistance2 = exports.distance2 = exports.distance2ToBezier = exports.pointInRect = exports.rectIntersectsRect = exports.lineIntersectsRect = exports.bezierIntersectsLine = exports.bezierIntersectsRect = exports.EPS = undefined;
	
	var _rbush = __webpack_require__(30);
	
	var _rbush2 = _interopRequireDefault(_rbush);
	
	var _geomutils = __webpack_require__(28);
	
	var _geomutils2 = _interopRequireDefault(_geomutils);
	
	var _primitiveTools = __webpack_require__(8);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: AleÅ¡ Saska - http://alessaska.cz/
	 */
	
	var EPS = Number.EPSILON || 1e-14;
	
	//solving cube analyticaly for bezier curves
	function cuberoot(x) {
	  var y = Math.pow(Math.abs(x), 1 / 3);
	  return x < 0 ? -y : y;
	}
	
	function solveCubic(a, b, c, d) {
	  if (Math.abs(a) < 1e-8) {
	    // Quadratic case, ax^2+bx+c=0
	    a = b;b = c;c = d;
	    if (Math.abs(a) < 1e-8) {
	      // Linear case, ax+b=0
	      a = b;b = c;
	      if (Math.abs(a) < 1e-8) // Degenerate case
	        return [];
	      return [-b / a];
	    }
	
	    var D = b * b - 4 * a * c;
	    if (Math.abs(D) < 1e-8) return [-b / (2 * a)];else if (D > 0) return [(-b + Math.sqrt(D)) / (2 * a), (-b - Math.sqrt(D)) / (2 * a)];
	    return [];
	  }
	
	  // Convert to depressed cubic t^3+pt+q = 0 (subst x = t - b/3a)
	  var p = (3 * a * c - b * b) / (3 * a * a);
	  var q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);
	  var roots = void 0;
	
	  if (Math.abs(p) < 1e-8) {
	    // p = 0 -> t^3 = -q -> t = -q^1/3
	    roots = [cuberoot(-q)];
	  } else if (Math.abs(q) < 1e-8) {
	    // q = 0 -> t^3 + pt = 0 -> t(t^2+p)=0
	    roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
	  } else {
	    var _D = q * q / 4 + p * p * p / 27;
	    if (Math.abs(_D) < 1e-8) {
	      // D = 0 -> two roots
	      roots = [-1.5 * q / p, 3 * q / p];
	    } else if (_D > 0) {
	      // Only one real root
	      var u = cuberoot(-q / 2 - Math.sqrt(_D));
	      roots = [u - p / (3 * u)];
	    } else {
	      // D < 0, three roots, but needs to use complex numbers/trigonometric solution
	      var _u = 2 * Math.sqrt(-p / 3);
	      var t = Math.acos(3 * q / p / _u) / 3; // D < 0 implies p < 0 and acos argument in [-1..1]
	      var k = 2 * Math.PI / 3;
	      roots = [_u * Math.cos(t), _u * Math.cos(t - k), _u * Math.cos(t - 2 * k)];
	    }
	  }
	
	  // Convert back from depressed cubic
	  for (var i = 0; i < roots.length; i++) {
	    roots[i] -= b / (3 * a);
	  }return roots;
	}
	
	//function distanceToBezier(x,y,ax,ay,bx,by,cx,cy){
	function distance2ToBezier(x, y, a, d, b, e, c, f) {
	  //based on compute derivation of: d/dt ((X - (a*(1-t)*(1-t)+2*b*t*(1-t)+c*t*t))^2 + (Y - (d*(1-t)*(1-t)+2*e*t*(1-t)+f*t*t))^2)
	
	  var A = 4 * a * a - 16 * a * b + 8 * a * c + 16 * b * b - 16 * b * c + 4 * c * c + 4 * d * d - 16 * d * e + 8 * d * f + 16 * e * e - 16 * e * f + 4 * f * f;
	  var B = -12 * a * a + 36 * a * b - 12 * a * c - 24 * b * b + 12 * b * c - 12 * d * d + 36 * d * e - 12 * d * f - 24 * e * e + 12 * e * f;
	  var C = 12 * a * a - 24 * a * b + 4 * a * c - 4 * a * x + 8 * b * b + 8 * b * x - 4 * c * x + 12 * d * d - 24 * d * e + 4 * d * f - 4 * d * y + 8 * e * e + 8 * e * y - 4 * f * y;
	  var D = -4 * a * a + 4 * a * b + 4 * a * x - 4 * b * x - 4 * d * d + 4 * d * e + 4 * d * y - 4 * e * y;
	
	  var eqresult = solveCubic(A, B, C, D);
	
	  //loop through all possible solitions to find out which point is the nearest
	  var mindist = Infinity;
	  for (var i = 0; i < eqresult.length; i++) {
	    var t = eqresult[i];
	
	    if (t < 0 || t > 1) continue;
	
	    //point at bezier curve
	    var px = a * (1 - t) * (1 - t) + 2 * b * t * (1 - t) + c * t * t;
	    var py = d * (1 - t) * (1 - t) + 2 * e * t * (1 - t) + f * t * t;
	
	    var dist = distance2(x, y, px, py);
	    if (dist < mindist) mindist = dist;
	  }
	
	  return mindist;
	}
	
	/*
	 * @param v - array of with points [x1,y1,x2,y2 .... ]
	 * @return array representing bounding box [x1,y1,x2,y2]
	 */
	function getBBFromPoints(v) {
	  var xmin = Infinity;
	  var xmax = -xmin;
	  var ymin = Infinity;
	  var ymax = -ymin;
	
	  //x of points - even indexes in array 
	  for (var i = 0; i < v.length; i += 2) {
	    var val = v[i];
	    if (val < xmin) xmin = val;
	    if (val > xmax) xmax = val;
	  }
	
	  //y of points - odd indexes in array 
	  for (var _i = 1; _i < v.length; _i += 2) {
	    var _val = v[_i];
	    if (_val < ymin) ymin = _val;
	    if (_val > ymax) ymax = _val;
	  }
	
	  return [xmin, ymin, xmax, ymax];
	}
	
	//distance from point to point
	function distance2(x1, y1, x2, y2) {
	  var dx = x1 - x2;
	  var dy = y1 - y2;
	  return dx * dx + dy * dy;
	}
	
	//distance from point to line
	function pDistance2(x, y, x1, y1, x2, y2) {
	  var A = x - x1;
	  var B = y - y1;
	  var C = x2 - x1;
	  var D = y2 - y1;
	
	  var dot = A * C + B * D;
	  var len_sq = C * C + D * D;
	  var param = -1;
	  if (len_sq != 0) //in case of 0 length line
	    param = dot / len_sq;
	
	  var xx = void 0,
	      yy = void 0;
	
	  if (param < 0) {
	    xx = x1;
	    yy = y1;
	  } else if (param > 1) {
	    xx = x2;
	    yy = y2;
	  } else {
	    xx = x1 + param * C;
	    yy = y1 + param * D;
	  }
	
	  return distance2(x, y, xx, yy);
	}
	
	function lineIntersectsLine(l1p1x, l1p1y, l1p2x, l1p2y, l2p1x, l2p1y, l2p2x, l2p2y) {
	  var q = (l1p1y - l2p1y) * (l2p2x - l2p1x) - (l1p1x - l2p1x) * (l2p2y - l2p1y);
	  var d = (l1p2x - l1p1x) * (l2p2y - l2p1y) - (l1p2y - l1p1y) * (l2p2x - l2p1x);
	
	  if (d == 0) {
	    return false;
	  }
	
	  var r = q / d;
	
	  q = (l1p1y - l2p1y) * (l1p2x - l1p1x) - (l1p1x - l2p1x) * (l1p2y - l1p1y);
	  var s = q / d;
	
	  if (r < 0 || r > 1 || s < 0 || s > 1) {
	    return false;
	  }
	
	  return true;
	}
	
	function pointInRect(px, py, x1, y1, x2, y2) {
	  return px >= x1 - EPS && px <= x2 + EPS && py >= y1 - EPS && py <= y2 + EPS;
	}
	
	function rectIntersectsRect(p1x, p1y, p2x, p2y, r1x, r1y, r2x, r2y) {
	  return p1x <= r2x && p1y <= r2y && p2x >= r1x && p2y >= r1y;
	}
	
	function lineIntersectsRect(p1x, p1y, p2x, p2y, r1x, r1y, r2x, r2y) {
	  if (pointInRect(p1x, p1y, r1x, r1y, r2x, r2y) || pointInRect(p2x, p2y, r1x, r1y, r2x, r2y)) return true;
	
	  return lineIntersectsLine(p1x, p1y, p2x, p2y, r1x, r1y, r2x, r1y) || lineIntersectsLine(p1x, p1y, p2x, p2y, r2x, r1y, r2x, r2y) || lineIntersectsLine(p1x, p1y, p2x, p2y, r2x, r2y, r1x, r2y) || lineIntersectsLine(p1x, p1y, p2x, p2y, r1x, r2y, r1x, r1y);
	}
	
	function eq(a, b) {
	  return a >= b - EPS && a <= b + EPS;
	}
	
	function neq(a, b) {
	  return !eq(a, b);
	}
	
	function checkBezierTkoef(a, d, b, e, c, f, t, q, s, r, v) {
	  if (t < 0 || t > 1) return false;
	
	  if (neq(v - s, 0)) {
	    var x = (d * (1 - t) * (1 - t) + 2 * e * t * (1 - t) + f * t * t) / (v - s);
	    if (x < 0 || x > 1) return false;
	  }
	
	  return true;
	}
	
	function bezierIntersectsLine(a, d, b, e, c, f, q, s, r, v) {
	  //based on wolfram alpha: >> solve ((d*(1-x)*(1-x)+2*e*x*(1-x)+f*x*x) = s + ((-a*(x-1)*(x-1) + x*(2*b*(x-1)-c*x)+q)/(q-r))*(v - s)) for x <<
	
	  var t = void 0;
	
	  var tden = -a * s + a * v + 2 * b * s - 2 * b * v - c * s + c * v + d * q - d * r - 2 * e * q + 2 * e * r + f * q - f * r;
	  if (neq(tden, 0)) {
	    if (neq(q - r, 0)) {
	      var sq1 = 2 * a * s - 2 * a * v - 2 * b * s + 2 * b * v - 2 * d * r + 2 * e * q - 2 * e * r;
	      var sq = sq1 * sq1 - 4 * (-a * s + a * v + d * q - d * r - q * v + r * s) * (-a * s + a * v + 2 * b * s - 2 * b * v - c * s + c * v + d * q - d * r - 2 * e * q + 2 * e * r + f * q - f * r);
	      if (sq >= 0) {
	        var t1 = a * s - a * v - b * s + b * v - d * q + d * r + e * q - e * r;
	
	        t = (t1 - 0.5 * Math.sqrt(sq)) / tden;
	        if (checkBezierTkoef(a, d, b, e, c, f, q, s, r, v, t)) return true;
	
	        t = (t1 + 0.5 * Math.sqrt(sq)) / tden;
	        if (checkBezierTkoef(a, d, b, e, c, f, q, s, r, v, t)) return true;
	      }
	    }
	  }
	
	  tden = -b * s + b * v + c * s - c * v + e * q - e * r - f * q + f * r;
	  if (eq(d, 2 * e - f) && eq(a, 2 * b - c) && neq(tden, 0) && neq(q * s - q * v - r * s + r * v, 0)) {
	    t = -2 * b * s + 2 * b * v + c * s - c * v + 2 * e * q - 2 * e * r - f * q + f * r - q * v + r * s;
	    t = t / (2 * tden);
	    if (checkBezierTkoef(a, d, b, e, c, f, q, s, r, v, t)) return true;
	  }
	
	  if (eq(s, v) && eq(d, 2 * e - f) && neq(e - f, 0) && neq(q - r, 0)) {
	    t = (2 * e - f - v) / (2 * (e - f));
	    if (checkBezierTkoef(a, d, b, e, c, f, q, s, r, v, t)) return true;
	  }
	
	  var aeq = (2 * b * s - 2 * b * v - c * s + c * v + d * q - d * r - 2 * e * q + 2 * e * r + f * q - f * r) / (s - v);
	  var val = b * d * s - b * d * v - 2 * b * e * s + 2 * b * e * v + b * f * s - b * f * v - c * d * s + c * d * v + 2 * c * e * s - 2 * c * e * v - c * f * s + c * f * v - d * e * q + d * e * r + d * f * q - d * f * r + 2 * e * e * q - 2 * e * e * r - 3 * e * f * q + 3 * e * f * r + f * f * q - f * f * r;
	  if (eq(a, aeq) && neq(val, 0) && neq(q - r, 0)) {
	    t = (2 * b * s - 2 * b * v - c * s + c * v - 2 * e * q + 2 * e * r + f * q - f * r + q * v - r * s) / (2 * (b * s - b * v - c * s + c * v - e * q + e * r + f * q - f * r));
	    if (checkBezierTkoef(a, d, b, e, c, f, q, s, r, v, t)) return true;
	  }
	
	  return false;
	}
	
	function bezierIntersectsRect(a, d, b, e, c, f, r1x, r1y, r2x, r2y) {
	  if (pointInRect(a, d, r1x, r1y, r2x, r2y) || pointInRect(c, f, r1x, r1y, r2x, r2y)) return true;
	
	  var centerx = (r1x + r2x) / 2;
	  var centery = (r1y + r2y) / 2;
	
	  var diffx = r1x - r2x;
	  var diffy = r1y - r2y;
	
	  //performance optimalization based on distance
	  var diff2xy = diffx * diffx + diffy * diffy;
	  var dist2 = distance2ToBezier(centerx, centery, a, d, b, e, c, f);
	  if (dist2 * 4 > diff2xy) return false;
	  if (dist2 * 4 <= Math.min(diffx * diffx, diffy * diffy)) return true;
	
	  return bezierIntersectsLine(a, d, b, e, c, f, r1y, r2x, r1y, r1y) || bezierIntersectsLine(a, d, b, e, c, f, r2x, r1y, r2x, r2y) || bezierIntersectsLine(a, d, b, e, c, f, r2x, r2y, r1x, r2y) || bezierIntersectsLine(a, d, b, e, c, f, r1x, r2y, r1x, r1y);
	}
	
	exports.EPS = EPS;
	exports.bezierIntersectsRect = bezierIntersectsRect;
	exports.bezierIntersectsLine = bezierIntersectsLine;
	exports.lineIntersectsRect = lineIntersectsRect;
	exports.rectIntersectsRect = rectIntersectsRect;
	exports.pointInRect = pointInRect;
	exports.distance2ToBezier = distance2ToBezier;
	exports.distance2 = distance2;
	exports.pDistance2 = pDistance2;
	exports.getBBFromPoints = getBBFromPoints;
	exports.eq = eq;
	exports.neq = neq;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _gl = __webpack_require__(4);
	
	var _gl2 = _interopRequireDefault(_gl);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: David Tichy, AleÅ¡ Saska
	 */
	
	var _class = function () {
	    function _class(events, onLoad) {
	        _classCallCheck(this, _class);
	
	        this._load = [events.debounce(onLoad, 5)];
	        this._textures = {};
	        this._pending = {};
	        this._n = 0;
	    }
	
	    _createClass(_class, [{
	        key: 'get',
	        value: function get(gl, img, action, options) {
	            var _this = this;
	
	            var p = this._pending[img];
	            var t = this._textures[img];
	
	            if (p) {
	                p.push(action);
	            } else if (t) {
	                action && action();
	            } else {
	                p = this._pending[img] = [action];
	                this._n++;
	                this._textures[img] = t = _gl2.default.createTexture(gl, img, function () {
	                    p.forEach(function (a) {
	                        return a && a();
	                    });
	                    delete _this._pending[img];
	                    --_this._n || _this._load.forEach(function (l) {
	                        return l();
	                    });
	                }, options);
	            }
	            return t;
	        }
	    }, {
	        key: 'onLoad',
	        value: function onLoad(action) {
	            if (this.allLoaded()) action();else this._load.push(action);
	        }
	    }, {
	        key: 'allLoaded',
	        value: function allLoaded() {
	            return _utils2.default.emptyObject(this._pending);
	        }
	    }]);

	    return _class;
	}();

	exports.default = _class;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _gl = __webpack_require__(4);
	
	var _gl2 = _interopRequireDefault(_gl);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: David Tichy, AleÅ¡ Saska
	 */
	
	var _class = function () {
	  function _class(events, onLoad) {
	    _classCallCheck(this, _class);
	
	    this._load = [events.debounce(onLoad || function () {}, 5)];
	    this._files = {};
	    this._pending = {};
	    this._n = 0;
	  }
	
	  _createClass(_class, [{
	    key: '_transformFile',
	    value: function _transformFile(data, dataType) {
	      if (dataType === 'json') return JSON.parse(data);
	      return data;
	    }
	  }, {
	    key: 'get',
	    value: function get(url) {
	      return this._files[url];
	    }
	
	    /*
	     * @param type {
	     *   url: 'url of file',
	     *   success: callback
	     *   dataType "text" || "json"
	     * }
	     */
	
	  }, {
	    key: 'load',
	    value: function load(url, action, dataType) {
	      var _this = this;
	
	      var p = this._pending[url];
	      var f = this._files[url];
	
	      if (p) {
	        p.push(action);
	      } else if (f) {
	        action && action();
	      } else {
	        p = this._pending[url] = [action];
	        this._n++;
	
	        _utils2.default.ajax(url, function (data) {
	          _this._files[url] = _this._transformFile(data, dataType);
	          p.forEach(function (a) {
	            return a && a(_this._files[url]);
	          });
	          delete _this._pending[url];
	          --_this._n || _this._load.forEach(function (l) {
	            return l();
	          });
	        }, dataType == 'arraybuffer' ? dataType : undefined);
	      }
	      return f;
	    }
	  }, {
	    key: 'onLoad',
	    value: function onLoad(action) {
	      if (this.allLoaded()) action();else this._load.push(action);
	    }
	  }, {
	    key: 'allLoaded',
	    value: function allLoaded() {
	      return _utils2.default.emptyObject(this._pending);
	    }
	  }]);

	  return _class;
	}();

	exports.default = _class;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Copyright (c) 2016, Helikar Lab.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  All rights reserved.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  This source code is licensed under the GPLv3 License.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Authors: David Tichy, AleÅ¡ Saska
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */
	
	var _default = __webpack_require__(35);
	
	var _default2 = _interopRequireDefault(_default);
	
	var _sdf = __webpack_require__(36);
	
	var _sdf2 = _interopRequireDefault(_sdf);
	
	var _utils = __webpack_require__(7);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _class = function () {
	  function _class(gl, files, textures) {
	    _classCallCheck(this, _class);
	
	    this._gl = gl;
	
	    this._modules = {
	      'default': new _default2.default(gl, files, textures),
	      'sdf': new _sdf2.default(gl, files, textures)
	    };
	  }
	
	  _createClass(_class, [{
	    key: 'clear',
	    value: function clear() {
	      for (var k in this._modules) {
	        this._modules[k].clear();
	      }
	    }
	  }, {
	    key: 'isSDF',
	    value: function isSDF(font) {
	      if (_utils2.default.isObject(font)) {
	        if (font.type === 'sdf' && font.pbf) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'getEngine',
	    value: function getEngine(font) {
	      if (this.isSDF(font)) {
	        return this._modules.sdf;
	      }
	      return this._modules.default;
	    }
	  }, {
	    key: 'bind',
	    value: function bind() {
	      for (var k in this._modules) {
	        this._modules[k].bind();
	      }
	    }
	  }, {
	    key: 'remove',
	    value: function remove() {
	      for (var k in this._modules) {
	        this._modules[k].remove && this._modules[k].remove();
	      }
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: David Tichy, AleÅ¡ Saska
	 */
	
	var _class = function () {
	  function _class(gl, files, textures) {
	    _classCallCheck(this, _class);
	
	    this._gl = gl;
	    this._size = 1024;
	
	    this._canvas = document.createElement("canvas");
	    this._canvas.width = this._canvas.height = this._size;
	    this._canvas.style.width = this._canvas.style.height = this._size + 'px';
	    this._canvas.style.display = "none";
	    this._el = document.body.appendChild(this._canvas);
	
	    this._context = this._canvas.getContext('2d');
	    this._context.fillStyle = "white";
	    this._context.textAlign = "left";
	    this._context.textBaseline = "top";
	
	    this._rendered = this._texts = this._x = this._y = this._height = undefined;
	
	    this.texture = this._gl.createTexture();
	  }
	
	  _createClass(_class, [{
	    key: "clear",
	    value: function clear() {
	      this._rendered = {};
	      this._context.clearRect(0, 0, this._size, this._size);
	      this._height = this._x = this._y = 0;
	    }
	  }, {
	    key: "setFont",
	    value: function setFont(font) {
	      var fontstr = font ? font.size + "px " + font.type : undefined;
	
	      this._rendered[fontstr] = this._texts = this._rendered[fontstr] || {};
	      this._context.font = fontstr;
	      this._x = 0;
	      this._y += this._height;
	      this._height = font ? font.size + 1 : NaN;
	    }
	  }, {
	    key: "getTexture",
	    value: function getTexture(style, onLoad) {
	      onLoad();
	      return this.texture;
	    }
	  }, {
	    key: "_getText",
	    value: function _getText(text) {
	      var result = this._texts[text];
	      if (!result) {
	        var width = this._context.measureText(text).width;
	        if (this._x + width > this._size) {
	          this._x = 0;
	          this._y += this._height;
	        }
	        this._context.fillText(text, this._x, this._y);
	        this._texts[text] = result = {
	          width: width,
	          height: this._height,
	          left: this._x / this._size,
	          right: (this._x + width) / this._size,
	          top: this._y / this._size,
	          bottom: (this._y + this._height) / this._size
	        };
	        this._x += width;
	      }
	      return result;
	    }
	  }, {
	    key: "get",
	    value: function get(text, x, y) {
	      var c = this._getText(text);
	
	      var dx = x <= 0.5 ? 0 : -c.width;
	      var dy = y <= 0.5 ? 0 : -c.height;
	
	      return [{
	        width: c.width,
	        height: c.height,
	        left: c.left,
	        right: c.right,
	        top: c.top,
	        bottom: c.bottom,
	        dx: dx,
	        dy: dy
	      }];
	    }
	  }, {
	    key: "steps",
	    value: function steps(text) {
	      return 1;
	    }
	  }, {
	    key: "bind",
	    value: function bind() {
	      this._gl.bindTexture(this._gl.TEXTURE_2D, this.texture);
	      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, false);
	      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
	      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
	      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, this._canvas);
	      this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      this._context && this._el.parentNode.removeChild(this._el);
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this._height - 1;
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _pbf = __webpack_require__(37);
	
	var _pbf2 = _interopRequireDefault(_pbf);
	
	var _atlas = __webpack_require__(39);
	
	var _atlas2 = _interopRequireDefault(_atlas);
	
	var _glyphs = __webpack_require__(41);
	
	var _glyphs2 = _interopRequireDefault(_glyphs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: AleÅ¡ Saska
	 */
	
	// A simplified representation of the glyph containing only the properties needed for shaping.
	var SimpleGlyph = function SimpleGlyph(glyph, rect, buffer) {
	  _classCallCheck(this, SimpleGlyph);
	
	  var padding = 1;
	  this.advance = glyph.advance;
	  this.left = glyph.left - buffer - padding;
	  this.top = glyph.top + buffer + padding;
	  this.rect = rect;
	};
	
	var SIZE_GROWTH_RATE = 4;
	var DEFAULT_SIZE = 512;
	// must be "DEFAULT_SIZE * SIZE_GROWTH_RATE ^ n" for some integer n
	var MAX_SIZE = 2048;
	
	var _class = function () {
	  function _class(gl, files, textures) {
	    var _this = this;
	
	    _classCallCheck(this, _class);
	
	    this.width = DEFAULT_SIZE;
	    this.height = DEFAULT_SIZE;
	
	    this.clear();
	
	    this._files = files;
	
	    this._rendered = {};
	    this._texts;
	    this._gl = gl;
	
	    this.atlas = new _atlas2.default(this._gl, function () {
	      _this._cachedGlyphs = {};
	    });
	    this._textures = {};
	    this._glyphs = {};
	    this._rects = {};
	    this._cachedGlyphs = {};
	  }
	
	  _createClass(_class, [{
	    key: 'clear',
	    value: function clear() {}
	  }, {
	    key: 'setFont',
	    value: function setFont(style) {
	      this.curFont = style.pbf;
	    }
	  }, {
	    key: 'getTexture',
	    value: function getTexture(style, onLoad) {
	      var _this2 = this,
	          _arguments = arguments;
	
	      var myOnLoad = function (onL) {
	        return function () {
	          var data = _this2._files.load(style.pbf, onLoad, 'arraybuffer');
	
	          //init first most-used ASCII chars
	          for (var i = 0; i < 128; i++) {
	            _this2._getChar(String.fromCharCode(i));
	          }
	
	          onL && onL.apply(_this2, _arguments);
	        };
	      }(onLoad);
	
	      var font = style.pbf;
	      if (!this._glyphs[font]) {
	        var data = this._files.load(style.pbf, myOnLoad, 'arraybuffer');
	        this._curglyphs = this._glyphs[font] = data && new _glyphs2.default(new _pbf2.default(data));
	      } else {
	        myOnLoad();
	      }
	
	      return this.atlas.texture;
	    }
	  }, {
	    key: '_getChar',
	    value: function _getChar(text, markDirty) {
	      var font = this.curFont;
	      var glyphID = text.charCodeAt(0);
	
	      var buffer = 3;
	      var range = Math.floor(glyphID / 256);
	
	      if (this._glyphs[font]) {
	        var g = this._glyphs[font];
	        if (g) {
	          var stack = g.stacks[range];
	          if (stack) {
	            var glyph = stack.glyphs[glyphID];
	            if (!this._rects[font]) this._rects[font] = {};
	
	            this._rects[font][text] = this.atlas.addGlyph(glyphID, this.curFont, glyph, buffer, markDirty);
	          }
	        }
	      }
	
	      var r = void 0,
	          rect = void 0;
	      if ((r = this._rects[font]) && (rect = r[text])) {
	        var cache = this._cachedGlyphs[font] || (this._cachedGlyphs[font] = {});
	        return cache[glyphID] || (cache[glyphID] = new SimpleGlyph(this._glyphs[font].stacks[range].glyphs[glyphID], rect, buffer));
	      }
	
	      return {};
	    }
	  }, {
	    key: 'get',
	    value: function get(text, x, y, markDirty) {
	      var width = 0;
	      var height = 0;
	
	      var horiBearingX = 3;
	      var horiBearingY = 2;
	
	      for (var i = 0; i < text.length; i++) {
	        var char = this._getChar(text[i], markDirty);
	        var rect = char.rect || {};
	        height = Math.max(height, rect.h - char.top);
	        width += char.advance + horiBearingX;
	        //      width               += rect.w + horiBearingX;
	      }
	
	      var dx = x <= 0.5 ? 0 : -width;
	      var dy = y <= 0.5 ? 0 : -height;
	
	      var ret = [];
	      for (var _i = 0; _i < text.length; _i++) {
	        var _char = this._getChar(text[_i], markDirty);
	        var _rect = _char.rect || {};
	
	        var horiAdvance = void 0;
	
	        dx += horiBearingX;
	
	        ret.push({
	          width: _rect.w,
	          height: _rect.h,
	          left: _rect.x / this.atlas.width,
	          right: (_rect.x + _rect.w) / this.atlas.width,
	          bottom: (_rect.y + _rect.h) / this.atlas.height,
	          top: _rect.y / this.atlas.height,
	          dx: dx,
	          dy: dy + _char.top + (height - _rect.h)
	        });
	
	        dx += _char.advance;
	        //      dx += rect.w;
	      }
	      return ret;
	    }
	  }, {
	    key: 'steps',
	    value: function steps(text) {
	      return text.length;
	    }
	  }, {
	    key: 'bind',
	    value: function bind() {
	      this.atlas.updateTexture(this._gl);
	    }
	  }, {
	    key: 'isSDF',
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: 'fontSize',
	    get: function get() {
	      return 24;
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = Pbf;
	
	var ieee754 = __webpack_require__(38);
	
	function Pbf(buf) {
	    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
	    this.pos = 0;
	    this.type = 0;
	    this.length = this.buf.length;
	}
	
	Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
	Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
	Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
	Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32
	
	var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
	    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
	
	Pbf.prototype = {
	
	    destroy: function() {
	        this.buf = null;
	    },
	
	    // === READING =================================================================
	
	    readFields: function(readField, result, end) {
	        end = end || this.length;
	
	        while (this.pos < end) {
	            var val = this.readVarint(),
	                tag = val >> 3,
	                startPos = this.pos;
	
	            this.type = val & 0x7;
	            readField(tag, result, this);
	
	            if (this.pos === startPos) this.skip(val);
	        }
	        return result;
	    },
	
	    readMessage: function(readField, result) {
	        return this.readFields(readField, result, this.readVarint() + this.pos);
	    },
	
	    readFixed32: function() {
	        var val = readUInt32(this.buf, this.pos);
	        this.pos += 4;
	        return val;
	    },
	
	    readSFixed32: function() {
	        var val = readInt32(this.buf, this.pos);
	        this.pos += 4;
	        return val;
	    },
	
	    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
	
	    readFixed64: function() {
	        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
	        this.pos += 8;
	        return val;
	    },
	
	    readSFixed64: function() {
	        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
	        this.pos += 8;
	        return val;
	    },
	
	    readFloat: function() {
	        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
	        this.pos += 4;
	        return val;
	    },
	
	    readDouble: function() {
	        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
	        this.pos += 8;
	        return val;
	    },
	
	    readVarint: function(isSigned) {
	        var buf = this.buf,
	            val, b;
	
	        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
	        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
	        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
	        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
	        b = buf[this.pos];   val |= (b & 0x0f) << 28;
	
	        return readVarintRemainder(val, isSigned, this);
	    },
	
	    readVarint64: function() { // for compatibility with v2.0.1
	        return this.readVarint(true);
	    },
	
	    readSVarint: function() {
	        var num = this.readVarint();
	        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
	    },
	
	    readBoolean: function() {
	        return Boolean(this.readVarint());
	    },
	
	    readString: function() {
	        var end = this.readVarint() + this.pos,
	            str = readUtf8(this.buf, this.pos, end);
	        this.pos = end;
	        return str;
	    },
	
	    readBytes: function() {
	        var end = this.readVarint() + this.pos,
	            buffer = this.buf.subarray(this.pos, end);
	        this.pos = end;
	        return buffer;
	    },
	
	    // verbose for performance reasons; doesn't affect gzipped size
	
	    readPackedVarint: function(arr, isSigned) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readVarint(isSigned));
	        return arr;
	    },
	    readPackedSVarint: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readSVarint());
	        return arr;
	    },
	    readPackedBoolean: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readBoolean());
	        return arr;
	    },
	    readPackedFloat: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readFloat());
	        return arr;
	    },
	    readPackedDouble: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readDouble());
	        return arr;
	    },
	    readPackedFixed32: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readFixed32());
	        return arr;
	    },
	    readPackedSFixed32: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readSFixed32());
	        return arr;
	    },
	    readPackedFixed64: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readFixed64());
	        return arr;
	    },
	    readPackedSFixed64: function(arr) {
	        var end = readPackedEnd(this);
	        arr = arr || [];
	        while (this.pos < end) arr.push(this.readSFixed64());
	        return arr;
	    },
	
	    skip: function(val) {
	        var type = val & 0x7;
	        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
	        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
	        else if (type === Pbf.Fixed32) this.pos += 4;
	        else if (type === Pbf.Fixed64) this.pos += 8;
	        else throw new Error('Unimplemented type: ' + type);
	    },
	
	    // === WRITING =================================================================
	
	    writeTag: function(tag, type) {
	        this.writeVarint((tag << 3) | type);
	    },
	
	    realloc: function(min) {
	        var length = this.length || 16;
	
	        while (length < this.pos + min) length *= 2;
	
	        if (length !== this.length) {
	            var buf = new Uint8Array(length);
	            buf.set(this.buf);
	            this.buf = buf;
	            this.length = length;
	        }
	    },
	
	    finish: function() {
	        this.length = this.pos;
	        this.pos = 0;
	        return this.buf.subarray(0, this.length);
	    },
	
	    writeFixed32: function(val) {
	        this.realloc(4);
	        writeInt32(this.buf, val, this.pos);
	        this.pos += 4;
	    },
	
	    writeSFixed32: function(val) {
	        this.realloc(4);
	        writeInt32(this.buf, val, this.pos);
	        this.pos += 4;
	    },
	
	    writeFixed64: function(val) {
	        this.realloc(8);
	        writeInt32(this.buf, val & -1, this.pos);
	        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
	        this.pos += 8;
	    },
	
	    writeSFixed64: function(val) {
	        this.realloc(8);
	        writeInt32(this.buf, val & -1, this.pos);
	        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
	        this.pos += 8;
	    },
	
	    writeVarint: function(val) {
	        val = +val || 0;
	
	        if (val > 0xfffffff || val < 0) {
	            writeBigVarint(val, this);
	            return;
	        }
	
	        this.realloc(4);
	
	        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
	        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
	        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
	        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
	    },
	
	    writeSVarint: function(val) {
	        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
	    },
	
	    writeBoolean: function(val) {
	        this.writeVarint(Boolean(val));
	    },
	
	    writeString: function(str) {
	        str = String(str);
	        this.realloc(str.length * 4);
	
	        this.pos++; // reserve 1 byte for short string length
	
	        var startPos = this.pos;
	        // write the string directly to the buffer and see how much was written
	        this.pos = writeUtf8(this.buf, str, this.pos);
	        var len = this.pos - startPos;
	
	        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);
	
	        // finally, write the message length in the reserved place and restore the position
	        this.pos = startPos - 1;
	        this.writeVarint(len);
	        this.pos += len;
	    },
	
	    writeFloat: function(val) {
	        this.realloc(4);
	        ieee754.write(this.buf, val, this.pos, true, 23, 4);
	        this.pos += 4;
	    },
	
	    writeDouble: function(val) {
	        this.realloc(8);
	        ieee754.write(this.buf, val, this.pos, true, 52, 8);
	        this.pos += 8;
	    },
	
	    writeBytes: function(buffer) {
	        var len = buffer.length;
	        this.writeVarint(len);
	        this.realloc(len);
	        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
	    },
	
	    writeRawMessage: function(fn, obj) {
	        this.pos++; // reserve 1 byte for short message length
	
	        // write the message directly to the buffer and see how much was written
	        var startPos = this.pos;
	        fn(obj, this);
	        var len = this.pos - startPos;
	
	        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);
	
	        // finally, write the message length in the reserved place and restore the position
	        this.pos = startPos - 1;
	        this.writeVarint(len);
	        this.pos += len;
	    },
	
	    writeMessage: function(tag, fn, obj) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeRawMessage(fn, obj);
	    },
	
	    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
	    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
	    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
	    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
	    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
	    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
	    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
	    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
	    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },
	
	    writeBytesField: function(tag, buffer) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeBytes(buffer);
	    },
	    writeFixed32Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeFixed32(val);
	    },
	    writeSFixed32Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeSFixed32(val);
	    },
	    writeFixed64Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeFixed64(val);
	    },
	    writeSFixed64Field: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeSFixed64(val);
	    },
	    writeVarintField: function(tag, val) {
	        this.writeTag(tag, Pbf.Varint);
	        this.writeVarint(val);
	    },
	    writeSVarintField: function(tag, val) {
	        this.writeTag(tag, Pbf.Varint);
	        this.writeSVarint(val);
	    },
	    writeStringField: function(tag, str) {
	        this.writeTag(tag, Pbf.Bytes);
	        this.writeString(str);
	    },
	    writeFloatField: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed32);
	        this.writeFloat(val);
	    },
	    writeDoubleField: function(tag, val) {
	        this.writeTag(tag, Pbf.Fixed64);
	        this.writeDouble(val);
	    },
	    writeBooleanField: function(tag, val) {
	        this.writeVarintField(tag, Boolean(val));
	    }
	};
	
	function readVarintRemainder(l, s, p) {
	    var buf = p.buf,
	        h, b;
	
	    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
	    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
	    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
	    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
	    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
	    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);
	
	    throw new Error('Expected varint not more than 10 bytes');
	}
	
	function readPackedEnd(pbf) {
	    return pbf.type === Pbf.Bytes ?
	        pbf.readVarint() + pbf.pos : pbf.pos + 1;
	}
	
	function toNum(low, high, isSigned) {
	    if (isSigned) {
	        return high * 0x100000000 + (low >>> 0);
	    }
	
	    return ((high >>> 0) * 0x100000000) + (low >>> 0);
	}
	
	function writeBigVarint(val, pbf) {
	    var low, high;
	
	    if (val >= 0) {
	        low  = (val % 0x100000000) | 0;
	        high = (val / 0x100000000) | 0;
	    } else {
	        low  = ~(-val % 0x100000000);
	        high = ~(-val / 0x100000000);
	
	        if (low ^ 0xffffffff) {
	            low = (low + 1) | 0;
	        } else {
	            low = 0;
	            high = (high + 1) | 0;
	        }
	    }
	
	    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
	        throw new Error('Given varint doesn\'t fit into 10 bytes');
	    }
	
	    pbf.realloc(10);
	
	    writeBigVarintLow(low, high, pbf);
	    writeBigVarintHigh(high, pbf);
	}
	
	function writeBigVarintLow(low, high, pbf) {
	    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
	    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
	    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
	    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
	    pbf.buf[pbf.pos]   = low & 0x7f;
	}
	
	function writeBigVarintHigh(high, pbf) {
	    var lsb = (high & 0x07) << 4;
	
	    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
	    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
	    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
	    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
	    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
	    pbf.buf[pbf.pos++]  = high & 0x7f;
	}
	
	function makeRoomForExtraLength(startPos, len, pbf) {
	    var extraLen =
	        len <= 0x3fff ? 1 :
	        len <= 0x1fffff ? 2 :
	        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));
	
	    // if 1 byte isn't enough for encoding message length, shift the data to the right
	    pbf.realloc(extraLen);
	    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
	}
	
	function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
	function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
	function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
	function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
	function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
	function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
	function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
	function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
	function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }
	
	// Buffer code below from https://github.com/feross/buffer, MIT-licensed
	
	function readUInt32(buf, pos) {
	    return ((buf[pos]) |
	        (buf[pos + 1] << 8) |
	        (buf[pos + 2] << 16)) +
	        (buf[pos + 3] * 0x1000000);
	}
	
	function writeInt32(buf, val, pos) {
	    buf[pos] = val;
	    buf[pos + 1] = (val >>> 8);
	    buf[pos + 2] = (val >>> 16);
	    buf[pos + 3] = (val >>> 24);
	}
	
	function readInt32(buf, pos) {
	    return ((buf[pos]) |
	        (buf[pos + 1] << 8) |
	        (buf[pos + 2] << 16)) +
	        (buf[pos + 3] << 24);
	}
	
	function readUtf8(buf, pos, end) {
	    var str = '';
	    var i = pos;
	
	    while (i < end) {
	        var b0 = buf[i];
	        var c = null; // codepoint
	        var bytesPerSequence =
	            b0 > 0xEF ? 4 :
	            b0 > 0xDF ? 3 :
	            b0 > 0xBF ? 2 : 1;
	
	        if (i + bytesPerSequence > end) break;
	
	        var b1, b2, b3;
	
	        if (bytesPerSequence === 1) {
	            if (b0 < 0x80) {
	                c = b0;
	            }
	        } else if (bytesPerSequence === 2) {
	            b1 = buf[i + 1];
	            if ((b1 & 0xC0) === 0x80) {
	                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
	                if (c <= 0x7F) {
	                    c = null;
	                }
	            }
	        } else if (bytesPerSequence === 3) {
	            b1 = buf[i + 1];
	            b2 = buf[i + 2];
	            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
	                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
	                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
	                    c = null;
	                }
	            }
	        } else if (bytesPerSequence === 4) {
	            b1 = buf[i + 1];
	            b2 = buf[i + 2];
	            b3 = buf[i + 3];
	            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
	                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
	                if (c <= 0xFFFF || c >= 0x110000) {
	                    c = null;
	                }
	            }
	        }
	
	        if (c === null) {
	            c = 0xFFFD;
	            bytesPerSequence = 1;
	
	        } else if (c > 0xFFFF) {
	            c -= 0x10000;
	            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
	            c = 0xDC00 | c & 0x3FF;
	        }
	
	        str += String.fromCharCode(c);
	        i += bytesPerSequence;
	    }
	
	    return str;
	}
	
	function writeUtf8(buf, str, pos) {
	    for (var i = 0, c, lead; i < str.length; i++) {
	        c = str.charCodeAt(i); // code point
	
	        if (c > 0xD7FF && c < 0xE000) {
	            if (lead) {
	                if (c < 0xDC00) {
	                    buf[pos++] = 0xEF;
	                    buf[pos++] = 0xBF;
	                    buf[pos++] = 0xBD;
	                    lead = c;
	                    continue;
	                } else {
	                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
	                    lead = null;
	                }
	            } else {
	                if (c > 0xDBFF || (i + 1 === str.length)) {
	                    buf[pos++] = 0xEF;
	                    buf[pos++] = 0xBF;
	                    buf[pos++] = 0xBD;
	                } else {
	                    lead = c;
	                }
	                continue;
	            }
	        } else if (lead) {
	            buf[pos++] = 0xEF;
	            buf[pos++] = 0xBF;
	            buf[pos++] = 0xBD;
	            lead = null;
	        }
	
	        if (c < 0x80) {
	            buf[pos++] = c;
	        } else {
	            if (c < 0x800) {
	                buf[pos++] = c >> 0x6 | 0xC0;
	            } else {
	                if (c < 0x10000) {
	                    buf[pos++] = c >> 0xC | 0xE0;
	                } else {
	                    buf[pos++] = c >> 0x12 | 0xF0;
	                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
	                }
	                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
	            }
	            buf[pos++] = c & 0x3F | 0x80;
	        }
	    }
	    return pos;
	}


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _shelfPack = __webpack_require__(40);
	
	var _shelfPack2 = _interopRequireDefault(_shelfPack);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	//import util from '../util/util';
	
	var SIZE_GROWTH_RATE = 4;
	var DEFAULT_SIZE = 1024;
	// must be "DEFAULT_SIZE * SIZE_GROWTH_RATE ^ n" for some integer n
	var MAX_SIZE = 2048;
	
	var GlyphAtlas = function () {
	    function GlyphAtlas(gl, resetCache) {
	        _classCallCheck(this, GlyphAtlas);
	
	        this.width = DEFAULT_SIZE;
	        this.height = DEFAULT_SIZE;
	
	        this._resetCache = resetCache;
	        this.bin = new _shelfPack2.default(this.width, this.height);
	        this.index = {};
	        this.ids = {};
	
	        this.gl = gl;
	        this.data = new Uint8Array(this.width * this.height);
	    }
	
	    _createClass(GlyphAtlas, [{
	        key: '_createTexture',
	        value: function _createTexture() {
	            this.dirty = false;
	            var gl = this.gl;
	            var texture = gl.createTexture();
	            gl.bindTexture(gl.TEXTURE_2D, texture);
	            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
	            gl.bindTexture(gl.TEXTURE_2D, null);
	            return texture;
	        }
	    }, {
	        key: 'getGlyphs',
	        value: function getGlyphs() {
	            var glyphs = {};
	            var split = void 0,
	                name = void 0,
	                id = void 0;
	
	            for (var key in this.ids) {
	                split = key.split('#');
	                name = split[0];
	                id = split[1];
	
	                if (!glyphs[name]) glyphs[name] = [];
	                glyphs[name].push(id);
	            }
	
	            return glyphs;
	        }
	    }, {
	        key: 'getRects',
	        value: function getRects() {
	            var rects = {};
	            var split = void 0,
	                name = void 0,
	                id = void 0;
	
	            for (var key in this.ids) {
	                split = key.split('#');
	                name = split[0];
	                id = split[1];
	
	                if (!rects[name]) rects[name] = {};
	                rects[name][id] = this.index[key];
	            }
	
	            return rects;
	        }
	    }, {
	        key: 'addGlyph',
	        value: function addGlyph(id, name, glyph, buffer, markDirty) {
	            if (!glyph) return null;
	
	            var key = name + '#' + glyph.id;
	
	            // The glyph is already in this texture.
	            if (this.index[key]) {
	                if (this.ids[key].indexOf(id) < 0) {
	                    this.ids[key].push(id);
	                }
	                return this.index[key];
	            }
	
	            var bufferedWidth = glyph.width + buffer * 2;
	            var bufferedHeight = glyph.height + buffer * 2;
	
	            // Add a 1px border around every image.
	            var padding = 1;
	            var packWidth = bufferedWidth + 2 * padding;
	            var packHeight = bufferedHeight + 2 * padding;
	
	            // Increase to next number divisible by 4, but at least 1.
	            // This is so we can scale down the texture coordinates and pack them
	            // into fewer bytes.
	            packWidth += 4 - packWidth % 4;
	            packHeight += 4 - packHeight % 4;
	
	            var rect = this.bin.packOne(packWidth, packHeight);
	            if (!rect) {
	                this.resize();
	                rect = this.bin.packOne(packWidth, packHeight);
	                markDirty && markDirty();
	            }
	            if (!rect) {
	                return null;
	            }
	
	            this.index[key] = rect;
	            this.ids[key] = [id];
	
	            if (glyph.bitmap) {
	                var target = this.data;
	                var source = glyph.bitmap;
	                for (var y = 0; y < bufferedHeight; y++) {
	                    var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
	                    var y2 = bufferedWidth * y;
	                    for (var x = 0; x < bufferedWidth; x++) {
	                        target[y1 + x] = source[y2 + x];
	                    }
	                }
	            }
	
	            this.dirty = true;
	
	            return rect;
	        }
	    }, {
	        key: 'resize',
	        value: function resize() {
	            var prevWidth = this.width;
	            var prevHeight = this.height;
	
	            if (prevWidth >= MAX_SIZE || prevHeight >= MAX_SIZE) return;
	
	            if (this._texture) {
	                if (this.gl) {
	                    this.gl.deleteTexture(this._texture);
	                }
	                this._texture = null;
	            }
	
	            this.width *= SIZE_GROWTH_RATE;
	            this.height *= SIZE_GROWTH_RATE;
	            this.bin.resize(this.width, this.height);
	
	            var buf = new ArrayBuffer(this.width * this.height);
	            for (var i = 0; i < prevHeight; i++) {
	                var src = new Uint8Array(this.data.buffer, prevHeight * i, prevWidth);
	                var dst = new Uint8Array(buf, prevHeight * i * SIZE_GROWTH_RATE, prevWidth);
	                dst.set(src);
	            }
	            this.data = new Uint8Array(buf);
	            this._resetCache();
	        }
	    }, {
	        key: 'bind',
	        value: function bind(gl) {}
	    }, {
	        key: 'updateTexture',
	        value: function updateTexture() {
	            var gl = this.gl;
	            if (!this._texture) {
	                this._texture = this._createTexture();
	            }
	            if (this.dirty) {
	                gl.bindTexture(gl.TEXTURE_2D, this._texture);
	                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
	                gl.bindTexture(gl.TEXTURE_2D, null);
	                this.dirty = false;
	            }
	            return this._texture;
	        }
	    }, {
	        key: 'texture',
	        get: function get() {
	            return this._texture;
	        }
	    }]);
	
	    return GlyphAtlas;
	}();
	
	exports.default = GlyphAtlas;
	;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
	     true ? module.exports = factory() :
	    undefined;
	}(this, function () {
	
	/**
	 * Create a new ShelfPack bin allocator.
	 *
	 * Uses the Shelf Best Height Fit algorithm from
	 * http://clb.demon.fi/files/RectangleBinPack.pdf
	 *
	 * @class  ShelfPack
	 * @param  {number}  [w=64]  Initial width of the sprite
	 * @param  {number}  [h=64]  Initial width of the sprite
	 * @param  {Object}  [options]
	 * @param  {boolean} [options.autoResize=false]  If `true`, the sprite will automatically grow
	 * @example
	 * var sprite = new ShelfPack(64, 64, { autoResize: false });
	 */
	function ShelfPack(w, h, options) {
	    options = options || {};
	    this.w = w || 64;
	    this.h = h || 64;
	    this.autoResize = !!options.autoResize;
	    this.shelves = [];
	    this.freebins = [];
	    this.stats = {};
	    this.bins = {};
	    this.maxId = 0;
	}
	
	
	/**
	 * Batch pack multiple bins into the sprite.
	 *
	 * @param   {Object[]} bins       Array of requested bins - each object should have `width`, `height` (or `w`, `h`) properties
	 * @param   {number}   bins[].w   Requested bin width
	 * @param   {number}   bins[].h   Requested bin height
	 * @param   {Object}   [options]
	 * @param   {boolean}  [options.inPlace=false] If `true`, the supplied bin objects will be updated inplace with `x` and `y` properties
	 * @returns {Bin[]}    Array of allocated Bins - each Bin is an object with `id`, `x`, `y`, `w`, `h` properties
	 * @example
	 * var bins = [
	 *     { id: 1, w: 12, h: 12 },
	 *     { id: 2, w: 12, h: 16 },
	 *     { id: 3, w: 12, h: 24 }
	 * ];
	 * var results = sprite.pack(bins, { inPlace: false });
	 */
	ShelfPack.prototype.pack = function(bins, options) {
	    bins = [].concat(bins);
	    options = options || {};
	
	    var results = [],
	        w, h, id, allocation;
	
	    for (var i = 0; i < bins.length; i++) {
	        w  = bins[i].w || bins[i].width;
	        h  = bins[i].h || bins[i].height;
	        id = bins[i].id;
	
	        if (w && h) {
	            allocation = this.packOne(w, h, id);
	            if (!allocation) {
	                continue;
	            }
	            if (options.inPlace) {
	                bins[i].x  = allocation.x;
	                bins[i].y  = allocation.y;
	                bins[i].id = allocation.id;
	            }
	            results.push(allocation);
	        }
	    }
	
	    // Shrink the width/height of the sprite to the bare minimum.
	    // Since shelf-pack doubles first width, then height when running out of shelf space
	    // this can result in fairly large unused space both in width and height if that happens
	    // towards the end of bin packing.
	    if (this.shelves.length > 0) {
	        var w2 = 0;
	        var h2 = 0;
	
	        for (var j = 0; j < this.shelves.length; j++) {
	            var shelf = this.shelves[j];
	            h2 += shelf.h;
	            w2 = Math.max(shelf.w - shelf.free, w2);
	        }
	
	        this.resize(w2, h2);
	    }
	
	    return results;
	};
	
	
	/**
	 * Pack a single bin into the sprite.
	 *
	 * Each bin will have a unique identitifer.
	 * If no identifier is supplied in the `id` parameter, one will be created.
	 * Note: The supplied `id` is used as an object index, so numeric values are fastest!
	 *
	 * Bins are automatically refcounted (i.e. a newly packed Bin will have a refcount of 1).
	 * When a bin is no longer needed, use the `ShelfPack.unref` function to mark it
	 *   as unused.  When a Bin's refcount decrements to 0, the Bin will be marked
	 *   as free and its space may be reused by the packing code.
	 *
	 * @param    {number}         w      Width of the bin to allocate
	 * @param    {number}         h      Height of the bin to allocate
	 * @param    {number|string}  [id]   Unique identifier for this bin, (if unsupplied, assume it's a new bin and create an id)
	 * @returns  {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties, or `null` if allocation failed
	 * @example
	 * var results = sprite.packOne(12, 16, 'a');
	 */
	ShelfPack.prototype.packOne = function(w, h, id) {
	    var best = { freebin: -1, shelf: -1, waste: Infinity },
	        y = 0,
	        bin, shelf, waste, i;
	
	    // if id was supplied, attempt a lookup..
	    if (typeof id === 'string' || typeof id === 'number') {
	        bin = this.getBin(id);
	        if (bin) {              // we packed this bin already
	            this.ref(bin);
	            return bin;
	        }
	        if (typeof id === 'number') {
	            this.maxId = Math.max(id, this.maxId);
	        }
	    } else {
	        id = ++this.maxId;
	    }
	
	    // First try to reuse a free bin..
	    for (i = 0; i < this.freebins.length; i++) {
	        bin = this.freebins[i];
	
	        // exactly the right height and width, use it..
	        if (h === bin.maxh && w === bin.maxw) {
	            return this.allocFreebin(i, w, h, id);
	        }
	        // not enough height or width, skip it..
	        if (h > bin.maxh || w > bin.maxw) {
	            continue;
	        }
	        // extra height or width, minimize wasted area..
	        if (h <= bin.maxh && w <= bin.maxw) {
	            waste = (bin.maxw * bin.maxh) - (w * h);
	            if (waste < best.waste) {
	                best.waste = waste;
	                best.freebin = i;
	            }
	        }
	    }
	
	    // Next find the best shelf..
	    for (i = 0; i < this.shelves.length; i++) {
	        shelf = this.shelves[i];
	        y += shelf.h;
	
	        // not enough width on this shelf, skip it..
	        if (w > shelf.free) {
	            continue;
	        }
	        // exactly the right height, pack it..
	        if (h === shelf.h) {
	            return this.allocShelf(i, w, h, id);
	        }
	        // not enough height, skip it..
	        if (h > shelf.h) {
	            continue;
	        }
	        // extra height, minimize wasted area..
	        if (h < shelf.h) {
	            waste = (shelf.h - h) * w;
	            if (waste < best.waste) {
	                best.freebin = -1;
	                best.waste = waste;
	                best.shelf = i;
	            }
	        }
	    }
	
	    if (best.freebin !== -1) {
	        return this.allocFreebin(best.freebin, w, h, id);
	    }
	
	    if (best.shelf !== -1) {
	        return this.allocShelf(best.shelf, w, h, id);
	    }
	
	    // No free bins or shelves.. add shelf..
	    if (h <= (this.h - y) && w <= this.w) {
	        shelf = new Shelf(y, this.w, h);
	        return this.allocShelf(this.shelves.push(shelf) - 1, w, h, id);
	    }
	
	    // No room for more shelves..
	    // If `autoResize` option is set, grow the sprite as follows:
	    //  * double whichever sprite dimension is smaller (`w1` or `h1`)
	    //  * if sprite dimensions are equal, grow width before height
	    //  * accomodate very large bin requests (big `w` or `h`)
	    if (this.autoResize) {
	        var h1, h2, w1, w2;
	
	        h1 = h2 = this.h;
	        w1 = w2 = this.w;
	
	        if (w1 <= h1 || w > w1) {   // grow width..
	            w2 = Math.max(w, w1) * 2;
	        }
	        if (h1 < w1 || h > h1) {    // grow height..
	            h2 = Math.max(h, h1) * 2;
	        }
	
	        this.resize(w2, h2);
	        return this.packOne(w, h, id);  // retry
	    }
	
	    return null;
	};
	
	
	/**
	 * Called by packOne() to allocate a bin by reusing an existing freebin
	 *
	 * @private
	 * @param    {number}         index  Index into the `this.freebins` array
	 * @param    {number}         w      Width of the bin to allocate
	 * @param    {number}         h      Height of the bin to allocate
	 * @param    {number|string}  id     Unique identifier for this bin
	 * @returns  {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties
	 * @example
	 * var bin = sprite.allocFreebin(0, 12, 16, 'a');
	 */
	ShelfPack.prototype.allocFreebin = function (index, w, h, id) {
	    var bin = this.freebins.splice(index, 1)[0];
	    bin.id = id;
	    bin.w = w;
	    bin.h = h;
	    bin.refcount = 0;
	    this.bins[id] = bin;
	    this.ref(bin);
	    return bin;
	};
	
	
	/**
	 * Called by `packOne() to allocate bin on an existing shelf
	 *
	 * @private
	 * @param    {number}         index  Index into the `this.shelves` array
	 * @param    {number}         w      Width of the bin to allocate
	 * @param    {number}         h      Height of the bin to allocate
	 * @param    {number|string}  id     Unique identifier for this bin
	 * @returns  {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties
	 * @example
	 * var results = sprite.allocShelf(0, 12, 16, 'a');
	 */
	ShelfPack.prototype.allocShelf = function(index, w, h, id) {
	    var shelf = this.shelves[index];
	    var bin = shelf.alloc(w, h, id);
	    this.bins[id] = bin;
	    this.ref(bin);
	    return bin;
	};
	
	
	/**
	 * Return a packed bin given its id, or undefined if the id is not found
	 *
	 * @param    {number|string}  id  Unique identifier for this bin,
	 * @returns  {Bin}            The requested bin, or undefined if not yet packed
	 * @example
	 * var b = sprite.getBin('a');
	 */
	ShelfPack.prototype.getBin = function(id) {
	    return this.bins[id];
	};
	
	
	/**
	 * Increment the ref count of a bin and update statistics.
	 *
	 * @param    {Bin}     bin  Bin instance
	 * @returns  {number}  New refcount of the bin
	 * @example
	 * var bin = sprite.getBin('a');
	 * sprite.ref(bin);
	 */
	ShelfPack.prototype.ref = function(bin) {
	    if (++bin.refcount === 1) {   // a new Bin.. record height in stats historgram..
	        var h = bin.h;
	        this.stats[h] = (this.stats[h] | 0) + 1;
	    }
	
	    return bin.refcount;
	};
	
	
	/**
	 * Decrement the ref count of a bin and update statistics.
	 * The bin will be automatically marked as free space once the refcount reaches 0.
	 *
	 * @param    {Bin}     bin  Bin instance
	 * @returns  {number}  New refcount of the bin
	 * @example
	 * var bin = sprite.getBin('a');
	 * sprite.unref(bin);
	 */
	ShelfPack.prototype.unref = function(bin) {
	    if (bin.refcount === 0) {
	        return 0;
	    }
	
	    if (--bin.refcount === 0) {
	        this.stats[bin.h]--;
	        delete this.bins[bin.id];
	        this.freebins.push(bin);
	    }
	
	    return bin.refcount;
	};
	
	
	/**
	 * Clear the sprite.  Resets everything and resets statistics.
	 *
	 * @example
	 * sprite.clear();
	 */
	ShelfPack.prototype.clear = function() {
	    this.shelves = [];
	    this.freebins = [];
	    this.stats = {};
	    this.bins = {};
	    this.maxId = 0;
	};
	
	
	/**
	 * Resize the sprite.
	 *
	 * @param   {number}  w  Requested new sprite width
	 * @param   {number}  h  Requested new sprite height
	 * @returns {boolean} `true` if resize succeeded, `false` if failed
	 * @example
	 * sprite.resize(256, 256);
	 */
	ShelfPack.prototype.resize = function(w, h) {
	    this.w = w;
	    this.h = h;
	    for (var i = 0; i < this.shelves.length; i++) {
	        this.shelves[i].resize(w);
	    }
	    return true;
	};
	
	
	/**
	 * Create a new Shelf.
	 *
	 * @private
	 * @class  Shelf
	 * @param  {number}  y   Top coordinate of the new shelf
	 * @param  {number}  w   Width of the new shelf
	 * @param  {number}  h   Height of the new shelf
	 * @example
	 * var shelf = new Shelf(64, 512, 24);
	 */
	function Shelf(y, w, h) {
	    this.x = 0;
	    this.y = y;
	    this.w = this.free = w;
	    this.h = h;
	}
	
	
	/**
	 * Allocate a single bin into the shelf.
	 *
	 * @private
	 * @param   {number}         w   Width of the bin to allocate
	 * @param   {number}         h   Height of the bin to allocate
	 * @param   {number|string}  id  Unique id of the bin to allocate
	 * @returns {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties, or `null` if allocation failed
	 * @example
	 * shelf.alloc(12, 16, 'a');
	 */
	Shelf.prototype.alloc = function(w, h, id) {
	    if (w > this.free || h > this.h) {
	        return null;
	    }
	    var x = this.x;
	    this.x += w;
	    this.free -= w;
	    return new Bin(id, x, this.y, w, h);
	};
	
	
	/**
	 * Resize the shelf.
	 *
	 * @private
	 * @param   {number}  w  Requested new width of the shelf
	 * @returns {boolean}    true
	 * @example
	 * shelf.resize(512);
	 */
	Shelf.prototype.resize = function(w) {
	    this.free += (w - this.w);
	    this.w = w;
	    return true;
	};
	
	
	/**
	 * Create a new Bin object.
	 *
	 * @class  Bin
	 * @param  {number|string}  id  Unique id of the bin
	 * @param  {number}         x   Left coordinate of the bin
	 * @param  {number}         y   Top coordinate of the bin
	 * @param  {number}         w   Width of the bin
	 * @param  {number}         h   Height of the bin
	 * @example
	 * var bin = new Bin('a', 0, 0, 12, 16);
	 */
	function Bin(id, x, y, w, h) {
	    this.id = id;
	    this.x  = x;
	    this.y  = y;
	    this.w  = w;
	    this.h  = h;
	    this.maxw = w;
	    this.maxh = h;
	    this.refcount = 0;
	}
	
	return ShelfPack;
	
	}));

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Glyphs;
	function Glyphs(pbf, end) {
	    this.stacks = pbf.readFields(readFontstacks, [], end);
	}
	
	function readFontstacks(tag, stacks, pbf) {
	    if (tag === 1) {
	        var fontstack = pbf.readMessage(readFontstack, { glyphs: {} });
	        stacks.push(fontstack);
	    }
	}
	
	function readFontstack(tag, fontstack, pbf) {
	    if (tag === 1) fontstack.name = pbf.readString();else if (tag === 2) fontstack.range = pbf.readString();else if (tag === 3) {
	        var glyph = pbf.readMessage(readGlyph, {});
	        fontstack.glyphs[glyph.id] = glyph;
	    }
	}
	
	function readGlyph(tag, glyph, pbf) {
	    if (tag === 1) glyph.id = pbf.readVarint();else if (tag === 2) glyph.bitmap = pbf.readBytes();else if (tag === 3) glyph.width = pbf.readVarint();else if (tag === 4) glyph.height = pbf.readVarint();else if (tag === 5) glyph.left = pbf.readSVarint();else if (tag === 6) glyph.top = pbf.readSVarint();else if (tag === 7) glyph.advance = pbf.readVarint();
	}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Authors: David Tichy, AleÅ¡ Saska
	 */
	
	var _class = function () {
	    function _class() {
	        _classCallCheck(this, _class);
	
	        this._enable = true;
	    }
	
	    _createClass(_class, [{
	        key: "debounce",
	        value: function debounce(func, wait, immediate) {
	            var _this = this,
	                _arguments = arguments;
	
	            var timeout = void 0,
	                args = void 0,
	                context = void 0,
	                timestamp = void 0,
	                result = void 0;
	
	            var later = function later() {
	                var last = Date.now - timestamp;
	
	                if (last < wait && last > 0) {
	                    timeout = setTimeout(later, wait - last);
	                } else {
	                    timeout = null;
	                    if (!immediate) {
	                        if (_this._enable) {
	                            result = func.apply(context, args);
	                        }
	                        if (!timeout) context = args = null;
	                    }
	                }
	            };
	
	            return function () {
	                context = _this;
	                args = _arguments;
	                timestamp = Date.now;
	                var callNow = immediate && !timeout;
	                if (!timeout) timeout = setTimeout(later, wait);
	                if (callNow) {
	                    if (_this._enable) {
	                        result = func.apply(context, args);
	                    }
	                    context = args = null;
	                }
	
	                return result;
	            };
	        }
	    }, {
	        key: "disable",
	        value: function disable() {
	            this._enable = false;
	        }
	    }]);
	
	    return _class;
	}();
	
	exports.default = _class;
	;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _geomutils = __webpack_require__(28);
	
	var _geomutils2 = _interopRequireDefault(_geomutils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 *  Copyright (c) 2016, Helikar Lab.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the GPLv3 License.
	 *  Author: AleÅ¡ Saska
	 */
	
	function pushUnique(arr, e) {
	  if (arr.indexOf(e) >= 0) return;
	  arr.push(e);
	}
	
	var _class = function () {
	  function _class(layers, insertTempLayer, draw, nodes, edges, checkUniqId) {
	    var _this = this;
	
	    _classCallCheck(this, _class);
	
	    this._layers = layers;
	    this._insertTempLayer = insertTempLayer;
	
	    this._draw = draw;
	    this._nodes = nodes;
	    this._edges = edges;
	    this._checkUniqId = checkUniqId;
	
	    this._toAddEdges = [];
	    this._toAddNodes = [];
	    this._toRemoveEdges = [];
	    this._toRemoveNodes = [];
	
	    //create support structures
	    this._nPos = {};
	    this._ePos = {};
	    this._eDirs = {};
	
	    nodes.forEach(function (n, i) {
	      _this._nPos[n.uniqid] = i;
	      _this._eDirs[n.uniqid] = {};
	    });
	
	    edges.forEach(function (e, i) {
	      var s = _geomutils2.default.edgeSource(e);
	      var t = _geomutils2.default.edgeTarget(e);
	
	      var si = s.uniqid || s.__uniqid;
	      var ti = t.uniqid || t.__uniqid;
	      (_this._eDirs[si] || (_this._eDirs[si] = {}))[ti] = e;
	      _this._ePos[e.uniqid] = i;
	    });
	
	    this._actualTempNodes = [];
	    this._actualTempEdges = [];
	  }
	
	  _createClass(_class, [{
	    key: "_doRemoveNodes",
	    value: function _doRemoveNodes(nodes) {
	      var _this2 = this;
	
	      nodes.forEach(function (n) {
	        if (n.uniqid === undefined) return;
	
	        if (_this2._nPos[n.uniqid] !== undefined) {
	          //in the normal graph
	          var pos = _this2._nPos[n.uniqid];
	          _this2._layers.main.removeNodeAtPos(pos);
	          delete _this2._nPos[n.uniqid];
	        } else {
	          //try to remove from temp graph
	
	          for (var i = 0; i < _this2._actualTempNodes.length; i++) {
	            if (_this2._actualTempNodes[i] === n) {
	              _this2._actualTempNodes.splice(i, 1);
	              break;
	            }
	          }
	        }
	
	        n.__uniqid = n.uniqid;
	        delete n.uniqid;
	      });
	    }
	  }, {
	    key: "_doRemoveEdges",
	    value: function _doRemoveEdges(edges) {
	      var _this3 = this;
	
	      edges.forEach(function (e) {
	        if (e.uniqid === undefined) return;
	
	        var s = _geomutils2.default.edgeSource(e);
	        var t = _geomutils2.default.edgeTarget(e);
	
	        delete (_this3._eDirs[s.uniqid || s.__uniqid] || {})[t.uniqid || t.__uniqid];
	
	        if (_this3._ePos[e.uniqid] !== undefined) {
	          //in the normal graph
	          var pos = _this3._ePos[e.uniqid];
	          _this3._layers.main.removeEdgeAtPos(pos);
	          delete _this3._ePos[e.uniqid];
	        } else {
	          //try to remove from temp graph
	
	          for (var i = 0; i < _this3._actualTempEdges.length; i++) {
	            if (_this3._actualTempEdges[i] === e) {
	              _this3._actualTempEdges.splice(i, 1);
	              break;
	            }
	          }
	        }
	
	        e.__uniqid = e.uniqid;
	        delete e.uniqid;
	      });
	    }
	  }, {
	    key: "_doAddEdges",
	    value: function _doAddEdges() {
	      var _this4 = this;
	
	      this._toAddEdges.forEach(function (e) {
	        //already added in main graph
	        if (_this4._ePos[e.uniqid] !== undefined) {
	          _this4._doRemoveEdges([e]);
	        }
	
	        if (e.uniqid !== undefined) {
	          console.error(e);
	          console.error("This edge has been already added, if you want to add same edge twice, create new object with same properties");
	          return;
	        }
	        _this4._checkUniqId(e);
	
	        //add this node into temporary chart
	
	        //TODO: Not so efficient >> causes quadratic complexity of adding edges into temporary graph
	        pushUnique(_this4._actualTempEdges, e);
	      });
	    }
	  }, {
	    key: "_doAddNodes",
	    value: function _doAddNodes(nodes) {
	      var _this5 = this;
	
	      this._toAddNodes.forEach(function (n) {
	        if (_this5._nPos[n.uniqid] !== undefined) {
	          _this5._doRemoveNodes([n]);
	        }
	
	        //already added
	        if (n.uniqid !== undefined) {
	          console.error(n);
	          console.error("This node has been already added, if you want to add same node twice, create new object with same properties");
	          return;
	        }
	        _this5._checkUniqId(n);
	
	        _this5._eDirs[n.uniqid] = {};
	
	        //TODO: Not so efficient >> causes quadratic complexity of adding nodes into temporary graph
	        pushUnique(_this5._actualTempNodes, n);
	      });
	    }
	  }, {
	    key: "addEdge",
	    value: function addEdge(e) {
	      var s = _geomutils2.default.edgeSource(e);
	      var t = _geomutils2.default.edgeTarget(e);
	
	      var tid = t.uniqid || t.__uniqid;
	      var sid = s.uniqid || s.__uniqid;
	
	      if ((this._eDirs[sid] || {})[tid]) {
	        //this edge was already added >> remove it
	        this._doRemoveEdges([e]);
	      }
	
	      if ((this._eDirs[tid] || {})[sid]) {
	        //must remove line and add two curves
	
	        this._toAddEdges.push(this._eDirs[tid][sid]);
	        this._doRemoveEdges([this._eDirs[tid][sid]]);
	
	        this._toAddEdges.push(this._eDirs[sid][tid] = e);
	
	        return this;
	      }
	
	      this._toAddEdges.push(e);
	      return this;
	    }
	  }, {
	    key: "addNode",
	    value: function addNode(n) {
	      this._toAddNodes.push(n);
	      return this;
	    }
	  }, {
	    key: "removeNode",
	    value: function removeNode(n) {
	      this._toRemoveNodes.push(n);
	      return this;
	    }
	  }, {
	    key: "removeEdge",
	    value: function removeEdge(e) {
	      this._toRemoveEdges.push(e);
	      return this;
	    }
	  }, {
	    key: "applyChanges",
	    value: function applyChanges() {
	
	      //nothing to do
	      if (this._toRemoveEdges.length === 0 && this._toRemoveNodes.length === 0 && this._toAddEdges.length === 0 && this._toAddNodes.length === 0) return this;
	
	      this._actualTempNodes = this._layers.temp ? this._layers.temp.nodes : [];
	      this._actualTempEdges = this._layers.temp ? this._layers.temp.edges : [];
	
	      this._doRemoveEdges(this._toRemoveEdges);
	      this._doRemoveNodes(this._toRemoveNodes);
	      this._doAddNodes();
	      this._doAddEdges();
	
	      this._toAddEdges = [];
	      this._toAddNodes = [];
	      this._toRemoveEdges = [];
	      this._toRemoveNodes = [];
	
	      this._insertTempLayer();
	      this._layers.temp.set(this._actualTempNodes, this._actualTempEdges);
	
	      this._draw();
	
	      return this;
	    }
	  }]);
	
	  return _class;
	}();
	
	exports.default = _class;
	;

/***/ })
/******/ ]);
//# sourceMappingURL=ccNetViz.js.map
if(true)
module.exports = ccNetViz;

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.6
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;
          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;
              default:
                return $$typeof;
            }
        }
      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}

// AsyncMode is deprecated along with isAsyncMode
var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;

var hasWarnedAboutDeprecatedIsAsyncMode = false;

// AsyncMode should be deprecated
function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }
  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "react"));

var _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));

var _ccnetviz = _interopRequireDefault(__webpack_require__(/*! ccnetviz */ "./node_modules/ccnetviz/dist/ccNetViz.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var CCNetVizComponent =
/*#__PURE__*/
function (_React$Component) {
  _inherits(CCNetVizComponent, _React$Component);

  function CCNetVizComponent() {
    var _this;

    _classCallCheck(this, CCNetVizComponent);

    _this = _possibleConstructorReturn(this, (CCNetVizComponent.__proto__ || Object.getPrototypeOf(CCNetVizComponent)).call(this));
    _this.canvasEl = (0, _react.createRef)();
    return _this;
  }

  _createClass(CCNetVizComponent, [{
    key: "draw",
    value: function draw() {
      this.ccNetViz.draw();
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this$props = this.props,
          nodes = _this$props.nodes,
          edges = _this$props.edges,
          layout = _this$props.layout;
      this.ccNetViz.set(nodes, edges, layout);
    }
  }, {
    key: "init",
    value: function init() {
      if (this.ccNetViz) {
        this.ccNetViz.remove();
      }

      this.ccNetViz = new _ccnetviz.default(this.canvasEl.current, this.props.options);
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(newprops) {
      var _this2 = this;

      var isChangeIn = function isChangeIn(types) {
        return types.some(function (key) {
          return newprops[key] !== _this2.props[key];
        });
      };

      var shouldRender = function shouldRender() {
        return isChangeIn(['width', 'height', 'style', 'className']);
      };

      if (isChangeIn(['options'])) {
        this.init();
        this.reset();
        this.draw();
        return shouldRender();
      }

      if (isChangeIn(['nodes', 'edges', 'layout'])) {
        this.reset();
        this.draw();
        return shouldRender();
      }

      return shouldRender();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.draw();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.ccNetViz.remove();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.init();
      this.reset();
      this.draw();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          width = _this$props2.width,
          height = _this$props2.height,
          style = _this$props2.style,
          className = _this$props2.className;
      return _react.default.createElement('canvas', {
        style: style,
        width: width,
        className: className,
        height: height,
        ref: this.canvasEl
      });
    }
  }]);

  return CCNetVizComponent;
}(_react.default.Component);

CCNetVizComponent.propTypes = {
  options: _propTypes.default.object,
  layout: _propTypes.default.string,
  nodes: _propTypes.default.array.isRequired,
  edges: _propTypes.default.array.isRequired
};
var _default = CCNetVizComponent;
exports.default = _default;
module.exports = exports["default"];

/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1jY05ldFZpei93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vcmVhY3QtY2NOZXRWaXovd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmVhY3QtY2NOZXRWaXovLi9ub2RlX21vZHVsZXMvY2NuZXR2aXovZGlzdC9jY05ldFZpei5qcyIsIndlYnBhY2s6Ly9yZWFjdC1jY05ldFZpei8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL3JlYWN0LWNjTmV0Vml6Ly4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vcmVhY3QtY2NOZXRWaXovLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9yZWFjdC1jY05ldFZpei8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL3JlYWN0LWNjTmV0Vml6Ly4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL3JlYWN0LWNjTmV0Vml6Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yZWFjdC1jY05ldFZpei8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC1jY05ldFZpei8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC1jY05ldFZpei9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9Il0sIm5hbWVzIjpbIkNDTmV0Vml6Q29tcG9uZW50IiwiY2FudmFzRWwiLCJjY05ldFZpeiIsImRyYXciLCJwcm9wcyIsIm5vZGVzIiwiZWRnZXMiLCJsYXlvdXQiLCJzZXQiLCJyZW1vdmUiLCJjdXJyZW50Iiwib3B0aW9ucyIsIm5ld3Byb3BzIiwiaXNDaGFuZ2VJbiIsInR5cGVzIiwic29tZSIsImtleSIsInNob3VsZFJlbmRlciIsImluaXQiLCJyZXNldCIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJjbGFzc05hbWUiLCJjcmVhdGVFbGVtZW50IiwicmVmIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwib2JqZWN0Iiwic3RyaW5nIiwiYXJyYXkiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0JBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzQkFBc0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQjtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQix1Q0FBdUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtB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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsb0NBQW9DLGtCQUFrQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixVQUFVO0FBQ1Y7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRyxLQUFLLEdBQUcsT0FBTyxHQUFHLEtBQUssR0FBRztBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QywwREFBMEQsRUFBRTs7QUFFeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7O0FBRzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMEJBQTBCOztBQUU1QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFrRDtBQUMzRTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFrRDtBQUMzRTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFtRDtBQUM3RTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsS0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixTQUFNO0FBQzdJO0FBQ0E7O0FBRUEsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksSUFBcUM7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMs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QUEsVUFJTEMsS0FKSyxnQkFJTEEsS0FKSztBQUFBLFVBS0xDLFNBTEssZ0JBS0xBLFNBTEs7QUFRUCxhQUFPLGVBQU1DLGFBQU4sQ0FBb0IsUUFBcEIsRUFBOEI7QUFDbkNGLGFBQUssRUFBTEEsS0FEbUM7QUFFbkNGLGFBQUssRUFBTEEsS0FGbUM7QUFHbkNHLGlCQUFTLEVBQVRBLFNBSG1DO0FBSW5DRixjQUFNLEVBQU5BLE1BSm1DO0FBS25DSSxXQUFHLEVBQUUsS0FBS3hCO0FBTHlCLE9BQTlCLENBQVA7QUFPRDs7OztFQTFFNkIsZUFBTXlCLFM7O0FBNkV0QzFCLGlCQUFpQixDQUFDMkIsU0FBbEIsR0FBOEI7QUFDNUJoQixTQUFPLEVBQUUsbUJBQVVpQixNQURTO0FBRTVCckIsUUFBTSxFQUFFLG1CQUFVc0IsTUFGVTtBQUc1QnhCLE9BQUssRUFBRSxtQkFBVXlCLEtBQVYsQ0FBZ0JDLFVBSEs7QUFJNUJ6QixPQUFLLEVBQUUsbUJBQVV3QixLQUFWLENBQWdCQztBQUpLLENBQTlCO2VBT2UvQixpQjs7Ozs7Ozs7Ozs7OztBQ3hGZixtRCIsImZpbGUiOiJyZWFjdC1jY05ldFZpei5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicmVhY3QtY2NOZXRWaXpcIiwgW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicmVhY3QtY2NOZXRWaXpcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVhY3QtY2NOZXRWaXpcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY2NOZXRWaXogPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcblx0dmFyIF9jY05ldFZpejIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jY05ldFZpeik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IEFsZcWhIFNhc2thIC0gaHR0cDovL2FsZXNzYXNrYS5jei9cblx0ICovXG5cdFxuXHR2YXIgY2NOZXRWaXpNdWx0aUxldmVsID0gZnVuY3Rpb24gY2NOZXRWaXpNdWx0aUxldmVsKGNhbnZhcywgb3B0aW9ucykge1xuXHQgIHZhciB2aXpTY3JlZW4gPSBuZXcgX2NjTmV0Vml6Mi5kZWZhdWx0KGNhbnZhcywgb3B0aW9ucyk7XG5cdCAgdmFyIHZpekxheW91dDtcblx0XG5cdCAgdmFyIGhpc3RvcnkgPSBbXTtcblx0ICB2YXIgY3VybGV2ZWwgPSB7fTtcblx0XG5cdCAgdmFyIG9uQ29udGV4dE1lbnUsIG9uQ2xpY2s7XG5cdFxuXHQgIC8vcmlnaHQgY2xpY2sgPj4gZ28gYmFja1xuXHQgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcblx0ICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgdmFyIGhpc3RlbCA9IGhpc3RvcnkucG9wKCk7XG5cdFxuXHQgICAgICAvL2N1cnJlbnRseSBzaG93biBsZXZlbFxuXHQgICAgICBjdXJsZXZlbCA9IGhpc3RlbDtcblx0XG5cdCAgICAgIHZpelNjcmVlbi5zZXQoY3VybGV2ZWwubm9kZXMsIGN1cmxldmVsLmVkZ2VzKTtcblx0ICAgICAgdml6U2NyZWVuLmRyYXcoKTtcblx0ICAgIH1cblx0XG5cdCAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgfSk7XG5cdFxuXHQgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcblx0ICAgIHZhciBiYiA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XG5cdCAgICB2YXIgeCA9IGUuY2xpZW50WCAtIGJiLmxlZnQ7XG5cdCAgICB2YXIgeSA9IGUuY2xpZW50WSAtIGJiLnRvcDtcblx0ICAgIHZhciByYWRpdXMgPSA1O1xuXHRcblx0ICAgIHZhciBsQ29vcmRzID0gdml6U2NyZWVuLmdldExheWVyQ29vcmRzKHsgcmFkaXVzOiByYWRpdXMsIHg6IHgsIHk6IHkgfSk7XG5cdCAgICB2YXIgcmVzdWx0ID0gdml6U2NyZWVuLmZpbmQobENvb3Jkcy54LCBsQ29vcmRzLnksIGxDb29yZHMucmFkaXVzLCB0cnVlLCBmYWxzZSk7XG5cdCAgICBpZiAocmVzdWx0Lm5vZGVzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgdmFyIG5vZGUgPSByZXN1bHQubm9kZXNbMF0ubm9kZTtcblx0XG5cdCAgICAgIHZhciBsYXlvdXQgPSBub2RlLmxheW91dCB8fCB2aXpMYXlvdXQ7XG5cdCAgICAgIGlmIChub2RlLl9fY29tcHV0ZWRMYXlvdXQpIHtcblx0ICAgICAgICAvL2l0IGlzIG5vdCBuZXNzZXNhcnkgdG8gcmVjb21wdXRlIGxheW91dCBpZiBpdCB3YXMgeWV0IGNvbXB1dGVkIG9uIHRoaXMgc3ViZ3JhcGhcblx0ICAgICAgICBsYXlvdXQgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy93ZSBzdG9yZSB0aGF0IGxheW91dCB3YXMgb25jZSBjb21wdXRlZCBmb3IgdGhpcyBzdWJncmFwaFxuXHQgICAgICAgIG5vZGUuX19jb21wdXRlZExheW91dCA9IHRydWU7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChub2RlLm5vZGVzICYmIG5vZGUuZWRnZXMpIHtcblx0ICAgICAgICB2YXIgaW5zaWRlbm9kZXMgPSBub2RlLm5vZGVzO1xuXHQgICAgICAgIHZhciBpbnNpZGVlZGdlcyA9IG5vZGUuZWRnZXM7XG5cdFxuXHQgICAgICAgIGhpc3RvcnkucHVzaChjdXJsZXZlbCk7XG5cdFxuXHQgICAgICAgIGN1cmxldmVsID0geyBub2RlczogaW5zaWRlbm9kZXMsIGVkZ2VzOiBpbnNpZGVlZGdlcyB9O1xuXHRcblx0ICAgICAgICB2aXpTY3JlZW4uc2V0KGN1cmxldmVsLm5vZGVzLCBjdXJsZXZlbC5lZGdlcywgbGF5b3V0KTtcblx0ICAgICAgICB2aXpTY3JlZW4uZHJhdygpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIC8vLy9UT0RPOiBBZGQgaW50ZXJhY3Rpdml0eSBmdW5jdGlvcyBpbnRvIHRoaXMgY2xhc3Ncblx0XG5cdCAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51KTtcblx0ICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spO1xuXHQgICAgdml6U2NyZWVuLnJlbW92ZSgpO1xuXHQgIH07XG5cdFxuXHQgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKG5vZGVzLCBlZGdlcywgbGF5b3V0KSB7XG5cdCAgICBjdXJsZXZlbCA9IHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMgfTtcblx0ICAgIGhpc3RvcnkgPSBbXTtcblx0XG5cdCAgICB2aXpMYXlvdXQgPSBsYXlvdXQ7XG5cdCAgICB2aXpTY3JlZW4uc2V0LmFwcGx5KHZpelNjcmVlbiwgYXJndW1lbnRzKTtcblx0ICB9O1xuXHRcblx0ICB2YXIgZXhwb3NlTWV0aG9kcyA9IFsnZmluZCcsICdmaW5kQXJlYScsICdnZXRMYXllckNvb3JkcycsICdkcmF3JywgJ3Jlc2V0VmlldycsICdzZXRWaWV3cG9ydCcsICd1cGRhdGUnLCAncmVzZXRWaWV3J107XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGV4cG9zZU1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cdCAgICAoZnVuY3Rpb24gKG1ldGhvZCwgc2VsZikge1xuXHQgICAgICBzZWxmW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHZpelNjcmVlblttZXRob2RdLmFwcGx5KHZpelNjcmVlbiwgYXJndW1lbnRzKTtcblx0ICAgICAgfTtcblx0ICAgIH0pKG1ldGhvZCwgc2VsZik7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHR3aW5kb3cuY2NOZXRWaXpNdWx0aUxldmVsID0gY2NOZXRWaXpNdWx0aUxldmVsO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gY2NOZXRWaXpNdWx0aUxldmVsO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfbGF5ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcblx0dmFyIF9sYXllcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXllcik7XG5cdFxuXHR2YXIgX2xheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdFxuXHR2YXIgX2xheW91dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXlvdXQpO1xuXHRcblx0dmFyIF9nbCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2dsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsKTtcblx0XG5cdHZhciBfY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9jb2xvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xvcik7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXHRcblx0dmFyIF90ZXh0dXJlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXHRcblx0dmFyIF90ZXh0dXJlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0dXJlcyk7XG5cdFxuXHR2YXIgX2ZpbGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cdFxuXHR2YXIgX2ZpbGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbGVzKTtcblx0XG5cdHZhciBfdGV4dHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblx0XG5cdHZhciBfdGV4dHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dHMpO1xuXHRcblx0dmFyIF9sYXp5RXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cdFxuXHR2YXIgX2xhenlFdmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGF6eUV2ZW50cyk7XG5cdFxuXHR2YXIgX2ludGVyYWN0aXZpdHlCYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXHRcblx0dmFyIF9pbnRlcmFjdGl2aXR5QmF0Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW50ZXJhY3Rpdml0eUJhdGNoKTtcblx0XG5cdHZhciBfc3BhdGlhbFNlYXJjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHRcblx0dmFyIF9zcGF0aWFsU2VhcmNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NwYXRpYWxTZWFyY2gpO1xuXHRcblx0dmFyIF9wcmltaXRpdmVUb29scyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3JzOiBcblx0ICogIERhdmlkIFRpY2h5XG5cdCAqICAgIEFsZcWhIFNhc2thIC0gaHR0cDovL2FsZXNzYXNrYS5jei9cblx0ICovXG5cdFxuXHR2YXIgc0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdGZ1bmN0aW9uIGdldENvbnRleHQoY2FudmFzKSB7XG5cdCAgdmFyIGF0dHJpYnV0ZXMgPSB7IGRlcHRoOiBmYWxzZSwgYW50aWFsaWFzOiBmYWxzZSB9O1xuXHQgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcblx0XG5cdCAgcmV0dXJuIGdsO1xuXHR9XG5cdFxuXHR2YXIgbGFzdFVuaXFJZCA9IDA7XG5cdFxuXHRmdW5jdGlvbiBjaGVja1VuaXFJZChlbCkge1xuXHQgIGlmIChlbC5fX3VuaXFpZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICBlbC51bmlxaWQgPSBlbC5fX3VuaXFpZDtcblx0ICAgIGRlbGV0ZSBlbC5fX3VuaXFpZDtcblx0ICB9IGVsc2UgaWYgKGVsLnVuaXFpZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBlbC51bmlxaWQgPSArK2xhc3RVbmlxSWQ7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBtZXJnZUFycmF5cyhhLCBiLCBjbXApIHtcblx0ICB2YXIgciA9IFtdO1xuXHQgIHIubGVuZ3RoID0gYS5sZW5ndGggKyBiLmxlbmd0aDtcblx0XG5cdCAgdmFyIGkgPSAwLFxuXHQgICAgICBqID0gMCxcblx0ICAgICAgayA9IDA7XG5cdFxuXHQgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaiA8IGIubGVuZ3RoKSB7XG5cdCAgICBpZiAoY21wKGFbaV0sIGJbal0pIDwgMCkgcltrKytdID0gYVtpKytdO2Vsc2UgcltrKytdID0gYltqKytdO1xuXHQgIH1cblx0XG5cdCAgd2hpbGUgKGkgPCBhLmxlbmd0aCkge1xuXHQgICAgcltrKytdID0gYVtpKytdO1xuXHQgIH13aGlsZSAoaiA8IGIubGVuZ3RoKSB7XG5cdCAgICByW2srK10gPSBiW2orK107XG5cdCAgfXJldHVybiByO1xuXHR9XG5cdFxuXHR2YXIgY2NOZXRWaXogPSBmdW5jdGlvbiBjY05ldFZpeihjYW52YXMsIG9wdGlvbnMpIHtcblx0ICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgY2FudmFzID0gY2FudmFzIHx8IHNDYW52YXM7XG5cdFxuXHQgIHZhciBiYWNrZ3JvdW5kU3R5bGUgPSBvcHRpb25zLnN0eWxlcy5iYWNrZ3JvdW5kID0gb3B0aW9ucy5zdHlsZXMuYmFja2dyb3VuZCB8fCB7fTtcblx0ICB2YXIgYmFja2dyb3VuZENvbG9yID0gbmV3IF9jb2xvcjIuZGVmYXVsdChiYWNrZ3JvdW5kU3R5bGUuY29sb3IgfHwgXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIik7XG5cdFxuXHQgIHZhciByZW1vdmVkID0gZmFsc2U7XG5cdCAgdmFyIHNldHRlZCA9IGZhbHNlO1xuXHRcblx0ICB2YXIgbm9kZVN0eWxlID0gb3B0aW9ucy5zdHlsZXMubm9kZSA9IG9wdGlvbnMuc3R5bGVzLm5vZGUgfHwge307XG5cdCAgbm9kZVN0eWxlLm1pblNpemUgPSBub2RlU3R5bGUubWluU2l6ZSAhPSBudWxsID8gbm9kZVN0eWxlLm1pblNpemUgOiA2O1xuXHQgIG5vZGVTdHlsZS5tYXhTaXplID0gbm9kZVN0eWxlLm1heFNpemUgfHwgMTY7XG5cdCAgbm9kZVN0eWxlLmNvbG9yID0gbm9kZVN0eWxlLmNvbG9yIHx8IFwicmdiKDI1NSwgMjU1LCAyNTUpXCI7XG5cdFxuXHQgIGlmIChub2RlU3R5bGUubGFiZWwpIHtcblx0ICAgIHZhciBzID0gbm9kZVN0eWxlLmxhYmVsO1xuXHQgICAgcy5jb2xvciA9IHMuY29sb3IgfHwgXCJyZ2IoMTIwLCAxMjAsIDEyMClcIjtcblx0ICAgIHMuZm9udCA9IHMuZm9udCB8fCB7IHR5cGU6IFwiQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZlwiLCBzaXplOiAxMSB9O1xuXHQgIH1cblx0XG5cdCAgdmFyIGVkZ2VTdHlsZSA9IG9wdGlvbnMuc3R5bGVzLmVkZ2UgPSBvcHRpb25zLnN0eWxlcy5lZGdlIHx8IHt9O1xuXHQgIGVkZ2VTdHlsZS53aWR0aCA9IGVkZ2VTdHlsZS53aWR0aCB8fCAxO1xuXHQgIGVkZ2VTdHlsZS5jb2xvciA9IGVkZ2VTdHlsZS5jb2xvciB8fCBcInJnYigyMDQsIDIwNCwgMjA0KVwiO1xuXHRcblx0ICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKCkge1xuXHQgICAgaWYgKCFvcHRpb25zLm9uTG9hZCB8fCBvcHRpb25zLm9uTG9hZCgpKSB7XG5cdCAgICAgIF90aGlzLmRyYXcodHJ1ZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgaWYgKGVkZ2VTdHlsZS5hcnJvdykge1xuXHQgICAgdmFyIF9zID0gZWRnZVN0eWxlLmFycm93O1xuXHQgICAgX3MubWluU2l6ZSA9IF9zLm1pblNpemUgIT0gbnVsbCA/IF9zLm1pblNpemUgOiA2O1xuXHQgICAgX3MubWF4U2l6ZSA9IF9zLm1heFNpemUgfHwgMTI7XG5cdCAgICBfcy5hc3BlY3QgPSAxO1xuXHQgIH1cblx0XG5cdCAgdmFyIGV2ZW50cyA9IG5ldyBfbGF6eUV2ZW50czIuZGVmYXVsdCgpO1xuXHQgIHZhciBsYXllcnMgPSB7fTtcblx0ICB2YXIgdmlldyA9IHZvaWQgMCxcblx0ICAgICAgZ2wgPSB2b2lkIDAsXG5cdCAgICAgIGRyYXdGdW5jID0gdm9pZCAwLFxuXHQgICAgICB0ZXh0dXJlcyA9IHZvaWQgMCxcblx0ICAgICAgZmlsZXMgPSB2b2lkIDAsXG5cdCAgICAgIHRleHRzID0gdm9pZCAwO1xuXHQgIHZhciBjb250ZXh0ID0ge307XG5cdFxuXHQgIHRoaXMuY250U2hvd25Ob2RlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBuID0gMDtcblx0ICAgIGZvciAodmFyIGsgaW4gbGF5ZXJzKSB7XG5cdCAgICAgIG4gKz0gbGF5ZXJzW2tdLmNudFNob3duTm9kZXMoKTtcblx0ICAgIH1yZXR1cm4gbjtcblx0ICB9O1xuXHQgIHZhciBnZXROb2Rlc0NudCA9IG9wdGlvbnMuZ2V0Tm9kZXNDbnQgfHwgdGhpcy5jbnRTaG93bk5vZGVzO1xuXHRcblx0ICB0aGlzLmNudFNob3duRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZSA9IDA7XG5cdCAgICBmb3IgKHZhciBrIGluIGxheWVycykge1xuXHQgICAgICBlICs9IGxheWVyc1trXS5jbnRTaG93bkVkZ2VzKCk7XG5cdCAgICB9cmV0dXJuIGU7XG5cdCAgfTtcblx0ICB2YXIgZ2V0RWRnZXNDbnQgPSBvcHRpb25zLmdldEVkZ2VzQ250IHx8IHRoaXMuY250U2hvd25FZGdlcztcblx0XG5cdCAgdmFyIG9uUmVkcmF3ID0gZXZlbnRzLmRlYm91bmNlKGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYuZHJhdy5jYWxsKHNlbGYpO1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sIDUpO1xuXHRcblx0ICBmdW5jdGlvbiBjaGVja1JlbW92ZWQoKSB7XG5cdCAgICBpZiAocmVtb3ZlZCkge1xuXHQgICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IGNhbGwgYW55IGZ1bmN0aW9uIG9uIGdyYXBoIGFmdGVyIHJlbW92ZSgpXCIpO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdFxuXHQgIHZhciBub2RlcyA9IHZvaWQgMCxcblx0ICAgICAgZWRnZXMgPSB2b2lkIDA7XG5cdFxuXHQgIGZ1bmN0aW9uIGluc2VydFRlbXBMYXllcigpIHtcblx0ICAgIGlmIChsYXllcnMudGVtcCkgcmV0dXJuO1xuXHQgICAgbGF5ZXJzLnRlbXAgPSBuZXcgX2xheWVyMi5kZWZhdWx0KGNhbnZhcywgY29udGV4dCwgdmlldywgZ2wsIHRleHR1cmVzLCBmaWxlcywgdGV4dHMsIGV2ZW50cywgb3B0aW9ucywgYmFja2dyb3VuZENvbG9yLCBub2RlU3R5bGUsIGVkZ2VTdHlsZSwgZ2V0U2l6ZSwgZ2V0Tm9kZVNpemUsIGdldExhYmVsU2l6ZSwgZ2V0TGFiZWxIaWRlU2l6ZSwgZ2V0Tm9kZXNDbnQsIGdldEVkZ2VzQ250LCBvblJlZHJhdywgb25Mb2FkKTtcblx0ICB9XG5cdFxuXHQgIHZhciBiYXRjaCA9IHVuZGVmaW5lZDtcblx0ICBmdW5jdGlvbiBnZXRCYXRjaCgpIHtcblx0ICAgIGlmICghYmF0Y2gpIGJhdGNoID0gbmV3IF9pbnRlcmFjdGl2aXR5QmF0Y2gyLmRlZmF1bHQobGF5ZXJzLCBpbnNlcnRUZW1wTGF5ZXIsIGRyYXdGdW5jLCBub2RlcywgZWRnZXMsIGNoZWNrVW5pcUlkKTtcblx0ICAgIHJldHVybiBiYXRjaDtcblx0ICB9O1xuXHRcblx0ICB0aGlzLnNldCA9IGZ1bmN0aW9uIChuLCBlLCBsYXlvdXQpIHtcblx0ICAgIHZhciBsYXlvdXRfb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cdFxuXHQgICAgaWYgKGNoZWNrUmVtb3ZlZCgpKSByZXR1cm4gX3RoaXM7XG5cdFxuXHQgICAgbm9kZXMgPSBuIHx8IFtdO1xuXHQgICAgZWRnZXMgPSBlIHx8IFtdO1xuXHRcblx0ICAgIG5vZGVzLmZvckVhY2goY2hlY2tVbmlxSWQpO1xuXHQgICAgZWRnZXMuZm9yRWFjaChjaGVja1VuaXFJZCk7XG5cdFxuXHQgICAgbGF5ZXJzLnRlbXAgJiYgbGF5ZXJzLnRlbXAuc2V0KFtdLCBbXSwgbGF5b3V0LCBsYXlvdXRfb3B0aW9ucyk7XG5cdCAgICBsYXllcnMubWFpbi5zZXQobm9kZXMsIGVkZ2VzLCBsYXlvdXQsIGxheW91dF9vcHRpb25zKTtcblx0XG5cdCAgICAvL3Jlc2V0IGJhdGNoXG5cdCAgICBiYXRjaCA9IHVuZGVmaW5lZDtcblx0ICAgIHNldHRlZCA9IHRydWU7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgLy9tYWtlIGFsbCBkeW5hbWljIGNoYW5nZXMgc3RhdGljXG5cdCAgdGhpcy5yZWZsb3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybjtcblx0XG5cdCAgICBnZXRCYXRjaCgpLmFwcGx5Q2hhbmdlcygpO1xuXHRcblx0ICAgIC8vbm9kZXMgYW5kIGVkZ2VzIGluIGR5bmFtaWMgY2hhcnQgYXJlIGFjdHVhbFxuXHQgICAgdmFyIG4gPSBsYXllcnMubWFpbi5nZXRWaXNpYmxlTm9kZXMoKTtcblx0ICAgIGlmIChsYXllcnMudGVtcCkgbiA9IG4uY29uY2F0KGxheWVycy50ZW1wLmdldFZpc2libGVOb2RlcygpKTtcblx0XG5cdCAgICB2YXIgZSA9IGxheWVycy5tYWluLmdldFZpc2libGVFZGdlcygpO1xuXHQgICAgaWYgKGxheWVycy50ZW1wKSBlID0gZS5jb25jYXQobGF5ZXJzLnRlbXAuZ2V0VmlzaWJsZUVkZ2VzKCkpO1xuXHRcblx0ICAgIF90aGlzLnNldChuLCBlKTtcblx0ICAgIF90aGlzLmRyYXcoKTtcblx0ICB9O1xuXHRcblx0ICB0aGlzLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobikge1xuXHQgICAgaWYgKGNoZWNrUmVtb3ZlZCgpKSB7XG5cdCAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1nZXRCYXRjaCgpLnJlbW92ZU5vZGUobik7cmV0dXJuIF90aGlzO1xuXHQgIH07XG5cdCAgdGhpcy5yZW1vdmVFZGdlID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkge1xuXHQgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9Z2V0QmF0Y2goKS5yZW1vdmVFZGdlKGUpO3JldHVybiBfdGhpcztcblx0ICB9O1xuXHQgIHRoaXMuYWRkRWRnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfWdldEJhdGNoKCkuYWRkRWRnZShlKTtyZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0ICB0aGlzLmFkZE5vZGUgPSBmdW5jdGlvbiAobikge1xuXHQgICAgaWYgKGNoZWNrUmVtb3ZlZCgpKSB7XG5cdCAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1nZXRCYXRjaCgpLmFkZE5vZGUobik7cmV0dXJuIF90aGlzO1xuXHQgIH07XG5cdCAgdGhpcy51cGRhdGVOb2RlID0gZnVuY3Rpb24gKG4pIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkge1xuXHQgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9cmV0dXJuIF90aGlzLnJlbW92ZU5vZGUobikuYWRkTm9kZShuKTtcblx0ICB9O1xuXHQgIHRoaXMudXBkYXRlRWRnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfXJldHVybiBfdGhpcy5yZW1vdmVFZGdlKGUpLmFkZEVkZ2UoZSk7XG5cdCAgfTtcblx0ICB0aGlzLmFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkge1xuXHQgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9Z2V0QmF0Y2goKS5hcHBseUNoYW5nZXMoKTtyZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdGhpcy5hZGRFZGdlcyA9IGZ1bmN0aW9uIChlZGdlcykge1xuXHQgICAgaWYgKGNoZWNrUmVtb3ZlZCgpKSByZXR1cm4gX3RoaXM7XG5cdFxuXHQgICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpcy5hZGRFZGdlKGUpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH07XG5cdFxuXHQgIHRoaXMuYWRkTm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkgcmV0dXJuIF90aGlzO1xuXHRcblx0ICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgX3RoaXMuYWRkTm9kZShuKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICB0aGlzLnJlbW92ZUVkZ2VzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybiBfdGhpcztcblx0XG5cdCAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIF90aGlzLnJlbW92ZUVkZ2UoZSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICB0aGlzLnJlbW92ZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybiBfdGhpcztcblx0XG5cdCAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgIF90aGlzLnJlbW92ZU5vZGUobik7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9O1xuXHRcblx0ICB0aGlzLnVwZGF0ZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybiBfdGhpcztcblx0XG5cdCAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgIF90aGlzLnVwZGF0ZU5vZGUobik7XG5cdCAgICB9KTtcblx0XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfTtcblx0XG5cdCAgdGhpcy51cGRhdGVFZGdlcyA9IGZ1bmN0aW9uIChlZGdlcykge1xuXHQgICAgaWYgKGNoZWNrUmVtb3ZlZCgpKSByZXR1cm4gX3RoaXM7XG5cdFxuXHQgICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICBfdGhpcy51cGRhdGVFZGdlKGUpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH07XG5cdFxuXHQgIHZhciBnZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZShjLCBzLCBuLCBzYykge1xuXHQgICAgdmFyIHJlc3VsdCA9IHNjICogTWF0aC5zcXJ0KGMud2lkdGggKiBjLmhlaWdodCAvIChuICsgMSkpIC8gdmlldy5zaXplO1xuXHQgICAgaWYgKHMpIHtcblx0ICAgICAgdmFyIG1pbiA9IHMuc2l6ZSA/IHMuc2l6ZSA6IHMubWluU2l6ZTtcblx0ICAgICAgdmFyIG1heCA9IHMuc2l6ZSA/IHMuc2l6ZSA6IHMubWF4U2l6ZTtcblx0XG5cdCAgICAgIHJlc3VsdCA9IG1heCA/IE1hdGgubWluKG1heCwgcmVzdWx0KSA6IHJlc3VsdDtcblx0ICAgICAgaWYgKHJlc3VsdCA8IHMuaGlkZVNpemUpIHJldHVybiAwO1xuXHQgICAgICByZXN1bHQgPSBtaW4gPyBNYXRoLm1heChtaW4sIHJlc3VsdCkgOiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cdFxuXHQgIHZhciBnZXROb2RlU2l6ZSA9IGZ1bmN0aW9uIGdldE5vZGVTaXplKGMpIHtcblx0ICAgIHJldHVybiBnZXRTaXplKGMsIGMuc3R5bGUsIGdldE5vZGVzQ250KCksIDAuNCk7XG5cdCAgfTtcblx0ICB2YXIgZ2V0TGFiZWxTaXplID0gZnVuY3Rpb24gZ2V0TGFiZWxTaXplKGMsIHMpIHtcblx0ICAgIHJldHVybiBnZXRTaXplKGMsIHMsIGdldE5vZGVzQ250KCksIDAuMjUpO1xuXHQgIH07XG5cdFxuXHQgIHZhciBnZXRMYWJlbEhpZGVTaXplID0gZnVuY3Rpb24gZ2V0TGFiZWxIaWRlU2l6ZShjLCBzKSB7XG5cdCAgICBpZiAocykge1xuXHQgICAgICB2YXIgc2MgPSAwLjI1O1xuXHQgICAgICB2YXIgbiA9IGxheWVycy5tYWluLmNudFNob3duTm9kZXMoKTsgLy9sb3dlciBib3VuZFxuXHQgICAgICB2YXIgdCA9IHNjICogTWF0aC5zcXJ0KGMud2lkdGggKiBjLmhlaWdodCAvIChuICsgMSkpO1xuXHRcblx0ICAgICAgdmFyIHZzID0gdm9pZCAwO1xuXHQgICAgICBpZiAocy5oaWRlU2l6ZSkge1xuXHQgICAgICAgIHZzID0gdCAvIHMuaGlkZVNpemU7XG5cdCAgICAgICAgaWYgKHMubWF4U2l6ZSkgdnMgPSBNYXRoLm1pbih2cywgdCAvIHMubWF4U2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIHZzO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIDE7XG5cdCAgfTtcblx0XG5cdCAgdmFyIG9mZnNldCA9IDAuNSAqIG5vZGVTdHlsZS5tYXhTaXplO1xuXHRcblx0ICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoc2lsZW50KSB7XG5cdCAgICBpZiAoc2lsZW50ICYmIChyZW1vdmVkIHx8ICFzZXR0ZWQpKSByZXR1cm47XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybjtcblx0XG5cdCAgICB2YXIgd2lkdGggPSBjYW52YXMud2lkdGg7XG5cdCAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblx0ICAgIHZhciBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcblx0ICAgIHZhciBvID0gdmlldy5zaXplID09PSAxID8gb2Zmc2V0IDogMDtcblx0ICAgIHZhciBveCA9IG8gLyB3aWR0aDtcblx0ICAgIHZhciBveSA9IG8gLyBoZWlnaHQ7XG5cdFxuXHQgICAgY29udGV4dC50cmFuc2Zvcm0gPSBfZ2wyLmRlZmF1bHQub3J0aG8odmlldy54IC0gb3gsIHZpZXcueCArIHZpZXcuc2l6ZSArIG94LCB2aWV3LnkgLSBveSwgdmlldy55ICsgdmlldy5zaXplICsgb3ksIC0xLCAxKTtcblx0ICAgIGNvbnRleHQub2Zmc2V0WCA9IG94O1xuXHQgICAgY29udGV4dC5vZmZzZXRZID0gb3k7XG5cdCAgICBjb250ZXh0LndpZHRoID0gMC41ICogd2lkdGg7XG5cdCAgICBjb250ZXh0LmhlaWdodCA9IDAuNSAqIGhlaWdodDtcblx0ICAgIGNvbnRleHQuYXNwZWN0MiA9IGFzcGVjdCAqIGFzcGVjdDtcblx0ICAgIGNvbnRleHQuYXNwZWN0ID0gYXNwZWN0O1xuXHQgICAgY29udGV4dC5jb3VudCA9IGdldE5vZGVzQ250KCk7XG5cdFxuXHQgICAgLy9iYWQgaGFjayBiZWNhdXNlIHdlIHVzZSBkaWZmZXJlbnQgc2l6ZSBmb3IgY3VydmVFeGMgYW5kIGZvciBub2RlU2l6ZSA6KFxuXHQgICAgaWYgKGNvbnRleHQuc3R5bGUpIGRlbGV0ZSBjb250ZXh0LnN0eWxlO1xuXHQgICAgY29udGV4dC5jdXJ2ZUV4YyA9IGdldFNpemUoY29udGV4dCwgdW5kZWZpbmVkLCBnZXRFZGdlc0NudCgpLCAwLjUpO1xuXHQgICAgY29udGV4dC5zdHlsZSA9IG5vZGVTdHlsZTtcblx0ICAgIGNvbnRleHQubm9kZVNpemUgPSBnZXROb2RlU2l6ZShjb250ZXh0KTtcblx0XG5cdCAgICBnbCAmJiBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblx0XG5cdCAgICBnbCAmJiBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblx0XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5tYWluLnNjZW5lLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGxheWVycy5tYWluLnNjZW5lLmVsZW1lbnRzW2ldLmRyYXcoY29udGV4dCk7XG5cdCAgICAgIGxheWVycy50ZW1wICYmIGxheWVycy50ZW1wLnNjZW5lLmVsZW1lbnRzW2ldLmRyYXcoY29udGV4dCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBkcmF3RnVuYyA9IHRoaXMuZHJhdy5iaW5kKHRoaXMpO1xuXHRcblx0ICB0aGlzLmdldFNjcmVlbkNvb3JkcyA9IGZ1bmN0aW9uIChjb25mKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybjtcblx0ICAgIHZhciByZXQgPSB7fTtcblx0ICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgaWYgKGNvbmYueCAhPT0gdW5kZWZpbmVkKSByZXQueCA9IChjb25mLnggLSB2aWV3LnggKyBjb250ZXh0Lm9mZnNldFgpIC8gKHZpZXcuc2l6ZSArIDIgKiBjb250ZXh0Lm9mZnNldFgpICogY2FudmFzLndpZHRoICsgcmVjdC5sZWZ0O1xuXHQgICAgaWYgKGNvbmYueSAhPT0gdW5kZWZpbmVkKSByZXQueSA9ICgxIC0gKGNvbmYueSAtIHZpZXcueSArIGNvbnRleHQub2Zmc2V0WSkgLyAodmlldy5zaXplICsgMiAqIGNvbnRleHQub2Zmc2V0WSkpICogY2FudmFzLmhlaWdodCArIHJlY3QudG9wO1xuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9O1xuXHRcblx0ICB0aGlzLmdldExheWVyQ29vcmRzID0gZnVuY3Rpb24gKGNvbmYpIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkgcmV0dXJuO1xuXHRcblx0ICAgIHZhciByZXQgPSB7fTtcblx0XG5cdCAgICBbJ3gnLCAneDEnLCAneDInXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdCAgICAgIGlmIChjb25mW2tdICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB2YXIgeCA9IGNvbmZba107XG5cdCAgICAgICAgeCA9IHggLyBjYW52YXMud2lkdGggKiAodmlldy5zaXplICsgMiAqIGNvbnRleHQub2Zmc2V0WCkgLSBjb250ZXh0Lm9mZnNldFggKyB2aWV3Lng7XG5cdCAgICAgICAgcmV0W2tdID0geDtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdFxuXHQgICAgWyd5JywgJ3kxJywgJ3kyJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHQgICAgICBpZiAoY29uZltrXSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgdmFyIHkgPSBjb25mW2tdO1xuXHQgICAgICAgIHkgPSAoMSAtIHkgLyBjYW52YXMuaGVpZ2h0KSAqICh2aWV3LnNpemUgKyAyICogY29udGV4dC5vZmZzZXRZKSAtIGNvbnRleHQub2Zmc2V0WSArIHZpZXcueTtcblx0ICAgICAgICByZXRba10gPSB5O1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0XG5cdCAgICBpZiAoY29uZi5yYWRpdXMgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB2YXIgZGlzdCA9IGNvbmYucmFkaXVzO1xuXHRcblx0ICAgICAgdmFyIGRpc3RoID0gZGlzdCAvIGNhbnZhcy5oZWlnaHQ7XG5cdCAgICAgIHZhciBkaXN0dyA9IGRpc3QgLyBjYW52YXMud2lkdGg7XG5cdCAgICAgIGRpc3QgPSBNYXRoLm1heChkaXN0aCwgZGlzdHcpICogdmlldy5zaXplO1xuXHRcblx0ICAgICAgcmV0LnJhZGl1cyA9IGRpc3Q7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9O1xuXHRcblx0ICB2YXIgZmluZE1lcmdlID0gZnVuY3Rpb24gZmluZE1lcmdlKGZ1bmNuYW1lLCBhcmdzKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkgfHwgIWdsKSByZXR1cm47XG5cdFxuXHQgICAgdmFyIGYxID0gbGF5ZXJzLm1haW5bZnVuY25hbWVdLmFwcGx5KGxheWVycy5tYWluLCBhcmdzKTtcblx0XG5cdCAgICBpZiAoIWxheWVycy50ZW1wKSByZXR1cm4gZjE7XG5cdFxuXHQgICAgdmFyIGYyID0gbGF5ZXJzLnRlbXBbZnVuY25hbWVdLmFwcGx5KGxheWVycy50ZW1wLCBhcmdzKTtcblx0XG5cdCAgICB2YXIgciA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIGYxKSB7XG5cdCAgICAgIHJba2V5XSA9IG1lcmdlQXJyYXlzKGYxW2tleV0sIGYyW2tleV0sIGZ1bmN0aW9uIChlMSwgZTIpIHtcblx0ICAgICAgICByZXR1cm4gZTEuZGlzdDIgLSBlMi5kaXN0Mjtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblx0XG5cdCAgdGhpcy5maW5kID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGZpbmRNZXJnZSgnZmluZCcsIGFyZ3VtZW50cyk7XG5cdCAgfTtcblx0ICB0aGlzLmZpbmRBcmVhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGZpbmRNZXJnZSgnZmluZEFyZWEnLCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdFxuXHQgIHRoaXMuZ2V0VGV4dFBvc2l0aW9uID0gZnVuY3Rpb24gKG4pIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSB8fCAhZ2wpIHJldHVybjtcblx0XG5cdCAgICB2YXIgb2Zmc2V0ID0gMC41ICogY29udGV4dC5ub2RlU2l6ZTtcblx0ICAgIHZhciBvZmZzZXR5ID0gKDIuMCAqIChuLnkgPD0gMC41ID8gMCA6IDEpIC0gMS4wKSAqIG9mZnNldDtcblx0XG5cdCAgICB2YXIgbnMgPSAoMCwgX3ByaW1pdGl2ZVRvb2xzLmdldFBhcnRpdGlvblN0eWxlKShvcHRpb25zLnN0eWxlc1tuLnN0eWxlXSwgbm9kZVN0eWxlLCBcImxhYmVsXCIpO1xuXHQgICAgdmFyIHRleHRFbmdpbmUgPSB0ZXh0cy5nZXRFbmdpbmUobnMuZm9udCk7XG5cdCAgICB0ZXh0RW5naW5lLnNldEZvbnQobnMuZm9udCk7XG5cdFxuXHQgICAgdmFyIHdhbnRlZFNpemUgPSB0ZXh0RW5naW5lLmlzU0RGID8gZ2V0TGFiZWxTaXplKGNvbnRleHQsIG5zLmxhYmVsIHx8IHt9KSA6IHRleHRFbmdpbmUuZm9udFNpemU7XG5cdCAgICB2YXIgZm9udFNjYWxlID0gd2FudGVkU2l6ZSAvIHRleHRFbmdpbmUuZm9udFNpemU7aWYgKHdhbnRlZFNpemUgPT09IDApIHtcblx0ICAgICAgZm9udFNjYWxlID0gMDtcblx0ICAgIH07XG5cdFxuXHQgICAgcmV0dXJuIHsgb2Zmc2V0WTogb2Zmc2V0eSwgZm9udFNjYWxlOiBmb250U2NhbGUsIGNoYXJzOiB0ZXh0RW5naW5lLmdldChuLmxhYmVsLCBuLngsIG4ueSkgfTtcblx0ICB9O1xuXHRcblx0ICB2YXIgYWRkRXZ0cyA9IGZ1bmN0aW9uIGFkZEV2dHMoZWwsIGV2dHMpIHtcblx0ICAgIGZvciAodmFyIGsgaW4gZXZ0cyB8fCB7fSkge1xuXHQgICAgICBldnRzW2tdICYmIGVsLmFkZEV2ZW50TGlzdGVuZXIoaywgZXZ0c1trXSwgeyBwYXNzaXZlOiBvcHRpb25zLnBhc3NpdmVFdnRzIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIHZhciByZW1vdmVFdnRzID0gZnVuY3Rpb24gcmVtb3ZlRXZ0cyhlbCwgZXZ0cykge1xuXHQgICAgZm9yICh2YXIgayBpbiBldnRzIHx8IHt9KSB7XG5cdCAgICAgIGV2dHNba10gJiYgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihrLCBldnRzW2tdKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICB2YXIgb25Eb3duVGhpcyA9IG9uTW91c2VEb3duLmJpbmQodGhpcyk7XG5cdFxuXHQgIHZhciB6b29tZXZ0cyA9IHZvaWQgMDtcblx0ICBhZGRFdnRzKGNhbnZhcywgem9vbWV2dHMgPSB7XG5cdCAgICAnbW91c2Vkb3duJzogb25Eb3duVGhpcyxcblx0ICAgICd0b3VjaHN0YXJ0Jzogb25Eb3duVGhpcyxcblx0ICAgICd3aGVlbCc6IG9uV2hlZWwuYmluZCh0aGlzKSxcblx0ICAgICdjb250ZXh0bWVudSc6IG9wdGlvbnMub25Db250ZXh0TWVudVxuXHQgIH0pO1xuXHRcblx0ICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkgcmV0dXJuO1xuXHRcblx0ICAgIGZvciAodmFyIGsgaW4gbGF5ZXJzKSB7XG5cdCAgICAgIGxheWVyc1trXS5yZW1vdmUoKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoZ2wpIHtcblx0ICAgICAgZ2wudmlld3BvcnQoMCwgMCwgY29udGV4dC53aWR0aCAqIDIsIGNvbnRleHQuaGVpZ2h0ICogMik7XG5cdCAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXHRcblx0ICAgICAgdmFyIGdsX2xvc2UgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuXHQgICAgICBnbF9sb3NlICYmIGdsX2xvc2UubG9zZUNvbnRleHQoKTtcblx0ICAgIH1cblx0XG5cdCAgICByZW1vdmVFdnRzKGNhbnZhcywgem9vbWV2dHMpO1xuXHRcblx0ICAgIGV2ZW50cy5kaXNhYmxlKCk7XG5cdCAgICB0ZXh0cyAmJiB0ZXh0cy5yZW1vdmUoKTtcblx0XG5cdCAgICByZW1vdmVkID0gdHJ1ZTtcblx0ICB9O1xuXHRcblx0ICB2YXIgbGFzdF92aWV3ID0ge307XG5cdCAgZnVuY3Rpb24gY2hlY2tDaGFuZ2VWaWV3cG9ydCgpIHtcblx0ICAgIHZhciBpc19jaGFuZ2UgPSBmYWxzZTtcblx0ICAgIGlmIChsYXN0X3ZpZXcpIHtcblx0ICAgICAgZm9yICh2YXIgayBpbiB2aWV3KSB7XG5cdCAgICAgICAgaWYgKGxhc3Rfdmlld1trXSAhPT0gdmlld1trXSkgaXNfY2hhbmdlID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgX3V0aWxzMi5kZWZhdWx0LmV4dGVuZChsYXN0X3ZpZXcsIHZpZXcpO1xuXHRcblx0ICAgIGlmIChpc19jaGFuZ2UpIHtcblx0ICAgICAgb3B0aW9ucy5vbkNoYW5nZVZpZXdwb3J0ICYmIG9wdGlvbnMub25DaGFuZ2VWaWV3cG9ydCh2aWV3KTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZSkge31cblx0XG5cdCAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG5cdCAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgIHZhciBzaXplID0gTWF0aC5taW4oMS4wLCB2aWV3LnNpemUgKiAoMSArIDAuMDAxICogKGUuZGVsdGFNb2RlID8gMzMgOiAxKSAqIGUuZGVsdGFZKSk7XG5cdCAgICB2YXIgZGVsdGEgPSBzaXplIC0gdmlldy5zaXplO1xuXHRcblx0ICAgIGlmICghb3B0aW9ucy5wYXNzaXZlRXZ0cykge1xuXHQgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIG9sZHNpemUgPSB2aWV3LnNpemU7XG5cdCAgICB2YXIgb2xkeCA9IHZpZXcueDtcblx0ICAgIHZhciBvbGR5ID0gdmlldy55O1xuXHRcblx0ICAgIHZpZXcuc2l6ZSA9IHNpemU7XG5cdCAgICB2aWV3LnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxIC0gc2l6ZSwgdmlldy54IC0gZGVsdGEgKiAoZS5jbGllbnRYIC0gcmVjdC5sZWZ0KSAvIGNhbnZhcy53aWR0aCkpO1xuXHQgICAgdmlldy55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSAtIHNpemUsIHZpZXcueSAtIGRlbHRhICogKDEgLSAoZS5jbGllbnRZIC0gcmVjdC50b3ApIC8gY2FudmFzLmhlaWdodCkpKTtcblx0XG5cdCAgICBpZiAob3B0aW9ucy5vblpvb20gJiYgb3B0aW9ucy5vblpvb20odmlldykgPT09IGZhbHNlKSB7XG5cdCAgICAgIHZpZXcuc2l6ZSA9IG9sZHNpemU7XG5cdCAgICAgIHZpZXcueCA9IG9sZHg7XG5cdCAgICAgIHZpZXcueSA9IG9sZHk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0XG5cdCAgICBjaGVja0NoYW5nZVZpZXdwb3J0KCk7XG5cdFxuXHQgICAgdGhpcy5kcmF3KCk7XG5cdCAgfVxuXHRcblx0ICB2YXIgbGFzdFVwVGltZSA9IDA7XG5cdCAgZnVuY3Rpb24gb25Nb3VzZURvd24oZG93bmUpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHRcblx0ICAgIGlmIChkb3duZS53aGljaCAhPT0gMSkgcmV0dXJuOyAvL2NhdGNoIG9ubHkgMSAtIGxlZnQgbW91c2UgYnV0dG9uXG5cdFxuXHQgICAgdmFyIHBhcnNlVG91Y2hFdnRzID0gZnVuY3Rpb24gcGFyc2VUb3VjaEV2dHMoZSkge1xuXHQgICAgICBpZiAoIWUudG91Y2hlcykgcmV0dXJuIGU7XG5cdFxuXHQgICAgICB2YXIgeCA9IDAsXG5cdCAgICAgICAgICB5ID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB4ICs9IGUudG91Y2hlc1tpXS5jbGllbnRYO3kgKz0gZS50b3VjaGVzW2ldLmNsaWVudFk7XG5cdCAgICAgIH1cblx0ICAgICAgZS5jbGllbnRYID0geCAvIGUudG91Y2hlcy5sZW5ndGg7XG5cdCAgICAgIGUuY2xpZW50WSA9IHkgLyBlLnRvdWNoZXMubGVuZ3RoO1xuXHRcblx0ICAgICAgcmV0dXJuIGU7XG5cdCAgICB9O1xuXHRcblx0ICAgIGRvd25lID0gcGFyc2VUb3VjaEV2dHMoZG93bmUpO1xuXHRcblx0ICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aCAvIHZpZXcuc2l6ZTtcblx0ICAgIHZhciBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdmlldy5zaXplO1xuXHQgICAgdmFyIHN4ID0gZG93bmUuY2xpZW50WDtcblx0ICAgIHZhciBzeSA9IGRvd25lLmNsaWVudFk7XG5cdCAgICB2YXIgZHggPSB2aWV3LnggKyBzeCAvIHdpZHRoO1xuXHQgICAgdmFyIGR5ID0gc3kgLyBoZWlnaHQgLSB2aWV3Lnk7XG5cdCAgICB2YXIgb2QgPSBvcHRpb25zLm9uRHJhZztcblx0ICAgIHZhciBkcmFnZ2VkID0gdm9pZCAwLFxuXHQgICAgICAgIGN1c3RvbSA9IHZvaWQgMDtcblx0ICAgIHZhciBwYW5uaW5nID0gdHJ1ZTtcblx0ICAgIHZhciB6b29taW5nID0gZmFsc2U7XG5cdCAgICB2YXIgZXZ0cyA9IHZvaWQgMDtcblx0XG5cdCAgICB2YXIgb3JpZ2Rpc3QgPSB2b2lkIDA7XG5cdCAgICBpZiAoKGRvd25lLnRvdWNoZXMgfHwgW10pLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICB2YXIgbXggPSBkb3duZS50b3VjaGVzWzBdLmNsaWVudFggLSBkb3duZS50b3VjaGVzWzFdLmNsaWVudFgsXG5cdCAgICAgICAgICBteSA9IGRvd25lLnRvdWNoZXNbMF0uY2xpZW50WSAtIGRvd25lLnRvdWNoZXNbMV0uY2xpZW50WTtcblx0ICAgICAgb3JpZ2Rpc3QgPSBNYXRoLnNxcnQobXggKiBteCArIG15ICogbXkpO1xuXHQgICAgICB6b29taW5nID0gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgZHJhZyA9IGZ1bmN0aW9uIGRyYWcoZSkge1xuXHQgICAgICBlID0gcGFyc2VUb3VjaEV2dHMoZSk7XG5cdFxuXHQgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggIT0gMSkgcGFubmluZyA9IGZhbHNlO1xuXHRcblx0ICAgICAgaWYgKGRyYWdnZWQpIHtcblx0ICAgICAgICBpZiAocGFubmluZykge1xuXHQgICAgICAgICAgaWYgKGN1c3RvbSkge1xuXHQgICAgICAgICAgICBvZC5kcmFnICYmIG9kLmRyYWcoZSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2aWV3LnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxIC0gdmlldy5zaXplLCBkeCAtIGUuY2xpZW50WCAvIHdpZHRoKSk7XG5cdCAgICAgICAgICAgIHZpZXcueSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEgLSB2aWV3LnNpemUsIGUuY2xpZW50WSAvIGhlaWdodCAtIGR5KSk7XG5cdCAgICAgICAgICAgIGNoZWNrQ2hhbmdlVmlld3BvcnQoKTtcblx0ICAgICAgICAgICAgX3RoaXMyLmRyYXcoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHggPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHkgPSB2b2lkIDA7XG5cdCAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgeCA9IGUudG91Y2hlc1swXS5jbGllbnRYO3kgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgeCA9IGUuY2xpZW50WDt5ID0gZS5jbGllbnRZO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIF9teCA9IHggLSBzeDtcblx0ICAgICAgICB2YXIgX215ID0geSAtIHN5O1xuXHRcblx0ICAgICAgICBpZiAoX214ICogX214ICsgX215ICogX215ID4gOCkge1xuXHQgICAgICAgICAgZHJhZ2dlZCA9IHRydWU7XG5cdCAgICAgICAgICBjdXN0b20gPSBvZCAmJiBvZC5zdGFydChkb3duZSk7XG5cdCAgICAgICAgICBjdXN0b20gJiYgb2QuZHJhZyAmJiBvZC5kcmFnKGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoIW9wdGlvbnMucGFzc2l2ZUV2dHMpIHtcblx0ICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIHVwID0gZnVuY3Rpb24gdXAoZSkge1xuXHQgICAgICBlID0gcGFyc2VUb3VjaEV2dHMoZSk7XG5cdFxuXHQgICAgICBjdXN0b20gJiYgb2Quc3RvcCAmJiBvZC5zdG9wKGUpO1xuXHRcblx0ICAgICAgaWYgKCFkcmFnZ2VkKSB7XG5cdCAgICAgICAgb3B0aW9ucy5vbkNsaWNrICYmIG9wdGlvbnMub25DbGljayhlKTtcblx0XG5cdCAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdFVwVGltZSA8IDI1MCkge1xuXHQgICAgICAgICAgb3B0aW9ucy5vbkRibENsaWNrICYmIG9wdGlvbnMub25EYmxDbGljayhlKTtcblx0ICAgICAgICAgIGxhc3RVcFRpbWUgPSAwO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBsYXN0VXBUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICByZW1vdmVFdnRzKHdpbmRvdywgZXZ0cyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciB6b29tID0gZnVuY3Rpb24gem9vbShlKSB7XG5cdCAgICAgIGUgPSBwYXJzZVRvdWNoRXZ0cyhlKTtcblx0XG5cdCAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PSAyKSB7XG5cdCAgICAgICAgdmFyIF9teDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIGUudG91Y2hlc1sxXS5jbGllbnRYLFxuXHQgICAgICAgICAgICBfbXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBlLnRvdWNoZXNbMV0uY2xpZW50WTtcblx0ICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydChfbXgyICogX214MiArIF9teTIgKiBfbXkyKTtcblx0ICAgICAgICBlLmRlbHRhWSA9IC0oZGlzdCAtIG9yaWdkaXN0KSAqIDU7XG5cdCAgICAgICAgb25XaGVlbFRoaXMoZSk7XG5cdCAgICAgICAgb3JpZ2Rpc3QgPSBkaXN0O1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIGFkZEV2dHMod2luZG93LCBldnRzID0ge1xuXHQgICAgICAnbW91c2V1cCc6IHVwLFxuXHQgICAgICAndG91Y2hlbmQnOiB1cCxcblx0ICAgICAgJ3RvdWNoY2FuY2VsJzogdXAsXG5cdCAgICAgICdtb3VzZW1vdmUnOiB6b29taW5nID8gem9vbSA6IGRyYWcsXG5cdCAgICAgICd0b3VjaG1vdmUnOiB6b29taW5nID8gem9vbSA6IGRyYWdcblx0ICAgIH0pO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5pbWFnZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChjaGVja1JlbW92ZWQoKSkgcmV0dXJuO1xuXHRcblx0ICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG5cdCAgfTtcblx0XG5cdCAgdGhpcy5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybjtcblx0XG5cdCAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGg7XG5cdCAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodDtcblx0ICB9O1xuXHRcblx0ICB0aGlzLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHZpZXc7XG5cdCAgfTtcblx0XG5cdCAgdGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgICBpZiAoY2hlY2tSZW1vdmVkKCkpIHJldHVybjtcblx0XG5cdCAgICBfdXRpbHMyLmRlZmF1bHQuZXh0ZW5kKHZpZXcsIHYpO1xuXHRcblx0ICAgIGNoZWNrQ2hhbmdlVmlld3BvcnQoKTtcblx0ICB9O1xuXHRcblx0ICB0aGlzLnJlc2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBfdGhpcy5zZXRWaWV3cG9ydCh7IHNpemU6IDEsIHg6IDAsIHk6IDAgfSk7XG5cdCAgfTtcblx0XG5cdCAgLy9leHBvc2UgdGhlc2UgbWV0aG9kcyBmcm9tIGxheWVyIGludG8gdGhpcyBjbGFzc1xuXHQgIFsndXBkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cdCAgICAoZnVuY3Rpb24gKG1ldGhvZCwgc2VsZikge1xuXHQgICAgICBzZWxmW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgICAgICAgZm9yICh2YXIgayBpbiBsYXllcnMpIHtcblx0ICAgICAgICAgIHZhciBsID0gbGF5ZXJzW2tdO1xuXHQgICAgICAgICAgbFttZXRob2RdLmFwcGx5KGwsIGFyZ3MpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIHNlbGY7XG5cdCAgICAgIH07XG5cdCAgICB9KShtZXRob2QsIHNlbGYpO1xuXHQgIH0pO1xuXHRcblx0ICBpZiAoZ2wgPSBnZXRDb250ZXh0KGNhbnZhcykpIHtcblx0ICAgIGdsLmNsZWFyQ29sb3IoYmFja2dyb3VuZENvbG9yLnIsIGJhY2tncm91bmRDb2xvci5nLCBiYWNrZ3JvdW5kQ29sb3IuYiwgYmFja2dyb3VuZENvbG9yLmEpO1xuXHQgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG5cdCAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FKTtcblx0ICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cdCAgfVxuXHRcblx0ICB2aWV3ID0geyBzaXplOiAxLCB4OiAwLCB5OiAwIH07XG5cdFxuXHQgIHRoaXMucmVzaXplKCk7XG5cdFxuXHQgIHRleHR1cmVzID0gbmV3IF90ZXh0dXJlczIuZGVmYXVsdChldmVudHMsIG9uTG9hZCk7XG5cdCAgZmlsZXMgPSBuZXcgX2ZpbGVzMi5kZWZhdWx0KGV2ZW50cywgb25Mb2FkKTtcblx0ICB0ZXh0cyA9IGdsICYmIG5ldyBfdGV4dHMyLmRlZmF1bHQoZ2wsIGZpbGVzLCB0ZXh0dXJlcyk7XG5cdCAgbGF5ZXJzLm1haW4gPSBuZXcgX2xheWVyMi5kZWZhdWx0KGNhbnZhcywgY29udGV4dCwgdmlldywgZ2wsIHRleHR1cmVzLCBmaWxlcywgdGV4dHMsIGV2ZW50cywgb3B0aW9ucywgYmFja2dyb3VuZENvbG9yLCBub2RlU3R5bGUsIGVkZ2VTdHlsZSwgZ2V0U2l6ZSwgZ2V0Tm9kZVNpemUsIGdldExhYmVsU2l6ZSwgZ2V0TGFiZWxIaWRlU2l6ZSwgZ2V0Tm9kZXNDbnQsIGdldEVkZ2VzQ250LCBvblJlZHJhdywgb25Mb2FkKTtcblx0XG5cdCAgaWYgKCFnbCkgY29uc29sZS53YXJuKFwiQ2Fubm90IGluaXRpYWxpemUgV2ViR0wgY29udGV4dFwiKTtcblx0fTtcblx0XG5cdGNjTmV0Vml6LmlzV2ViR0xTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuICEhZ2V0Q29udGV4dChzQ2FudmFzKTtcblx0fTtcblx0XG5cdGNjTmV0Vml6LmNvbG9yID0gX2NvbG9yMi5kZWZhdWx0O1xuXHRjY05ldFZpei5zcGF0aWFsU2VhcmNoID0gX3NwYXRpYWxTZWFyY2gyLmRlZmF1bHQ7XG5cdGNjTmV0Vml6LmxheW91dCA9IF9sYXlvdXQyLmRlZmF1bHQ7XG5cdGNjTmV0Vml6LmNvbG9yID0gX2NvbG9yMi5kZWZhdWx0O1xuXHRcblx0d2luZG93LmNjTmV0Vml6ID0gY2NOZXRWaXo7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGNjTmV0Vml6O1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNhbnZhcywgY29udGV4dCwgdmlldywgZ2wsIHRleHR1cmVzLCBmaWxlcywgdGV4dHMsIGV2ZW50cywgb3B0aW9ucywgYmFja2dyb3VuZENvbG9yLCBub2RlU3R5bGUsIGVkZ2VTdHlsZSwgZ2V0U2l6ZSwgZ2V0Tm9kZVNpemUsIGdldExhYmVsU2l6ZSwgZ2V0TGFiZWxIaWRlU2l6ZSwgZ2V0Tm9kZXNDbnQsIGdldEVkZ2VzQ250LCBvblJlZHJhdywgb25Mb2FkKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgIGdldE5vZGVzQ250ID0gZ2V0Tm9kZXNDbnQgfHwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdCAgICB9O1xuXHQgICAgZ2V0RWRnZXNDbnQgPSBnZXRFZGdlc0NudCB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLmVkZ2VzLmxlbmd0aDtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5yZWRyYXcgPSBvblJlZHJhdyB8fCBmdW5jdGlvbiAoKSB7fTtcblx0XG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgIG9wdGlvbnMuc3R5bGVzID0gb3B0aW9ucy5zdHlsZXMgfHwge307XG5cdFxuXHQgICAgdmFyIG5vZGVzRmlsbGVyID0gZnVuY3Rpb24gbm9kZXNGaWxsZXIoc3R5bGUpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2LCBlLCBpViwgaUkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB4ID0gZS54O1xuXHQgICAgICAgICAgICAgICAgdmFyIHkgPSBlLnk7XG5cdCAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYucG9zaXRpb24sIGlWLCB4LCB5LCB4LCB5LCB4LCB5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi50ZXh0dXJlQ29vcmQsIGlWLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxKTtcblx0ICAgICAgICAgICAgICAgIGlmICh2LmNvbG9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlLmNvbG9yO1xuXHQgICAgICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQuY29sb3JzKHYuY29sb3IsIGlWLCBjLCBjLCBjLCBjKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQucXVhZCh2LmluZGljZXMsIGlWLCBpSSk7XG5cdCAgICAgICAgICAgIH0gfTtcblx0ICAgIH07XG5cdCAgICB2YXIgbGFiZWxzRmlsbGVyID0gZnVuY3Rpb24gbGFiZWxzRmlsbGVyKHN0eWxlKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHlsZSkge1xuXHQgICAgICAgICAgICB2YXIgdGV4dEVuZ2luZSA9IHRleHRzLmdldEVuZ2luZShzdHlsZS5mb250KTtcblx0XG5cdCAgICAgICAgICAgIHRleHRFbmdpbmUuc2V0Rm9udChzdHlsZS5mb250KTtcblx0XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2LCBlLCBpViwgaUkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGUueDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGUueTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRleHRFbmdpbmUuZ2V0KGUubGFiZWwgfHwgXCJcIiwgeCwgeSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyssIGlWICs9IDQsIGlJICs9IDYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBwYXJ0c1tpXTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi5wb3NpdGlvbiwgaVYsIHgsIHksIHgsIHksIHgsIHksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYucmVsYXRpdmUsIGlWLCBjLmR4LCBjLmR5LCBjLndpZHRoICsgYy5keCwgYy5keSwgYy53aWR0aCArIGMuZHgsIGMuaGVpZ2h0ICsgYy5keSwgYy5keCwgYy5oZWlnaHQgKyBjLmR5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2LnRleHR1cmVDb29yZCwgaVYsIGMubGVmdCwgYy5ib3R0b20sIGMucmlnaHQsIGMuYm90dG9tLCBjLnJpZ2h0LCBjLnRvcCwgYy5sZWZ0LCBjLnRvcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQucXVhZCh2LmluZGljZXMsIGlWLCBpSSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUodiwgZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0RW5naW5lLnN0ZXBzKGUubGFiZWwgfHwgXCJcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfShzdHlsZSk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoYSwgYikge1xuXHQgICAgICAgIHZhciB4ID0gYi54IC0gYS54O1xuXHQgICAgICAgIHZhciB5ID0gYi55IC0gYS55O1xuXHQgICAgICAgIHZhciBzYyA9IDEgLyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdCAgICAgICAgcmV0dXJuIHsgeDogc2MgKiB4LCB5OiBzYyAqIHkgfTtcblx0ICAgIH07XG5cdFxuXHQgICAgdmFyIGR4ID0gTWF0aC5jb3MoMC45KTtcblx0ICAgIHZhciBkeSA9IE1hdGguc2luKDAuOSk7XG5cdFxuXHQgICAgdmFyIGN0MSA9IHt9LFxuXHQgICAgICAgIGN0MiA9IHt9LFxuXHQgICAgICAgIGN0ID0ge307XG5cdCAgICB2YXIgc2V0VmVydGljZUN1cnZlU2hpZnQgPSBmdW5jdGlvbiBzZXRWZXJ0aWNlQ3VydmVTaGlmdCh2LCBpViwgcywgdCkge1xuXHQgICAgICAgIHZhciBjc3ggPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGNzeSA9IHZvaWQgMCxcblx0ICAgICAgICAgICAgY3R4ID0gdm9pZCAwLFxuXHQgICAgICAgICAgICBjdHkgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGNpc3ggPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGNpc3kgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHNpc3kgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGNpdHggPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGNpdHkgPSB2b2lkIDA7XG5cdCAgICAgICAgX2dlb211dGlsczIuZGVmYXVsdC5nZXRDdXJ2ZVNoaWZ0KHQuZSwgY3QxKTtcblx0ICAgICAgICBjdHggPSBjdDEueDtcblx0ICAgICAgICBjdHkgPSBjdDEueTtcblx0ICAgICAgICBjaXR4ID0gY3QxLmN4O1xuXHQgICAgICAgIGNpdHkgPSBjdDEuY3k7XG5cdFxuXHQgICAgICAgIF9nZW9tdXRpbHMyLmRlZmF1bHQuZ2V0Q3VydmVTaGlmdChzLmUsIGN0Mik7XG5cdCAgICAgICAgY3N4ID0gY3QyLng7XG5cdCAgICAgICAgY3N5ID0gY3QyLnk7XG5cdCAgICAgICAgY2lzeCA9IGN0Mi5jeDtcblx0ICAgICAgICBjaXN5ID0gY3QyLmN5O1xuXHRcblx0ICAgICAgICB2LmN1cnZlU2hpZnQgJiYgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2LmN1cnZlU2hpZnQsIGlWLCAtY3N5LCBjc3gsIC1jc3ksIGNzeCwgLWN0eSwgY3R4LCAtY3R5LCBjdHgpO1xuXHQgICAgICAgIHYuY2lyY2xlU2hpZnQgJiYgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2LmNpcmNsZVNoaWZ0LCBpViwgLWNpc3ksIGNpc3gsIC1jaXN5LCBjaXN4LCAtY2l0eSwgY2l0eCwgLWNpdHksIGNpdHgpO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgZWRnZXNGaWxsZXIgPSB7XG5cdCAgICAgICAgJ2xpbmVzJzogZnVuY3Rpb24gbGluZXMoc3R5bGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYsIGUsIGlWLCBpSSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlU291cmNlKGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlVGFyZ2V0KGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHMueCAtIHQueDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBzLnkgLSB0Lnk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBub3JtYWxpemUocywgdCk7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHNldFZlcnRpY2VDdXJ2ZVNoaWZ0KHYsIGlWLCBzLCB0KTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2LnBvc2l0aW9uLCBpViwgcy54LCBzLnksIHMueCwgcy55LCB0LngsIHQueSwgdC54LCB0LnkpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi5sZW5ndGhTb0ZhciwgaVYsIDAsIDAsIDAsIDAsIGR4LCBkeSwgZHgsIGR5KTtcblx0ICAgICAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYubm9ybWFsLCBpViwgLWQueSwgZC54LCBkLnksIC1kLngsIGQueSwgLWQueCwgLWQueSwgZC54KTtcblx0ICAgICAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnF1YWQodi5pbmRpY2VzLCBpViwgaUkpO1xuXHQgICAgICAgICAgICAgICAgfSB9O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2N1cnZlcyc6IGZ1bmN0aW9uIGN1cnZlcyhzdHlsZSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgbnVtVmVydGljZXM6IDMsXG5cdCAgICAgICAgICAgICAgICBudW1JbmRpY2VzOiAzLFxuXHQgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodiwgZSwgaVYsIGlJKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VTb3VyY2UoZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VUYXJnZXQoZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gcy54IC0gdC54O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IHMueSAtIHQueTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IG5vcm1hbGl6ZShzLCB0KTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VmVydGljZUN1cnZlU2hpZnQodiwgaVYsIHMsIHQpO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYucG9zaXRpb24sIGlWLCBzLngsIHMueSwgMC41ICogKHQueCArIHMueCksIDAuNSAqICh0LnkgKyBzLnkpLCB0LngsIHQueSk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2Lmxlbmd0aFNvRmFyLCBpViwgMCwgMCwgZHggLyAyLCBkeSAvIDIsIGR4LCBkeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2Lm5vcm1hbCwgaVYsIDAsIDAsIGQueSwgLWQueCwgMCwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2LmN1cnZlLCBpViwgMSwgMSwgMC41LCAwLjAsIDAsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQuaW5kaWNlcyh2LmluZGljZXMsIGlWLCBpSSwgMCwgMSwgMik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnY2lyY2xlcyc6IGZ1bmN0aW9uIGNpcmNsZXMoc3R5bGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYsIGUsIGlWLCBpSSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlU291cmNlKGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkID0gcy55IDwgMC41ID8gMSA6IC0xO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeGRpZmYxID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeWRpZmYxID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeGRpZmYyID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeWRpZmYyID0gZDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeGRpZmYzID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeWRpZmYzID0gMS4yNSAqIGQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHhkaWZmNCA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHlkaWZmNCA9IDEuNSAqIGQ7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHNldFZlcnRpY2VDdXJ2ZVNoaWZ0KHYsIGlWLCBzLCBzKTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC52ZXJ0aWNlcyh2LnBvc2l0aW9uLCBpViwgcy54LCBzLnksIHMueCwgcy55LCBzLngsIHMueSwgcy54LCBzLnkpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi5sZW5ndGhTb0ZhciwgaVYsIHhkaWZmMSwgeWRpZmYxLCB4ZGlmZjIsIHlkaWZmMiwgeGRpZmYzLCB5ZGlmZjMsIHhkaWZmNCwgeWRpZmY0KTtcblx0ICAgICAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYubm9ybWFsLCBpViwgMCwgMCwgMSwgZCwgMCwgMS4yNSAqIGQsIC0xLCBkKTtcblx0ICAgICAgICAgICAgICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYuY3VydmUsIGlWLCAxLCAxLCAwLjUsIDAsIDAsIDAsIDAuNSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC5xdWFkKHYuaW5kaWNlcywgaVYsIGlJKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBfc2V0ID0gZnVuY3Rpb24gX3NldCh2LCBlLCBzLCB0LCBpViwgaUksIGR4LCBkeSkge1xuXHQgICAgICAgIHZhciB0eCA9IHQueDtcblx0ICAgICAgICB2YXIgdHkgPSB0Lnk7XG5cdFxuXHQgICAgICAgIHZhciBvZmZzZXRNdWwgPSB2b2lkIDA7XG5cdCAgICAgICAgdmFyIGN0eCA9IHZvaWQgMCxcblx0ICAgICAgICAgICAgY3R5ID0gdm9pZCAwLFxuXHQgICAgICAgICAgICBjaXR4ID0gdm9pZCAwLFxuXHQgICAgICAgICAgICBjaXR5ID0gdm9pZCAwO1xuXHRcblx0ICAgICAgICBfZ2VvbXV0aWxzMi5kZWZhdWx0LmdldEN1cnZlU2hpZnQodC5lLCBjdCk7XG5cdCAgICAgICAgY3R4ID0gY3QueDtcblx0ICAgICAgICBjdHkgPSBjdC55O1xuXHQgICAgICAgIGNpdHggPSBjdC5jeDtcblx0ICAgICAgICBjaXR5ID0gY3QuY3k7XG5cdFxuXHQgICAgICAgIGlmICh0LmlzX2VkZ2UpIHtcblx0ICAgICAgICAgICAgLy9pZiB0YXJnZXQgaXMgZWRnZSwgZGlzYWJsZSBub2RlIG9mZnNldCBmb3IgYXJyb3dcblx0ICAgICAgICAgICAgLy9ub3JtYWwgb2YgdGhhdCBlZGdlXG5cdCAgICAgICAgICAgIG9mZnNldE11bCA9IDA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgb2Zmc2V0TXVsID0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdi5jdXJ2ZVNoaWZ0ICYmIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi5jdXJ2ZVNoaWZ0LCBpViwgLWN0eSwgY3R4LCAtY3R5LCBjdHgsIC1jdHksIGN0eCwgLWN0eSwgY3R4KTtcblx0ICAgICAgICB2LmNpcmNsZVNoaWZ0ICYmIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi5jaXJjbGVTaGlmdCwgaVYsIC1jaXR5LCBjaXR4LCAtY2l0eSwgY2l0eCwgLWNpdHksIGNpdHgsIC1jaXR5LCBjaXR4KTtcblx0XG5cdCAgICAgICAgX3ByaW1pdGl2ZTIuZGVmYXVsdC5zaW5nbGVzKHYub2Zmc2V0TXVsLCBpViwgb2Zmc2V0TXVsLCBvZmZzZXRNdWwsIG9mZnNldE11bCwgb2Zmc2V0TXVsKTtcblx0ICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnZlcnRpY2VzKHYucG9zaXRpb24sIGlWLCB0eCwgdHksIHR4LCB0eSwgdHgsIHR5LCB0eCwgdHkpO1xuXHQgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi5kaXJlY3Rpb24sIGlWLCBkeCwgZHksIGR4LCBkeSwgZHgsIGR5LCBkeCwgZHkpO1xuXHQgICAgICAgIF9wcmltaXRpdmUyLmRlZmF1bHQudmVydGljZXModi50ZXh0dXJlQ29vcmQsIGlWLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxKTtcblx0ICAgICAgICBfcHJpbWl0aXZlMi5kZWZhdWx0LnF1YWQodi5pbmRpY2VzLCBpViwgaUkpO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgYXJyb3dGaWxsZXIgPSB7XG5cdCAgICAgICAgbGluZUFycm93czogZnVuY3Rpb24gbGluZUFycm93cyhzdHlsZSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodiwgZSwgaVYsIGlJKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VTb3VyY2UoZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VUYXJnZXQoZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBub3JtYWxpemUocywgdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3NldCh2LCBlLCBzLCB0LCBpViwgaUksIGQueCwgZC55KTtcblx0ICAgICAgICAgICAgICAgIH0gfTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGN1cnZlQXJyb3dzOiBmdW5jdGlvbiBjdXJ2ZUFycm93cyhzdHlsZSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodiwgZSwgaVYsIGlJKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VTb3VyY2UoZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VUYXJnZXQoZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXQodiwgZSwgcywgdCwgaVYsIGlJLCAwLjUgKiAodC54IC0gcy54KSwgMC41ICogKHQueSAtIHMueSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgY2lyY2xlQXJyb3dzOiBmdW5jdGlvbiBjaXJjbGVBcnJvd3Moc3R5bGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYsIGUsIGlWLCBpSSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlVGFyZ2V0KGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzID0gdDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NldCh2LCBlLCBzLCB0LCBpViwgaUksIHQueCA8IDAuNSA/IGR4IDogLWR4LCB0LnkgPCAwLjUgPyAtZHkgOiBkeSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICB0aGlzLmdldEN1cnJlbnRTcGF0aWFsU2VhcmNoID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoc3BhdGlhbFNlYXJjaCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHNwYXRpYWxTZWFyY2ggPSBuZXcgX3NwYXRpYWxTZWFyY2gyLmRlZmF1bHQoY29udGV4dCwgdGV4dHMsIG9wdGlvbnMsIFtdLCB7fSwgW10sIHt9LCBbXSwge30sIFtdLCB7fSwgbm9ybWFsaXplLCBub2RlU3R5bGUsIGdldExhYmVsU2l6ZSwgZ2V0TGFiZWxIaWRlU2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzcGF0aWFsU2VhcmNoO1xuXHQgICAgfTtcblx0XG5cdCAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcblx0ICAgIHZhciBlZGdlVHlwZXMgPSB2b2lkIDA7XG5cdCAgICB2YXIgZWRnZVBvc2VzID0gdm9pZCAwO1xuXHRcblx0ICAgIHZhciBzcGF0aWFsU2VhcmNoID0gdW5kZWZpbmVkO1xuXHRcblx0ICAgIHZhciBsdmwgPSAwO1xuXHQgICAgLy9tYWtlIHN1cmUgZXZlcnl0aGluZyAoZmlsZXMgYW5kIHRleHR1cmVzKSBhcmUgbG9hZCwgaWYgbm90LCByZWRyYXcgdGhlIHdob2xlIGdyYXBoIGFmdGVyIHRoZXkgYmVjYW1lXG5cdCAgICB2YXIgc2V0X2VuZCA9IGZ1bmN0aW9uIHNldF9lbmQoKSB7XG5cdCAgICAgICAgdmFyIGVuYWJsZUxhenlSZWRyYXcgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiByZXNldChwKSB7XG5cdCAgICAgICAgICAgIGlmIChlbmFibGVMYXp5UmVkcmF3KSBfdGhpcy5zZXQoX3RoaXMubm9kZXMsIF90aGlzLmVkZ2VzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZpbGVzLm9uTG9hZChyZXNldCk7XG5cdCAgICAgICAgdGV4dHVyZXMub25Mb2FkKHJlc2V0KTtcblx0ICAgICAgICBlbmFibGVMYXp5UmVkcmF3ID0gdHJ1ZTtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAobm9kZXMsIGVkZ2VzLCBsYXlvdXQsIGxheW91dF9vcHRpb25zKSB7XG5cdCAgICAgICAgcmVtb3ZlZE5vZGVzID0gMDtcblx0ICAgICAgICByZW1vdmVkRWRnZXMgPSAwO1xuXHRcblx0ICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXMgPSBub2RlcyB8fCBbXTtcblx0ICAgICAgICB0aGlzLmVkZ2VzID0gZWRnZXMgPSBlZGdlcyA/IFtdLmNvbmNhdChlZGdlcykgOiBbXTtcblx0XG5cdCAgICAgICAgc3BhdGlhbFNlYXJjaCA9IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgICAgdmFyIGxpbmVzID0gW10sXG5cdCAgICAgICAgICAgIGN1cnZlcyA9IFtdLFxuXHQgICAgICAgICAgICBjaXJjbGVzID0gW107XG5cdFxuXHQgICAgICAgIC8vdGFuc2xhdGUgaW5kZXhlcyBpbnRvIG5vZGUgb2JqZWN0c1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnNvdXJjZSA9PSAnbnVtYmVyJykgZS5zb3VyY2UgPSBub2Rlc1tlLnNvdXJjZV07XG5cdFxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGUudGFyZ2V0ID09ICdudW1iZXInKSBlLnRhcmdldCA9IG5vZGVzW2UudGFyZ2V0XTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBnZXRJbmRleCA9IGZ1bmN0aW9uIGdldEluZGV4KGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGUudW5pcWlkIHx8IC1lLmluZGV4IHx8IC1lLm5pZHg7XG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBub2Rlc1tfaV0uaW5kZXggPSBfaTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgaiA9IG5vZGVzLmxlbmd0aCArIDEwOyBfaTIgPCBlZGdlcy5sZW5ndGg7IF9pMisrLCBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGVkZ2VzW19pMl0ubmlkeCA9IGo7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGVkZ2VUeXBlcyA9IFtdO1xuXHQgICAgICAgICAgICBlZGdlUG9zZXMgPSBuZXcgVWludDMyQXJyYXkoZWRnZXMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgdmFyIGR1bW15c2QgPSB7IGs6ICdfJywga0Fycm93OiAnXycsIGQ6IFtdIH07XG5cdCAgICAgICAgICAgIHZhciBjaXJjbGVzZCA9IHsgazogJ2NpcmNsZXMnLCBrQXJyb3c6ICdjaXJjbGVBcnJvd3MnLCBkOiBjaXJjbGVzIH07XG5cdCAgICAgICAgICAgIHZhciBsaW5lc2QgPSB7IGs6ICdsaW5lcycsIGtBcnJvdzogJ2xpbmVBcnJvd3MnLCBkOiBsaW5lcyB9O1xuXHQgICAgICAgICAgICB2YXIgY3VydmVzZCA9IHsgazogJ2N1cnZlcycsIGtBcnJvdzogJ2N1cnZlQXJyb3dzJywgZDogY3VydmVzIH07XG5cdFxuXHQgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXAgPSB7fTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2UgPSBlZGdlc1tfaTNdO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2kgPSBnZXRJbmRleChfZS5zb3VyY2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IGdldEluZGV4KF9lLnRhcmdldCk7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIChtYXBbc2ldIHx8IChtYXBbc2ldID0ge30pKVt0aV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGVkZ2VzLmxlbmd0aDsgX2k0KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdm9pZCAwLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZTIgPSBlZGdlc1tfaTRdO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3NpID0gZ2V0SW5kZXgoX2UyLnNvdXJjZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF90aSA9IGdldEluZGV4KF9lMi50YXJnZXQpO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGR1bW15c2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKF9zaSA9PT0gX3RpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9lMi50ID0gMjsgLy9jaXJjbGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gY2lyY2xlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNpcmNsZXNkO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gbWFwW190aV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtICYmIG1bX3NpXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2UyLnQgPSAxOyAvL2N1cnZlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBjdXJ2ZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gY3VydmVzZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lMi50ID0gMDsgLy9saW5lXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBsaW5lcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBsaW5lc2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWRnZVR5cGVzLnB1c2godCk7XG5cdCAgICAgICAgICAgICAgICAgICAgZWRnZVBvc2VzW19pNF0gPSB0LmQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKF9lMik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBlZGdlcy5sZW5ndGg7IF9pNSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9lMyA9IGVkZ2VzW19pNV07XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfc2kyID0gZ2V0SW5kZXgoX2UzLnNvdXJjZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF90aTIgPSBnZXRJbmRleChfZTMudGFyZ2V0KTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF90ID0gZHVtbXlzZDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX3NpMiAhPT0gX3RpMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdCA9IGxpbmVzZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2UzLnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKF9lMyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVkZ2VUeXBlcy5wdXNoKF90KTtcblx0ICAgICAgICAgICAgICAgICAgICBlZGdlUG9zZXNbX2k1XSA9IF90LmQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgaW5pdCgpO1xuXHRcblx0ICAgICAgICB2YXIgbm9kZXNQYXJ0cyA9ICgwLCBfcHJpbWl0aXZlVG9vbHMucGFydGl0aW9uQnlTdHlsZSkobm9kZXMpO1xuXHQgICAgICAgIHZhciBjaXJjbGVzUGFydHMgPSAoMCwgX3ByaW1pdGl2ZVRvb2xzLnBhcnRpdGlvbkJ5U3R5bGUpKGNpcmNsZXMpO1xuXHQgICAgICAgIHZhciBsaW5lc1BhcnRzID0gKDAsIF9wcmltaXRpdmVUb29scy5wYXJ0aXRpb25CeVN0eWxlKShsaW5lcyk7XG5cdCAgICAgICAgdmFyIGN1cnZlc1BhcnRzID0gKDAsIF9wcmltaXRpdmVUb29scy5wYXJ0aXRpb25CeVN0eWxlKShjdXJ2ZXMpO1xuXHRcblx0ICAgICAgICB0aGlzLmdldEN1cnJlbnRTcGF0aWFsU2VhcmNoID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgaWYgKHNwYXRpYWxTZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgc3BhdGlhbFNlYXJjaCA9IG5ldyBfc3BhdGlhbFNlYXJjaDIuZGVmYXVsdChjb250ZXh0LCB0ZXh0cywgb3B0aW9ucywgbm9kZXMsIG5vZGVzUGFydHMsIGxpbmVzLCBsaW5lc1BhcnRzLCBjdXJ2ZXMsIGN1cnZlc1BhcnRzLCBjaXJjbGVzLCBjaXJjbGVzUGFydHMsIG5vcm1hbGl6ZSwgbm9kZVN0eWxlLCBnZXRMYWJlbFNpemUsIGdldExhYmVsSGlkZVNpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBzcGF0aWFsU2VhcmNoO1xuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIGxheW91dCAmJiBuZXcgX2xheW91dDIuZGVmYXVsdFtsYXlvdXRdKG5vZGVzLCBlZGdlcywgbGF5b3V0X29wdGlvbnMpLmFwcGx5KCkgJiYgX2xheW91dDIuZGVmYXVsdC5ub3JtYWxpemUobm9kZXMpO1xuXHRcblx0ICAgICAgICBpZiAoIWdsKSByZXR1cm47XG5cdFxuXHQgICAgICAgIHZhciB0cnlJbml0UHJpbWl0aXZlcyA9IGZ1bmN0aW9uIHRyeUluaXRQcmltaXRpdmVzKCkge1xuXHQgICAgICAgICAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlO1xuXHRcblx0ICAgICAgICAgICAgdmFyIGRlZmF1bHRBZGRlciA9IGZ1bmN0aW9uIGRlZmF1bHRBZGRlcihzZWN0aW9uLCBhZGRTZWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlY3Rpb24uc3R5bGUudGV4dHVyZSA9PT0gJ3N0cmluZycpIHNlY3Rpb24uc3R5bGUudGV4dHVyZSA9IHRleHR1cmVzLmdldChnbCwgc2VjdGlvbi5zdHlsZS50ZXh0dXJlLCBhZGRTZWN0aW9uKTtlbHNlIGFkZFNlY3Rpb24oKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdmFyIGxhYmVsQWRkZXIgPSBmdW5jdGlvbiBsYWJlbEFkZGVyKHNlY3Rpb24sIGFkZFNlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzbGYgPSAoc2VjdGlvbi5zdHlsZS5sYWJlbCB8fCB7fSkuZm9udCB8fCB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciB0ZXh0RW5naW5lID0gdGV4dHMuZ2V0RW5naW5lKHNsZik7XG5cdCAgICAgICAgICAgICAgICBzZWN0aW9uLnN0eWxlLnRleHR1cmUgPSB0ZXh0RW5naW5lLmdldFRleHR1cmUoc2xmLCBhZGRTZWN0aW9uKTtcblx0ICAgICAgICAgICAgfTtcblx0XG5cdCAgICAgICAgICAgIHZhciBpcyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgaXMgPSBub2Rlcy5sZW5ndGggJiYgIW5vZGVzWzBdLmNvbG9yO1xuXHQgICAgICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBzY2VuZS5ub2Rlcy5zZXQoZ2wsIG9wdGlvbnMuc3R5bGVzLCBkZWZhdWx0QWRkZXIsIGlzID8gbm9kZXMgOiBbXSwgaXMgPyBub2Rlc1BhcnRzIDoge30sIG5vZGVzRmlsbGVyKTtcblx0ICAgICAgICAgICAgaXMgPSBub2Rlcy5sZW5ndGggJiYgbm9kZXNbMF0uY29sb3I7XG5cdCAgICAgICAgICAgIGlzRGlydHkgPSBpc0RpcnR5IHx8IHNjZW5lLm5vZGVzQ29sb3JlZC5zZXQoZ2wsIG9wdGlvbnMuc3R5bGVzLCBkZWZhdWx0QWRkZXIsIGlzID8gbm9kZXMgOiBbXSwgaXMgPyBub2Rlc1BhcnRzIDoge30sIG5vZGVzRmlsbGVyKTtcblx0XG5cdCAgICAgICAgICAgIGlmIChub2RlU3R5bGUubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIHRleHRzLmNsZWFyKCk7XG5cdCAgICAgICAgICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBzY2VuZS5sYWJlbHNPdXRsaW5lLnNldChnbCwgb3B0aW9ucy5zdHlsZXMsIGxhYmVsQWRkZXIsIG5vZGVzLCBub2Rlc1BhcnRzLCBsYWJlbHNGaWxsZXIpO1xuXHQgICAgICAgICAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgc2NlbmUubGFiZWxzLnNldChnbCwgb3B0aW9ucy5zdHlsZXMsIGxhYmVsQWRkZXIsIG5vZGVzLCBub2Rlc1BhcnRzLCBsYWJlbHNGaWxsZXIpO1xuXHQgICAgICAgICAgICAgICAgdGV4dHMuYmluZCgpO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBzY2VuZS5saW5lcy5zZXQoZ2wsIG9wdGlvbnMuc3R5bGVzLCBkZWZhdWx0QWRkZXIsIGxpbmVzLCBsaW5lc1BhcnRzLCBlZGdlc0ZpbGxlci5saW5lcyk7XG5cdFxuXHQgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGlzRGlydHkgPSBpc0RpcnR5IHx8IHNjZW5lLmN1cnZlcy5zZXQoZ2wsIG9wdGlvbnMuc3R5bGVzLCBkZWZhdWx0QWRkZXIsIGN1cnZlcywgY3VydmVzUGFydHMsIGVkZ2VzRmlsbGVyLmN1cnZlcyk7XG5cdCAgICAgICAgICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBzY2VuZS5jaXJjbGVzLnNldChnbCwgb3B0aW9ucy5zdHlsZXMsIGRlZmF1bHRBZGRlciwgY2lyY2xlcywgY2lyY2xlc1BhcnRzLCBlZGdlc0ZpbGxlci5jaXJjbGVzKTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaWYgKGVkZ2VTdHlsZS5hcnJvdykge1xuXHQgICAgICAgICAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgc2NlbmUubGluZUFycm93cy5zZXQoZ2wsIG9wdGlvbnMuc3R5bGVzLCBkZWZhdWx0QWRkZXIsIGxpbmVzLCBsaW5lc1BhcnRzLCBhcnJvd0ZpbGxlci5saW5lQXJyb3dzKTtcblx0XG5cdCAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBzY2VuZS5jdXJ2ZUFycm93cy5zZXQoZ2wsIG9wdGlvbnMuc3R5bGVzLCBkZWZhdWx0QWRkZXIsIGN1cnZlcywgY3VydmVzUGFydHMsIGFycm93RmlsbGVyLmN1cnZlQXJyb3dzKTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgc2NlbmUuY2lyY2xlQXJyb3dzLnNldChnbCwgb3B0aW9ucy5zdHlsZXMsIGRlZmF1bHRBZGRlciwgY2lyY2xlcywgY2lyY2xlc1BhcnRzLCBhcnJvd0ZpbGxlci5jaXJjbGVBcnJvd3MpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICByZXR1cm4gaXNEaXJ0eTtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB3aGlsZSAodHJ5SW5pdFByaW1pdGl2ZXMoKSkge30gLy9sb29wIHVudGlsIHRoZXkgYXJlIG5vdCBkaXJ0eVxuXHQgICAgICAgIHNldF9lbmQoKTtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlLCBkYXRhKSB7XG5cdCAgICAgICAgaWYgKCFnbCkgcmV0dXJuO1xuXHQgICAgICAgIHNjZW5lW2VsZW1lbnRdLnVwZGF0ZShnbCwgYXR0cmlidXRlLCBkYXRhLCBmdW5jdGlvbiAoc3R5bGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYsIGUsIGlWKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcmltaXRpdmUyLmRlZmF1bHQuY29sb3JzKHYsIGlWLCBlLCBlLCBlLCBlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5maW5kID0gZnVuY3Rpb24gKHgsIHksIGRpc3QsIG5vZGVzLCBlZGdlcywgbGFiZWxzKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLmdldEN1cnJlbnRTcGF0aWFsU2VhcmNoKGNvbnRleHQpLmZpbmQoY29udGV4dCwgeCwgeSwgZGlzdCwgdmlldy5zaXplLCBub2RlcywgZWRnZXMsIGxhYmVscyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHRoaXMuZmluZEFyZWEgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIG5vZGVzLCBlZGdlcywgbGFiZWxzKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLmdldEN1cnJlbnRTcGF0aWFsU2VhcmNoKGNvbnRleHQpLmZpbmRBcmVhKGNvbnRleHQsIHgxLCB5MSwgeDIsIHkyLCB2aWV3LnNpemUsIG5vZGVzLCBlZGdlcywgbGFiZWxzKTtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy51cGRhdGVOb2RlID0gZnVuY3Rpb24gKG4sIGkpIHtcblx0ICAgICAgICBfdGhpcy5ub2Rlc1tpXSA9IG47XG5cdFxuXHQgICAgICAgIGlmIChzcGF0aWFsU2VhcmNoKSBzcGF0aWFsU2VhcmNoLnVwZGF0ZShjb250ZXh0LCAnbm9kZXMnLCBpLCBuKTtcblx0XG5cdCAgICAgICAgaWYgKCFnbCkgcmV0dXJuO1xuXHRcblx0ICAgICAgICAoX3RoaXMubm9kZXNbMF0uY29sb3IgPyBzY2VuZS5ub2Rlc0NvbG9yZWQgOiBzY2VuZS5ub2RlcykudXBkYXRlRWwoZ2wsIG4sIGksIG5vZGVzRmlsbGVyKTtcblx0ICAgICAgICBzY2VuZS5sYWJlbHMgJiYgc2NlbmUubGFiZWxzLnVwZGF0ZUVsKGdsLCBuLCBpLCBsYWJlbHNGaWxsZXIpO1xuXHQgICAgICAgIHNjZW5lLmxhYmVsc091dGxpbmUgJiYgc2NlbmUubGFiZWxzT3V0bGluZS51cGRhdGVFbChnbCwgbiwgaSwgbGFiZWxzRmlsbGVyKTtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy51cGRhdGVFZGdlID0gZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgICAgICB2YXIgdCA9IGVkZ2VUeXBlc1tpXTtcblx0ICAgICAgICB2YXIgcG9zID0gZWRnZVBvc2VzW2ldO1xuXHRcblx0ICAgICAgICB0LmRbcG9zXSA9IF90aGlzLmVkZ2VzW2ldID0gZTtcblx0XG5cdCAgICAgICAgaWYgKHNwYXRpYWxTZWFyY2gpIHNwYXRpYWxTZWFyY2gudXBkYXRlKGNvbnRleHQsIHQuaywgcG9zLCBlKTtcblx0XG5cdCAgICAgICAgaWYgKCFnbCkgcmV0dXJuO1xuXHRcblx0ICAgICAgICBzY2VuZVt0LmtdLnVwZGF0ZUVsKGdsLCBlLCBwb3MsIGVkZ2VzRmlsbGVyW3Qua10pO1xuXHQgICAgICAgIGlmIChlZGdlU3R5bGUuYXJyb3cpIHNjZW5lW3Qua0Fycm93XS51cGRhdGVFbChnbCwgZSwgcG9zLCBhcnJvd0ZpbGxlclt0LmtBcnJvd10pO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgcmVtb3ZlZE5vZGVzID0gMDtcblx0ICAgIHZhciByZW1vdmVkRWRnZXMgPSAwO1xuXHRcblx0ICAgIHZhciBmcmVlbm9kZSA9IHsgeDogLTEsIHk6IC0xLCB0aXRsZTogXCJcIiB9O1xuXHQgICAgdGhpcy5yZW1vdmVOb2RlQXRQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgaWYgKF90aGlzLm5vZGVzW3Bvc10gPT09IGZyZWVub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJlbW92ZWROb2RlcysrO1xuXHQgICAgICAgIF90aGlzLnVwZGF0ZU5vZGUoZnJlZW5vZGUsIHBvcyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIHZhciBmcmVlZWRnZSA9IHsgc291cmNlOiB7IHg6IC0xLCB5OiAtMSB9LCB0YXJnZXQ6IHsgeDogLTEsIHk6IC0xIH0gfTtcblx0ICAgIHRoaXMucmVtb3ZlRWRnZUF0UG9zID0gZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgIGlmIChfdGhpcy5lZGdlc1twb3NdID09PSBmcmVlZWRnZSkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZW1vdmVkRWRnZXMrKztcblx0XG5cdCAgICAgICAgX3RoaXMudXBkYXRlRWRnZShmcmVlZWRnZSwgcG9zKTtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5nZXRWaXNpYmxlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHJlbW92ZWROb2RlcyA8PSAwKSByZXR1cm4gX3RoaXMubm9kZXM7XG5cdFxuXHQgICAgICAgIHZhciByID0gW107XG5cdCAgICAgICAgX3RoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICBpZiAobiAhPT0gZnJlZW5vZGUpIHIucHVzaChuKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gcjtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5nZXRWaXNpYmxlRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHJlbW92ZWRFZGdlcyA8PSAwKSByZXR1cm4gX3RoaXMuZWRnZXM7XG5cdFxuXHQgICAgICAgIHZhciByID0gW107XG5cdCAgICAgICAgX3RoaXMuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICBpZiAobiAhPT0gZnJlZWVkZ2UpIHIucHVzaChuKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gcjtcblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5jbnRTaG93bk5vZGVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5ub2Rlcy5sZW5ndGggLSByZW1vdmVkTm9kZXM7XG5cdCAgICB9O1xuXHRcblx0ICAgIHRoaXMuY250U2hvd25FZGdlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMuZWRnZXMubGVuZ3RoIC0gcmVtb3ZlZEVkZ2VzO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgZ2V0RWRnZVN0eWxlU2l6ZSA9IGZ1bmN0aW9uIGdldEVkZ2VTdHlsZVNpemUoYykge1xuXHQgICAgICAgIHJldHVybiBjLndpZHRoIC8gMTIwO1xuXHQgICAgICAgIC8qICAgICAgbGV0IGF2c2l6ZSA9IChjLndpZHRoICsgYy5oZWlnaHQpLzI7XG5cdCAgICAgICAgICAgICAgbGV0IGtvZWYgPSAoTWF0aC5taW4oTWF0aC5tYXgoKGF2c2l6ZSAtIDE1MCkvMTUwLCAwKSwxKSsxKSoxLjM7XG5cdCAgICAgICAgICAgICAgLy9rb2VmIDEgZm9yIDE1MCBzaXplIGFuZCAxLjQgZm9yIDMwMCBzaXplXG5cdCAgICAgICAgICAgICAgcmV0dXJuIGMud2lkdGgvKDEzMCprb2VmKTtcblx0ICAgICAgICAqL1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgc3R5bGVzVHJhbnNsID0ge1xuXHQgICAgICAgICdsaW5lJzogMCxcblx0ICAgICAgICAnZGFzaGVkJzogMSxcblx0ICAgICAgICAnY2hhaW4tZG90dGVkJzogMixcblx0ICAgICAgICAnZG90dGVkJzogM1xuXHQgICAgfTtcblx0ICAgIHZhciBnZXRFZGdlVHlwZSA9IGZ1bmN0aW9uIGdldEVkZ2VUeXBlKHQpIHtcblx0ICAgICAgICBpZiAodCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHQgPSBzdHlsZXNUcmFuc2xbdF07XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0ICE9PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICB0ID0gMDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiB0O1xuXHQgICAgfTtcblx0XG5cdCAgICB0aGlzLm5vZGVzID0gW107XG5cdCAgICB0aGlzLmVkZ2VzID0gW107XG5cdFxuXHQgICAgdmFyIGV4dGVuc2lvbnMgPSBnbCA/IF9nbDIuZGVmYXVsdC5pbml0RXh0ZW5zaW9ucyhnbCwgXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIikgOiB7fTtcblx0ICAgIHZhciBzY2VuZSA9IHRoaXMuc2NlbmUgPSBjcmVhdGVTY2VuZS5jYWxsKHRoaXMpO1xuXHRcblx0ICAgIHZhciBsb2FkQ2FsbGVkID0gZmFsc2U7XG5cdCAgICBpZiAoIWdsKSB7XG5cdCAgICAgICAgb3B0aW9ucy5vbkxvYWQgJiYgIWxvYWRDYWxsZWQgJiYgKGxvYWRDYWxsZWQgPSB0cnVlKSAmJiBvcHRpb25zLm9uTG9hZCgpO3JldHVybiB0aGlzO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgZ2V0TGFiZWxUeXBlID0gZnVuY3Rpb24gZ2V0TGFiZWxUeXBlKGYpIHtcblx0ICAgICAgICBpZiAodGV4dHMuaXNTREYoZikpIHJldHVybiAxO1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfTtcblx0XG5cdCAgICB2YXIgZnNDb2xvclRleHR1cmUgPSBbXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIiwgXCJ1bmlmb3JtIHZlYzQgY29sb3I7XCIsIFwidW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcIiwgXCJ2YXJ5aW5nIHZlYzIgdGM7XCIsIFwidm9pZCBtYWluKHZvaWQpIHtcIiwgXCIgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHRleHR1cmUyRCh0ZXh0dXJlLCB2ZWMyKHRjLnMsIHRjLnQpKTtcIiwgXCJ9XCJdO1xuXHRcblx0ICAgIHZhciBmc0xhYmVsVGV4dHVyZSA9IFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLCBcInVuaWZvcm0gbG93cCBzYW1wbGVyMkQgdGV4dHVyZTtcIiwgXCJ1bmlmb3JtIG1lZGl1bXAgdmVjNCBjb2xvcjtcIiwgXCJ1bmlmb3JtIG1lZGl1bXAgZmxvYXQgaGVpZ2h0X2ZvbnQ7XCIsIFwidW5pZm9ybSBmbG9hdCB0eXBlO1wiLCBcInVuaWZvcm0gZmxvYXQgYnVmZmVyO1wiLCBcInVuaWZvcm0gZmxvYXQgYm9sZG5lc3M7XCIsIFwiZmxvYXQgZ2FtbWEgPSA0LjAgKiAxLjQxNDIgKiBib2xkbmVzcyAvIGhlaWdodF9mb250O1wiLCBcInZhcnlpbmcgbWVkaXVtcCB2ZWMyIHRjO1wiLCBcInZvaWQgbWFpbigpIHtcIiwgXCIgIGlmKHR5cGUgPiAwLjUpe1wiLCAvL1NERlxuXHQgICAgXCIgICAgZmxvYXQgdHg9dGV4dHVyZTJEKHRleHR1cmUsIHRjKS5hO1wiLCBcIiAgICBmbG9hdCBhPSBzbW9vdGhzdGVwKGJ1ZmZlciAtIGdhbW1hLCBidWZmZXIgKyBnYW1tYSwgdHgpO1wiLCBcIiAgICBnbF9GcmFnQ29sb3I9dmVjNChjb2xvci5yZ2IsIGEqY29sb3IuYSk7XCIsIFwiICB9ZWxzZXtcIiwgLy9OT1JNQUwgRk9OVFxuXHQgICAgXCIgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB0ZXh0dXJlMkQodGV4dHVyZSwgdmVjMih0Yy5zLCB0Yy50KSk7XCIsIFwiICB9XCIsIFwifVwiXTtcblx0XG5cdCAgICB2YXIgZnNWYXJDb2xvclRleHR1cmUgPSBbXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIiwgXCJ1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1wiLCBcInZhcnlpbmcgdmVjMiB0YztcIiwgXCJ2YXJ5aW5nIHZlYzQgYztcIiwgXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIGdsX0ZyYWdDb2xvciA9IGMgKiB0ZXh0dXJlMkQodGV4dHVyZSwgdmVjMih0Yy5zLCB0Yy50KSk7XCIsIFwifVwiXTtcblx0XG5cdCAgICB2YXIgbGluZVR5cGVzID0gW1wiICAgaWYodHlwZSA+PSAyLjUpe1wiLCAvLzMuMCBkb3R0ZWRcblx0ICAgIFwiICAgICAgcGFydCA9IGZyYWN0KHBhcnQqMy4wKTtcIiwgXCIgICAgICBpZihwYXJ0IDwgMC41KSBkaXNjYXJkO1wiLCBcIiAgIH1lbHNlIGlmKHR5cGUgPj0gMS41KXtcIiwgLy8yLjAgLSBjaGFpbiBkb3R0ZWRcblx0ICAgIFwiICAgICAgaWYocGFydCA8IDAuMTUpIGRpc2NhcmQ7XCIsIFwiICAgICAgaWYocGFydCA+IDAuMzAgJiYgcGFydCA8IDAuNDUpIGRpc2NhcmQ7XCIsIFwiICAgfWVsc2UgaWYodHlwZSA+PSAwLjUpe1wiLCAvLzEuMCAtIGRhc2hlZFxuXHQgICAgXCIgICAgICBpZihwYXJ0IDwgMC41KSBkaXNjYXJkO1wiLCBcIiAgIH1cIl07XG5cdCAgICB2YXIgZnNDdXJ2ZSA9IFtcIiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXCIsIFwiI2lmZGVmIEdMX0VTXCIsIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiLCBcIiNlbmRpZlwiLCBcInVuaWZvcm0gZmxvYXQgd2lkdGg7XCIsIFwidW5pZm9ybSB2ZWM0IGNvbG9yO1wiLCBcInVuaWZvcm0gZmxvYXQgdHlwZTtcIiwgXCJ1bmlmb3JtIGZsb2F0IGxpbmVTdGVwU2l6ZTtcIiwgXCJ1bmlmb3JtIGZsb2F0IGxpbmVTaXplO1wiLCBcInZhcnlpbmcgdmVjMiBjO1wiLCBcInZhcnlpbmcgdmVjMiB2X2xlbmd0aFNvRmFyO1wiLCBcInZvaWQgbWFpbih2b2lkKSB7XCIsIFwiICAgZmxvYXQgcGFydCA9IGFicyhmcmFjdChsZW5ndGgodl9sZW5ndGhTb0ZhcikqbGluZVN0ZXBTaXplKmxpbmVTaXplKSk7XCJdLmNvbmNhdChsaW5lVHlwZXMpLmNvbmNhdChbXCIgICB2ZWMyIHB4ID0gZEZkeChjKTtcIiwgXCIgICB2ZWMyIHB5ID0gZEZkeShjKTtcIiwgXCIgICBmbG9hdCBmeCA9IDIuMCAqIGMueCAqIHB4LnggLSBweC55O1wiLCBcIiAgIGZsb2F0IGZ5ID0gMi4wICogYy55ICogcHkueCAtIHB5Lnk7XCIsIFwiICAgZmxvYXQgc2QgPSAoYy54ICogYy54IC0gYy55KSAvIHNxcnQoZnggKiBmeCArIGZ5ICogZnkpO1wiLCBcIiAgIGZsb2F0IGFscGhhID0gMS4wIC0gYWJzKHNkKSAvIHdpZHRoO1wiLCBcIiAgIGlmIChhbHBoYSA8IDAuMCkgZGlzY2FyZDtcIiwgXCIgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIG1pbihhbHBoYSwgMS4wKSk7XCIsIFwifVwiXSk7XG5cdFxuXHQgICAgdmFyIGdldFNoaWZ0RnVuY3MgPSBbXCJhdHRyaWJ1dGUgdmVjMiBjdXJ2ZVNoaWZ0O1wiLCBcInZlYzQgZ2V0U2hpZnRDdXJ2ZSh2b2lkKSB7XCIsIFwiICAgdmVjMiBzaGlmdE4gPSB2ZWMyKGN1cnZlU2hpZnQueCwgYXNwZWN0MiAqIGN1cnZlU2hpZnQueSk7XCIsIFwiICAgZmxvYXQgbGVuZ3RoID0gbGVuZ3RoKHNjcmVlbiAqIHNoaWZ0Tik7XCIsIFwiICAgcmV0dXJuIHZlYzQoZXhjICogKGxlbmd0aCA9PSAwLjAgPyB2ZWMyKDAsIDApIDogc2hpZnROICogMC41IC8gbGVuZ3RoKSwgMCwgMCk7XCIsIFwifVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGNpcmNsZVNoaWZ0O1wiLCBcInZlYzQgZ2V0U2hpZnRDaXJjbGUodm9pZCkge1wiLCBcIiAgIHJldHVybiB2ZWM0KHNpemUqY2lyY2xlU2hpZnQsMCwwKTtcIiwgXCJ9XCJdO1xuXHRcblx0ICAgIHNjZW5lLmFkZChcImxpbmVzXCIsIG5ldyBfcHJpbWl0aXZlMi5kZWZhdWx0KGdsLCBlZGdlU3R5bGUsIG51bGwsIFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLCBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMyIG5vcm1hbDtcIiwgXCJhdHRyaWJ1dGUgdmVjMiBsZW5ndGhTb0ZhcjtcIiwgXCJ1bmlmb3JtIGZsb2F0IGV4YztcIiwgXCJ1bmlmb3JtIHZlYzIgc2l6ZTtcIiwgXCJ1bmlmb3JtIHZlYzIgc2NyZWVuO1wiLCBcInVuaWZvcm0gZmxvYXQgYXNwZWN0MjtcIiwgXCJ1bmlmb3JtIGZsb2F0IGFzcGVjdDtcIiwgXCJ1bmlmb3JtIHZlYzIgd2lkdGg7XCIsIFwidW5pZm9ybSBtYXQ0IHRyYW5zZm9ybTtcIiwgXCJ2YXJ5aW5nIHZlYzIgbjtcIiwgXCJ2YXJ5aW5nIHZlYzIgdl9sZW5ndGhTb0ZhcjtcIl0uY29uY2F0KGdldFNoaWZ0RnVuY3MpLmNvbmNhdChbXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIGdsX1Bvc2l0aW9uID0gZ2V0U2hpZnRDdXJ2ZSgpICsgZ2V0U2hpZnRDaXJjbGUoKSArIHZlYzQod2lkdGggKiBub3JtYWwsIDAsIDApICsgdHJhbnNmb3JtICogdmVjNChwb3NpdGlvbiwgMCwgMSk7XCIsIFwiICAgdmVjNCBwID0gdHJhbnNmb3JtKnZlYzQobGVuZ3RoU29GYXIsMCwwKTtcIiwgXCIgICB2X2xlbmd0aFNvRmFyID0gdmVjMihwLngsIHAueS9hc3BlY3QpO1wiLCBcIiAgIG4gPSBub3JtYWw7XCIsIFwifVwiXSksIFtcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLCBcInVuaWZvcm0gZmxvYXQgdHlwZTtcIiwgXCJ1bmlmb3JtIHZlYzQgY29sb3I7XCIsIFwidmFyeWluZyB2ZWMyIG47XCIsIFwidmFyeWluZyB2ZWMyIHZfbGVuZ3RoU29GYXI7XCIsIFwidW5pZm9ybSBmbG9hdCBsaW5lU2l6ZTtcIiwgXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIGZsb2F0IHBhcnQgPSBhYnMoZnJhY3QobGVuZ3RoKHZfbGVuZ3RoU29GYXIpKmxpbmVTaXplKjUuMCkpO1wiXS5jb25jYXQobGluZVR5cGVzKS5jb25jYXQoW1wiICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hIC0gbGVuZ3RoKG4pKTtcIiwgXCJ9XCJdKSwgZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICB2YXIgdW5pZm9ybXMgPSBjLnNoYWRlci51bmlmb3Jtcztcblx0ICAgICAgICB1bmlmb3Jtcy5leGMgJiYgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmV4YywgYy5jdXJ2ZUV4Yyk7XG5cdCAgICAgICAgZ2wudW5pZm9ybTJmKHVuaWZvcm1zLnNjcmVlbiwgYy53aWR0aCwgYy5oZWlnaHQpO1xuXHQgICAgICAgIHZhciBzaXplID0gMi41ICogYy5ub2RlU2l6ZTtcblx0ICAgICAgICB1bmlmb3Jtcy5zaXplICYmIGdsLnVuaWZvcm0yZih1bmlmb3Jtcy5zaXplLCBzaXplIC8gYy53aWR0aCwgc2l6ZSAvIGMuaGVpZ2h0KTtcblx0ICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMubGluZVNpemUsIGdldEVkZ2VTdHlsZVNpemUoYykpO1xuXHQgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5hc3BlY3QyLCBjLmFzcGVjdDIpO1xuXHQgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5hc3BlY3QsIGMuYXNwZWN0KTtcblx0ICAgICAgICBnbC51bmlmb3JtMmYodW5pZm9ybXMud2lkdGgsIGMuc3R5bGUud2lkdGggLyBjLndpZHRoLCBjLnN0eWxlLndpZHRoIC8gYy5oZWlnaHQpO1xuXHQgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy50eXBlLCBnZXRFZGdlVHlwZShjLnN0eWxlLnR5cGUpKTtcblx0ICAgICAgICBfZ2wyLmRlZmF1bHQudW5pZm9ybUNvbG9yKGdsLCB1bmlmb3Jtcy5jb2xvciwgYy5zdHlsZS5jb2xvcik7XG5cdCAgICB9KSk7XG5cdFxuXHQgICAgaWYgKGV4dGVuc2lvbnMuT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzKSB7XG5cdCAgICAgICAgc2NlbmUuYWRkKFwiY3VydmVzXCIsIG5ldyBfcHJpbWl0aXZlMi5kZWZhdWx0KGdsLCBlZGdlU3R5bGUsIG51bGwsIFtcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIiwgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMiBub3JtYWw7XCIsIFwiYXR0cmlidXRlIHZlYzIgY3VydmU7XCIsIFwiYXR0cmlidXRlIHZlYzIgbGVuZ3RoU29GYXI7XCIsIFwidW5pZm9ybSB2ZWMyIHNpemU7XCIsIFwidW5pZm9ybSBmbG9hdCBleGM7XCIsIFwidW5pZm9ybSB2ZWMyIHNjcmVlbjtcIiwgXCJ1bmlmb3JtIGZsb2F0IGFzcGVjdDI7XCIsIFwidW5pZm9ybSBmbG9hdCBhc3BlY3Q7XCIsIFwidW5pZm9ybSBtYXQ0IHRyYW5zZm9ybTtcIiwgXCJ2YXJ5aW5nIHZlYzIgdl9sZW5ndGhTb0ZhcjtcIiwgXCJ2YXJ5aW5nIHZlYzIgYztcIl0uY29uY2F0KGdldFNoaWZ0RnVuY3MpLmNvbmNhdChbXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIHZlYzIgbiA9IHZlYzIobm9ybWFsLngsIGFzcGVjdDIgKiBub3JtYWwueSk7XCIsIFwiICAgZmxvYXQgbGVuZ3RoID0gbGVuZ3RoKHNjcmVlbiAqIG4pO1wiLCBcIiAgIG4gPSBsZW5ndGggPT0gMC4wID8gdmVjMigwLCAwKSA6IG4gLyBsZW5ndGg7XCIsIFwiICAgZ2xfUG9zaXRpb24gPSBnZXRTaGlmdEN1cnZlKCkgKyBnZXRTaGlmdENpcmNsZSgpICsgdmVjNChleGMgKiBuLCAwLCAwKSArIHRyYW5zZm9ybSAqIHZlYzQocG9zaXRpb24sIDAsIDEpO1wiLCBcIiAgIGMgPSBjdXJ2ZTtcIiwgXCIgICB2ZWM0IHAgPSB0cmFuc2Zvcm0qdmVjNChsZW5ndGhTb0ZhciwwLDApO1wiLCBcIiAgIHZfbGVuZ3RoU29GYXIgPSB2ZWMyKHAueCwgcC55L2FzcGVjdCk7XCIsIFwifVwiXSksIGZzQ3VydmUsIGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IGMuc2hhZGVyLnVuaWZvcm1zO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMud2lkdGgsIGMuc3R5bGUud2lkdGgpO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMuZXhjLCBjLmN1cnZlRXhjKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVuaWZvcm1zLnNjcmVlbiwgYy53aWR0aCwgYy5oZWlnaHQpO1xuXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IDIuNSAqIGMubm9kZVNpemU7XG5cdCAgICAgICAgICAgIHVuaWZvcm1zLnNpemUgJiYgZ2wudW5pZm9ybTJmKHVuaWZvcm1zLnNpemUsIHNpemUgLyBjLndpZHRoLCBzaXplIC8gYy5oZWlnaHQpO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMubGluZVNpemUsIGdldEVkZ2VTdHlsZVNpemUoYykpO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMuYXNwZWN0MiwgYy5hc3BlY3QyKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmFzcGVjdCwgYy5hc3BlY3QpO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMudHlwZSwgZ2V0RWRnZVR5cGUoYy5zdHlsZS50eXBlKSk7XG5cdCAgICAgICAgICAgIHVuaWZvcm1zLmxpbmVTdGVwU2l6ZSAmJiBnbC51bmlmb3JtMWYodW5pZm9ybXMubGluZVN0ZXBTaXplLCA1KTtcblx0ICAgICAgICAgICAgX2dsMi5kZWZhdWx0LnVuaWZvcm1Db2xvcihnbCwgdW5pZm9ybXMuY29sb3IsIGMuc3R5bGUuY29sb3IpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBzY2VuZS5hZGQoXCJjaXJjbGVzXCIsIG5ldyBfcHJpbWl0aXZlMi5kZWZhdWx0KGdsLCBlZGdlU3R5bGUsIG51bGwsIFtcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIiwgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMiBub3JtYWw7XCIsIFwiYXR0cmlidXRlIHZlYzIgY3VydmU7XCIsIFwiYXR0cmlidXRlIHZlYzIgbGVuZ3RoU29GYXI7XCIsIFwidW5pZm9ybSBmbG9hdCBleGM7XCIsIFwidW5pZm9ybSB2ZWMyIHNjcmVlbjtcIiwgXCJ1bmlmb3JtIGZsb2F0IGFzcGVjdDI7XCIsIFwidW5pZm9ybSBmbG9hdCBhc3BlY3Q7XCIsIFwidW5pZm9ybSB2ZWMyIHNpemU7XCIsIFwidW5pZm9ybSBtYXQ0IHRyYW5zZm9ybTtcIiwgXCJ2YXJ5aW5nIHZlYzIgYztcIiwgXCJ2YXJ5aW5nIHZlYzIgdl9sZW5ndGhTb0ZhcjtcIl0uY29uY2F0KGdldFNoaWZ0RnVuY3MpLmNvbmNhdChbXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIGdsX1Bvc2l0aW9uID0gZ2V0U2hpZnRDdXJ2ZSgpICsgZ2V0U2hpZnRDaXJjbGUoKSArIHZlYzQoc2l6ZSAqIG5vcm1hbCwgMCwgMCkgKyB0cmFuc2Zvcm0gKiB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcIiwgXCIgICBjID0gY3VydmU7XCIsIFwiICAgdmVjNCBwID0gdHJhbnNmb3JtKnZlYzQoc2l6ZSAqIGxlbmd0aFNvRmFyLDAsMCk7XCIsIFwiICAgdl9sZW5ndGhTb0ZhciA9IHZlYzIocC54LCBwLnkvYXNwZWN0KTtcIiwgXCJ9XCJdKSwgZnNDdXJ2ZSwgZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0gYy5zaGFkZXIudW5pZm9ybXM7XG5cdCAgICAgICAgICAgIHVuaWZvcm1zLmV4YyAmJiBnbC51bmlmb3JtMWYodW5pZm9ybXMuZXhjLCBjLmN1cnZlRXhjKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLndpZHRoLCBjLnN0eWxlLndpZHRoKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLnR5cGUsIGdldEVkZ2VUeXBlKGMuc3R5bGUudHlwZSkpO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMmYodW5pZm9ybXMuc2NyZWVuLCBjLndpZHRoLCBjLmhlaWdodCk7XG5cdCAgICAgICAgICAgIHZhciBzaXplID0gMi41ICogYy5ub2RlU2l6ZTtcblx0ICAgICAgICAgICAgdW5pZm9ybXMuc2l6ZSAmJiBnbC51bmlmb3JtMmYodW5pZm9ybXMuc2l6ZSwgc2l6ZSAvIGMud2lkdGgsIHNpemUgLyBjLmhlaWdodCk7XG5cdCAgICAgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5saW5lU2l6ZSwgZ2V0RWRnZVN0eWxlU2l6ZShjKSk7XG5cdCAgICAgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5hc3BlY3QyLCBjLmFzcGVjdDIpO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMuYXNwZWN0LCBjLmFzcGVjdCk7XG5cdCAgICAgICAgICAgIHVuaWZvcm1zLmxpbmVTdGVwU2l6ZSAmJiBnbC51bmlmb3JtMWYodW5pZm9ybXMubGluZVN0ZXBTaXplLCA1IC8gMyk7XG5cdCAgICAgICAgICAgIF9nbDIuZGVmYXVsdC51bmlmb3JtQ29sb3IoZ2wsIHVuaWZvcm1zLmNvbG9yLCBjLnN0eWxlLmNvbG9yKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKGVkZ2VTdHlsZS5hcnJvdykge1xuXHQgICAgICAgIHZhciBzaGFkZXJwYXJhbXMgPSB7IGF0dHJpYnV0ZTogeyBvZmZzZXRNdWw6IDEgfSB9O1xuXHRcblx0ICAgICAgICB2YXIgYmluZCA9IGZ1bmN0aW9uIGJpbmQoYykge1xuXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IGdldFNpemUoYywgYy5zdHlsZSwgZ2V0RWRnZXNDbnQoKSwgMC4yKTtcblx0ICAgICAgICAgICAgaWYgKCFzaXplKSByZXR1cm4gdHJ1ZTtcblx0XG5cdCAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IGMuc2hhZGVyLnVuaWZvcm1zO1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMub2Zmc2V0LCAwLjUgKiBjLm5vZGVTaXplKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVuaWZvcm1zLmFycm93c2l6ZSwgc2l6ZSwgYy5zdHlsZS5hc3BlY3QgKiBzaXplKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmV4YywgYy5jdXJ2ZUV4Yyk7XG5cdCAgICAgICAgICAgIHVuaWZvcm1zLmNleGMgJiYgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmNleGMsIDAuNSAqIHZpZXcuc2l6ZSAqIGMuY3VydmVFeGMpO1xuXHQgICAgICAgICAgICBpZiAodW5pZm9ybXMuc2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgc2l6ZSA9IDIuNSAqIGMubm9kZVNpemU7XG5cdCAgICAgICAgICAgICAgICB1bmlmb3Jtcy5zaXplICYmIGdsLnVuaWZvcm0yZih1bmlmb3Jtcy5zaXplLCBzaXplIC8gYy53aWR0aCwgc2l6ZSAvIGMuaGVpZ2h0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBnbC51bmlmb3JtMmYodW5pZm9ybXMuc2NyZWVuLCBjLndpZHRoLCBjLmhlaWdodCk7XG5cdCAgICAgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtcy5hc3BlY3QyLCBjLmFzcGVjdDIpO1xuXHQgICAgICAgICAgICBfZ2wyLmRlZmF1bHQudW5pZm9ybUNvbG9yKGdsLCB1bmlmb3Jtcy5jb2xvciwgYy5zdHlsZS5jb2xvcik7XG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgc2NlbmUuYWRkKFwibGluZUFycm93c1wiLCBuZXcgX3ByaW1pdGl2ZTIuZGVmYXVsdChnbCwgZWRnZVN0eWxlLCBcImFycm93XCIsIFtcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMyIGRpcmVjdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMiB0ZXh0dXJlQ29vcmQ7XCIsIFwiYXR0cmlidXRlIGZsb2F0IG9mZnNldE11bDtcIiwgXCJ1bmlmb3JtIGZsb2F0IG9mZnNldDtcIiwgXCJ1bmlmb3JtIHZlYzIgYXJyb3dzaXplO1wiLCBcInVuaWZvcm0gdmVjMiBzaXplO1wiLCBcInVuaWZvcm0gdmVjMiBzY3JlZW47XCIsIFwidW5pZm9ybSBmbG9hdCBleGM7XCIsIFwidW5pZm9ybSBmbG9hdCBhc3BlY3QyO1wiLCBcInVuaWZvcm0gbWF0NCB0cmFuc2Zvcm07XCIsIFwidmFyeWluZyB2ZWMyIHRjO1wiXS5jb25jYXQoZ2V0U2hpZnRGdW5jcykuY29uY2F0KFtcInZvaWQgbWFpbih2b2lkKSB7XCIsIFwiICAgdmVjMiB1ID0gZGlyZWN0aW9uIC8gbGVuZ3RoKHNjcmVlbiAqIGRpcmVjdGlvbik7XCIsIFwiICAgdmVjMiB2ID0gdmVjMih1LnksIC1hc3BlY3QyICogdS54KTtcIiwgXCIgICB2ID0gdiAvIGxlbmd0aChzY3JlZW4gKiB2KTtcIiwgXCIgICBnbF9Qb3NpdGlvbiA9IGdldFNoaWZ0Q3VydmUoKSArIGdldFNoaWZ0Q2lyY2xlKCkgICsgdmVjNChhcnJvd3NpemUueCAqICgwLjUgLSB0ZXh0dXJlQ29vcmQueCkgKiB2IC0gYXJyb3dzaXplLnkgKiB0ZXh0dXJlQ29vcmQueSAqIHUgLSBvZmZzZXQgKiBvZmZzZXRNdWwgKiB1LCAwLCAwKSArIHRyYW5zZm9ybSAqIHZlYzQocG9zaXRpb24sIDAsIDEpO1wiLCBcIiAgIHRjID0gdGV4dHVyZUNvb3JkO1wiLCBcIn1cIl0pLCBmc0NvbG9yVGV4dHVyZSwgYmluZCwgc2hhZGVycGFyYW1zKSk7XG5cdFxuXHQgICAgICAgIGlmIChleHRlbnNpb25zLk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykge1xuXHQgICAgICAgICAgICBzY2VuZS5hZGQoXCJjdXJ2ZUFycm93c1wiLCBuZXcgX3ByaW1pdGl2ZTIuZGVmYXVsdChnbCwgZWRnZVN0eWxlLCBcImFycm93XCIsIFtcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMyIGRpcmVjdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMiB0ZXh0dXJlQ29vcmQ7XCIsIFwiYXR0cmlidXRlIGZsb2F0IG9mZnNldE11bDtcIiwgXCJ1bmlmb3JtIGZsb2F0IG9mZnNldDtcIiwgXCJ1bmlmb3JtIHZlYzIgYXJyb3dzaXplO1wiLCBcInVuaWZvcm0gdmVjMiBzaXplO1wiLCBcInVuaWZvcm0gZmxvYXQgZXhjO1wiLCBcInVuaWZvcm0gZmxvYXQgY2V4YztcIiwgXCJ1bmlmb3JtIHZlYzIgc2NyZWVuO1wiLCBcInVuaWZvcm0gZmxvYXQgYXNwZWN0MjtcIiwgXCJ1bmlmb3JtIG1hdDQgdHJhbnNmb3JtO1wiLCBcInZhcnlpbmcgdmVjMiB0YztcIl0uY29uY2F0KGdldFNoaWZ0RnVuY3MpLmNvbmNhdChbXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIHZlYzIgdSA9IG5vcm1hbGl6ZSh2ZWMyKGRpcmVjdGlvbi55LCAtYXNwZWN0MiAqIGRpcmVjdGlvbi54KSk7XCIsIFwiICAgdSA9IG5vcm1hbGl6ZShkaXJlY3Rpb24gLSBjZXhjICogdSAvIGxlbmd0aChzY3JlZW4gKiB1KSk7XCIsIFwiICAgdSA9IHUgLyBsZW5ndGgoc2NyZWVuICogdSk7XCIsIFwiICAgdmVjMiB2ID0gdmVjMih1LnksIC1hc3BlY3QyICogdS54KTtcIiwgXCIgICB2ID0gdiAvIGxlbmd0aChzY3JlZW4gKiB2KTtcIiwgXCIgICBnbF9Qb3NpdGlvbiA9IGdldFNoaWZ0Q3VydmUoKSArIGdldFNoaWZ0Q2lyY2xlKCkgKyB2ZWM0KGFycm93c2l6ZS54ICogKDAuNSAtIHRleHR1cmVDb29yZC54KSAqIHYgLSBhcnJvd3NpemUueSAqIHRleHR1cmVDb29yZC55ICogdSAtIG9mZnNldCAqIG9mZnNldE11bCAqIHUsIDAsIDApICsgdHJhbnNmb3JtICogdmVjNChwb3NpdGlvbiwgMCwgMSk7XCIsIFwiICAgdGMgPSB0ZXh0dXJlQ29vcmQ7XCIsIFwifVwiXSksIGZzQ29sb3JUZXh0dXJlLCBiaW5kLCBzaGFkZXJwYXJhbXMpKTtcblx0ICAgICAgICAgICAgc2NlbmUuYWRkKFwiY2lyY2xlQXJyb3dzXCIsIG5ldyBfcHJpbWl0aXZlMi5kZWZhdWx0KGdsLCBlZGdlU3R5bGUsIFwiYXJyb3dcIiwgW1wiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsIFwiYXR0cmlidXRlIHZlYzIgZGlyZWN0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMyIHRleHR1cmVDb29yZDtcIiwgXCJhdHRyaWJ1dGUgZmxvYXQgb2Zmc2V0TXVsO1wiLCBcInVuaWZvcm0gZmxvYXQgb2Zmc2V0O1wiLCBcInVuaWZvcm0gdmVjMiBhcnJvd3NpemU7XCIsIFwidW5pZm9ybSB2ZWMyIHNpemU7XCIsIFwidW5pZm9ybSB2ZWMyIHNjcmVlbjtcIiwgXCJ1bmlmb3JtIGZsb2F0IGV4YztcIiwgXCJ1bmlmb3JtIGZsb2F0IGFzcGVjdDI7XCIsIFwidW5pZm9ybSBtYXQ0IHRyYW5zZm9ybTtcIiwgXCJ2YXJ5aW5nIHZlYzIgdGM7XCJdLmNvbmNhdChnZXRTaGlmdEZ1bmNzKS5jb25jYXQoW1widm9pZCBtYWluKHZvaWQpIHtcIiwgXCIgICB2ZWMyIHUgPSBkaXJlY3Rpb247XCIsIFwiICAgdmVjMiB2ID0gdmVjMihkaXJlY3Rpb24ueSwgLWRpcmVjdGlvbi54KTtcIiwgXCIgICBnbF9Qb3NpdGlvbiA9IGdldFNoaWZ0Q3VydmUoKSArIGdldFNoaWZ0Q2lyY2xlKCkgKyB2ZWM0KChhcnJvd3NpemUueCAqICgwLjUgLSB0ZXh0dXJlQ29vcmQueCkgKiB2IC0gYXJyb3dzaXplLnkgKiB0ZXh0dXJlQ29vcmQueSAqIHUgLSBvZmZzZXQgKiBvZmZzZXRNdWwgKiB1KSAvIHNjcmVlbiwgMCwgMCkgKyB0cmFuc2Zvcm0gKiB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcIiwgXCIgICB0YyA9IHRleHR1cmVDb29yZDtcIiwgXCJ9XCJdKSwgZnNDb2xvclRleHR1cmUsIGJpbmQsIHNoYWRlcnBhcmFtcykpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBzY2VuZS5hZGQoXCJub2Rlc1wiLCBuZXcgX3ByaW1pdGl2ZTIuZGVmYXVsdChnbCwgbm9kZVN0eWxlLCBudWxsLCBbXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIiwgXCJhdHRyaWJ1dGUgdmVjMiB0ZXh0dXJlQ29vcmQ7XCIsIFwidW5pZm9ybSB2ZWMyIHNpemU7XCIsIFwidW5pZm9ybSBtYXQ0IHRyYW5zZm9ybTtcIiwgXCJ2YXJ5aW5nIHZlYzIgdGM7XCIsIFwidm9pZCBtYWluKHZvaWQpIHtcIiwgXCIgICBnbF9Qb3NpdGlvbiA9IHZlYzQoc2l6ZSAqICh0ZXh0dXJlQ29vcmQgLSB2ZWMyKDAuNSwgMC41KSksIDAsIDApICsgdHJhbnNmb3JtICogdmVjNChwb3NpdGlvbiwgMCwgMSk7XCIsIFwiICAgdGMgPSB0ZXh0dXJlQ29vcmQ7XCIsIFwifVwiXSwgZnNDb2xvclRleHR1cmUsIGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgdmFyIHNpemUgPSBnZXROb2RlU2l6ZShjKTtcblx0ICAgICAgICB2YXIgdW5pZm9ybXMgPSBjLnNoYWRlci51bmlmb3Jtcztcblx0ICAgICAgICBnbC51bmlmb3JtMmYodW5pZm9ybXMuc2l6ZSwgc2l6ZSAvIGMud2lkdGgsIHNpemUgLyBjLmhlaWdodCk7XG5cdCAgICAgICAgX2dsMi5kZWZhdWx0LnVuaWZvcm1Db2xvcihnbCwgdW5pZm9ybXMuY29sb3IsIGMuc3R5bGUuY29sb3IpO1xuXHQgICAgfSkpO1xuXHQgICAgc2NlbmUuYWRkKFwibm9kZXNDb2xvcmVkXCIsIG5ldyBfcHJpbWl0aXZlMi5kZWZhdWx0KGdsLCBub2RlU3R5bGUsIG51bGwsIFtcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLCBcImF0dHJpYnV0ZSB2ZWMyIHRleHR1cmVDb29yZDtcIiwgXCJhdHRyaWJ1dGUgdmVjNCBjb2xvcjtcIiwgXCJ1bmlmb3JtIHZlYzIgc2l6ZTtcIiwgXCJ1bmlmb3JtIG1hdDQgdHJhbnNmb3JtO1wiLCBcInZhcnlpbmcgdmVjMiB0YztcIiwgXCJ2YXJ5aW5nIHZlYzQgYztcIiwgXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIGdsX1Bvc2l0aW9uID0gdmVjNChzaXplICogKHRleHR1cmVDb29yZCAtIHZlYzIoMC41LCAwLjUpKSwgMCwgMCkgKyB0cmFuc2Zvcm0gKiB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcIiwgXCIgICB0YyA9IHRleHR1cmVDb29yZDtcIiwgXCIgICBjID0gY29sb3I7XCIsIFwifVwiXSwgZnNWYXJDb2xvclRleHR1cmUsIGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgdmFyIHNpemUgPSBnZXROb2RlU2l6ZShjKTtcblx0ICAgICAgICB2YXIgdW5pZm9ybXMgPSBjLnNoYWRlci51bmlmb3Jtcztcblx0ICAgICAgICBnbC51bmlmb3JtMmYodW5pZm9ybXMuc2l6ZSwgc2l6ZSAvIGMud2lkdGgsIHNpemUgLyBjLmhlaWdodCk7XG5cdCAgICB9KSk7XG5cdFxuXHQgICAgdmFyIHZzTGFiZWxzU2hhZGVyID0gW1wiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsIFwiYXR0cmlidXRlIHZlYzIgcmVsYXRpdmU7XCIsIFwiYXR0cmlidXRlIHZlYzIgdGV4dHVyZUNvb3JkO1wiLCBcInVuaWZvcm0gZmxvYXQgb2Zmc2V0O1wiLCBcInVuaWZvcm0gdmVjMiBzY2FsZTtcIiwgXCJ1bmlmb3JtIGZsb2F0IGZvbnRTY2FsZTtcIiwgXCJ1bmlmb3JtIG1hdDQgdHJhbnNmb3JtO1wiLCBcInZhcnlpbmcgdmVjMiB0YztcIiwgXCJ2b2lkIG1haW4odm9pZCkge1wiLCBcIiAgIGdsX1Bvc2l0aW9uID0gdmVjNChzY2FsZSAqIChyZWxhdGl2ZSpmb250U2NhbGUgKyB2ZWMyKDAsICgyLjAgKiBzdGVwKHBvc2l0aW9uLnksIDAuNSkgLSAxLjApICogb2Zmc2V0KSksIDAsIDApICsgdHJhbnNmb3JtICogdmVjNChwb3NpdGlvbiwgMCwgMSk7XCIsIFwiICAgdGMgPSB0ZXh0dXJlQ29vcmQ7XCIsIFwifVwiXTtcblx0ICAgIHZhciBiaW5kTGFiZWxzID0gZnVuY3Rpb24gYmluZExhYmVscyhpc19vdXRsaW5lKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgIGlmICghZ2V0Tm9kZVNpemUoYykpIHJldHVybiB0cnVlO1xuXHRcblx0ICAgICAgICAgICAgdmFyIGwgPSBjLnN0eWxlLmxhYmVsO1xuXHQgICAgICAgICAgICB2YXIgZiA9IGwuZm9udDtcblx0ICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0gYy5zaGFkZXIudW5pZm9ybXM7XG5cdFxuXHQgICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXMudHlwZSwgZ2V0TGFiZWxUeXBlKGYpKTtcblx0XG5cdCAgICAgICAgICAgIHZhciB0ZXh0RW5naW5lID0gdGV4dHMuZ2V0RW5naW5lKGYpO1xuXHQgICAgICAgICAgICB0ZXh0RW5naW5lLnNldEZvbnQoZik7XG5cdFxuXHQgICAgICAgICAgICB2YXIgZm9udFNjYWxlID0gMS4wO1xuXHQgICAgICAgICAgICB2YXIgc2RmU2l6ZSA9IHRleHRFbmdpbmUuZm9udFNpemU7XG5cdCAgICAgICAgICAgIHZhciB3YW50ZWRTaXplID0gdGV4dEVuZ2luZS5pc1NERiA/IGdldExhYmVsU2l6ZShjb250ZXh0LCBsIHx8IHt9KSA6IHNkZlNpemU7XG5cdCAgICAgICAgICAgIGlmICh3YW50ZWRTaXplID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBmb250U2NhbGUgPSAwO1xuXHQgICAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgICAgdmFyIG9wdHMgPSB7fTtcblx0ICAgICAgICAgICAgaWYgKHdhbnRlZFNpemUgJiYgc2RmU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgZm9udFNjYWxlICo9IHdhbnRlZFNpemUgLyBzZGZTaXplO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBpZiAoaXNfb3V0bGluZSAmJiAhdGV4dEVuZ2luZS5pc1NERikgLy9kaXNjYXJkQWxsXG5cdCAgICAgICAgICAgICAgICBmb250U2NhbGUgPSAwO1xuXHRcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmJ1ZmZlciwgaXNfb3V0bGluZSA/IDAuMjUgOiAxOTIuMCAvIDI1Ni4wKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmJvbGRuZXNzLCAoZiA/IGYuYm9sZG5lc3MgOiB1bmRlZmluZWQpIHx8IDEuKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmZvbnRTY2FsZSwgZm9udFNjYWxlKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLmhlaWdodF9mb250LCBzZGZTaXplKTtcblx0ICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1zLm9mZnNldCwgMC41ICogYy5ub2RlU2l6ZSk7XG5cdCAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1bmlmb3Jtcy5zY2FsZSwgMSAvIGMud2lkdGgsIDEgLyBjLmhlaWdodCk7XG5cdFxuXHQgICAgICAgICAgICB2YXIgY29sb3IgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgIGlmIChpc19vdXRsaW5lICYmIGYpIGNvbG9yID0gbmV3IF9jb2xvcjIuZGVmYXVsdChmLm91dGxpbmVDb2xvciB8fCBiYWNrZ3JvdW5kQ29sb3IpO2Vsc2UgY29sb3IgPSBjLnN0eWxlLmNvbG9yO1xuXHQgICAgICAgICAgICBfZ2wyLmRlZmF1bHQudW5pZm9ybUNvbG9yKGdsLCB1bmlmb3Jtcy5jb2xvciwgY29sb3IpO1xuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgbm9kZVN0eWxlLmxhYmVsICYmIHNjZW5lLmFkZChcImxhYmVsc091dGxpbmVcIiwgbmV3IF9wcmltaXRpdmUyLmRlZmF1bHQoZ2wsIG5vZGVTdHlsZSwgXCJsYWJlbFwiLCB2c0xhYmVsc1NoYWRlciwgZnNMYWJlbFRleHR1cmUsIGJpbmRMYWJlbHModHJ1ZSkpKTtcblx0ICAgIG5vZGVTdHlsZS5sYWJlbCAmJiBzY2VuZS5hZGQoXCJsYWJlbHNcIiwgbmV3IF9wcmltaXRpdmUyLmRlZmF1bHQoZ2wsIG5vZGVTdHlsZSwgXCJsYWJlbFwiLCB2c0xhYmVsc1NoYWRlciwgZnNMYWJlbFRleHR1cmUsIGJpbmRMYWJlbHMoZmFsc2UpKSk7XG5cdFxuXHQgICAgaWYgKG9wdGlvbnMub25Mb2FkKSB7XG5cdCAgICAgICAgdmFyIHN0eWxlcyA9IG9wdGlvbnMuc3R5bGVzO1xuXHQgICAgICAgIGZvciAodmFyIHAgaW4gc3R5bGVzKSB7XG5cdCAgICAgICAgICAgIHZhciBzID0gc3R5bGVzW3BdO1xuXHRcblx0ICAgICAgICAgICAgcy50ZXh0dXJlICYmIHRleHR1cmVzLmdldChnbCwgcy50ZXh0dXJlLCBvbkxvYWQpO1xuXHQgICAgICAgICAgICBzLmFycm93ICYmIHMuYXJyb3cudGV4dHVyZSAmJiB0ZXh0dXJlcy5nZXQoZ2wsIHMuYXJyb3cudGV4dHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVNjZW5lKCkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGVsZW1lbnRzOiBbXSxcblx0ICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQobmFtZSwgZSkge1xuXHQgICAgICAgICAgICAgICAgc2NlbmVbbmFtZV0gPSBlO1xuXHQgICAgICAgICAgICAgICAgc2NlbmUuZWxlbWVudHMucHVzaChlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdH07XG5cdFxuXHR2YXIgX2NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XG5cdHZhciBfY29sb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29sb3IpO1xuXHRcblx0dmFyIF9nbCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2dsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsKTtcblx0XG5cdHZhciBfcHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfcHJpbWl0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByaW1pdGl2ZSk7XG5cdFxuXHR2YXIgX2xheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdFxuXHR2YXIgX2xheW91dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sYXlvdXQpO1xuXHRcblx0dmFyIF9nZW9tdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0XG5cdHZhciBfZ2VvbXV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dlb211dGlscyk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXHRcblx0dmFyIF9wcmltaXRpdmVUb29scyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHR2YXIgX3NwYXRpYWxTZWFyY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0XG5cdHZhciBfc3BhdGlhbFNlYXJjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcGF0aWFsU2VhcmNoKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IERhdmlkIFRpY2h5XG5cdCAqL1xuXHRcblx0dmFyIENvbG9yID0gZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG5cdFxuXHQgICAgdGhpcy5hID0gMTtcblx0XG5cdCAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikge1xuXHQgICAgICAgIHRoaXMuciA9IGNvbG9yLnI7XG5cdCAgICAgICAgdGhpcy5nID0gY29sb3IuZztcblx0ICAgICAgICB0aGlzLmIgPSBjb2xvci5iO1xuXHQgICAgICAgIHRoaXMuYSA9IGNvbG9yLmE7XG5cdCAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuXHQgICAgICAgIHRoaXMuciA9IGFyZ3VtZW50c1swXTtcblx0ICAgICAgICB0aGlzLmcgPSBhcmd1bWVudHNbMV07XG5cdCAgICAgICAgdGhpcy5iID0gYXJndW1lbnRzWzJdO1xuXHQgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmICh0aGlzLmEgPSBhcmd1bWVudHNbM10pO1xuXHQgICAgfSBlbHNlIGlmICgvXnJnYmFcXCgoXFxkKyksID8oXFxkKyksID8oXFxkKyksID8oXFxkKylcXCkkL2kudGVzdChjb2xvcikpIHtcblx0ICAgICAgICBjb2xvciA9IC9ecmdiYVxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS5leGVjKGNvbG9yKTtcblx0ICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KHYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHYsIDEwKSAvIDI1NTtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB0aGlzLnIgPSBnZXQoY29sb3JbMV0pO1xuXHQgICAgICAgIHRoaXMuZyA9IGdldChjb2xvclsyXSk7XG5cdCAgICAgICAgdGhpcy5iID0gZ2V0KGNvbG9yWzNdKTtcblx0ICAgICAgICB0aGlzLmEgPSBnZXQoY29sb3JbNF0pO1xuXHQgICAgfSBlbHNlIGlmICgvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS50ZXN0KGNvbG9yKSkge1xuXHQgICAgICAgIGNvbG9yID0gL15yZ2JcXCgoXFxkKyksID8oXFxkKyksID8oXFxkKylcXCkkL2kuZXhlYyhjb2xvcik7XG5cdCAgICAgICAgdmFyIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHYsIDEwKSAvIDI1NTtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB0aGlzLnIgPSBfZ2V0KGNvbG9yWzFdKTtcblx0ICAgICAgICB0aGlzLmcgPSBfZ2V0KGNvbG9yWzJdKTtcblx0ICAgICAgICB0aGlzLmIgPSBfZ2V0KGNvbG9yWzNdKTtcblx0ICAgIH0gZWxzZSBpZiAoL15yZ2JcXCgoXFxkKylcXCUsID8oXFxkKylcXCUsID8oXFxkKylcXCVcXCkkL2kudGVzdChjb2xvcikpIHtcblx0ICAgICAgICBjb2xvciA9IC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLmV4ZWMoY29sb3IpO1xuXHQgICAgICAgIHZhciBfZ2V0MiA9IGZ1bmN0aW9uIF9nZXQyKHYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHYsIDEwKSAvIDEwMDtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB0aGlzLnIgPSBfZ2V0Mihjb2xvclsxXSk7XG5cdCAgICAgICAgdGhpcy5nID0gX2dldDIoY29sb3JbMl0pO1xuXHQgICAgICAgIHRoaXMuYiA9IF9nZXQyKGNvbG9yWzNdKTtcblx0ICAgIH0gZWxzZSBpZiAoL15cXCMoWzAtOWEtZl17Nn0pJC9pLnRlc3QoY29sb3IpKSB7XG5cdCAgICAgICAgY29sb3IgPSBwYXJzZUludChjb2xvci5zdWJzdHJpbmcoMSksIDE2KTtcblx0ICAgICAgICB0aGlzLnIgPSAoY29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1O1xuXHQgICAgICAgIHRoaXMuZyA9IChjb2xvciA+PiA4ICYgMjU1KSAvIDI1NTtcblx0ICAgICAgICB0aGlzLmIgPSAoY29sb3IgJiAyNTUpIC8gMjU1O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSAwO1xuXHQgICAgfVxuXHR9O1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ29sb3I7XG5cdDtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvKipcblx0ICogIENvcHlyaWdodCAoYykgMjAxNiwgSGVsaWthciBMYWIuXG5cdCAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgKlxuXHQgKiAgVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR1BMdjMgTGljZW5zZS5cblx0ICogIEF1dGhvcjogRGF2aWQgVGljaHlcblx0ICovXG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gX2NsYXNzKCkge1xuXHQgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIG51bGwsIFt7XG5cdCAgICAgICAga2V5OiBcImluaXRFeHRlbnNpb25zXCIsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRFeHRlbnNpb25zKGdsKSB7XG5cdCAgICAgICAgICAgIHZhciBleHRlbnNpb25zID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgICAgIChyZXN1bHRbZV0gPSBleHRlbnNpb25zLmluZGV4T2YoZSkgPj0gMCkgJiYgZ2wuZ2V0RXh0ZW5zaW9uKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogXCJjcmVhdGVTaGFkZXJcIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcblx0ICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHJlc3VsdCwgc291cmNlKTtcblx0ICAgICAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihyZXN1bHQpO1xuXHRcblx0ICAgICAgICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIocmVzdWx0LCBnbC5DT01QSUxFX1NUQVRVUykpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2cocmVzdWx0KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6IFwiY3JlYXRlVGV4dHVyZVwiLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsLCBpbWcsIG9uTG9hZCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcblx0ICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG5cdFxuXHQgICAgICAgICAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG5cdCAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcmVzdWx0KTtcblx0XG5cdCAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgfHwge30pLnNkZikge1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkxVTUlOQU5DRSwgZ2wuTFVNSU5BTkNFLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHQgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZCgpO1xuXHQgICAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbG9hZDtcblx0ICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1nO1xuXHQgICAgICAgICAgICBpbWFnZS5uYXR1cmFsV2lkdGggJiYgaW1hZ2UubmF0dXJhbEhlaWdodCAmJiBsb2FkKCk7XG5cdFxuXHQgICAgICAgICAgICByZXN1bHQuaW1hZ2UgPSBpbWFnZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiBcInVuaWZvcm1Db2xvclwiLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmlmb3JtQ29sb3IoZ2wsIGxvY2F0aW9uLCBjb2xvcikge1xuXHQgICAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6IFwib3J0aG9cIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3J0aG8obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcblx0ICAgICAgICAgICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuXHQgICAgICAgICAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG5cdCAgICAgICAgICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG5cdFxuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG5cdCAgICAgICAgICAgIHJlc3VsdFswXSA9IC0yICogbHI7XG5cdCAgICAgICAgICAgIHJlc3VsdFsxXSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFsyXSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFszXSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0XSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFs1XSA9IC0yICogYnQ7XG5cdCAgICAgICAgICAgIHJlc3VsdFs2XSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFs3XSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFs4XSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFs5XSA9IDA7XG5cdCAgICAgICAgICAgIHJlc3VsdFsxMF0gPSAyICogbmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFsxMV0gPSAwO1xuXHQgICAgICAgICAgICByZXN1bHRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcblx0ICAgICAgICAgICAgcmVzdWx0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG5cdCAgICAgICAgICAgIHJlc3VsdFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzE1XSA9IDE7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfV0pO1xuXHRcblx0ICAgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfc2hhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XG5cdHZhciBfc2hhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWRlcik7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXHRcblx0dmFyIF9wcmltaXRpdmVUb29scyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdC8qKlxuXHQgKiAgQ29weXJpZ2h0IChjKSAyMDE2LCBIZWxpa2FyIExhYi5cblx0ICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqXG5cdCAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgKiAgQXV0aG9yOiBEYXZpZCBUaWNoeVxuXHQgKi9cblx0XG5cdHZhciBwcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBwcmltaXRpdmUoZ2wsIGJhc2VTdHlsZSwgc3R5bGVQcm9wZXJ0eSwgdnMsIGZzLCBiaW5kLCBzaGFkZXJQYXJhbXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgcHJpbWl0aXZlKTtcblx0XG5cdCAgICAgICAgdmFyIHNoYWRlciA9IG5ldyBfc2hhZGVyMi5kZWZhdWx0KGdsLCB2cy5qb2luKCdcXG4nKSwgZnMuam9pbignXFxuJyksIHNoYWRlclBhcmFtcyk7XG5cdCAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcblx0ICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcblx0XG5cdCAgICAgICAgdmFyIHNlY3Rpb25zQnlTdHlsZSA9IHt9O1xuXHRcblx0ICAgICAgICB2YXIgZSA9IHt9O1xuXHQgICAgICAgIHZhciBpViA9IHZvaWQgMCxcblx0ICAgICAgICAgICAgaUkgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGlTID0gMCxcblx0ICAgICAgICAgICAgaUIgPSAwO1xuXHRcblx0ICAgICAgICB2YXIgcGFydExlbmd0aCA9IGZ1bmN0aW9uIHBhcnRMZW5ndGgoZmlsbGVyLCBwYXJ0KSB7XG5cdCAgICAgICAgICAgIGlmIChmaWxsZXIuc2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG4gPSAwO1xuXHQgICAgICAgICAgICAgICAgcGFydC5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbiArPSBmaWxsZXIuc2l6ZShlLCBwKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG47XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFydC5sZW5ndGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24gaW5pdChmaWxsZXIsIG4pIHtcblx0ICAgICAgICAgICAgaVYgPSBpSSA9IDA7XG5cdCAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLmZsb29yKHByaW1pdGl2ZS5tYXhCdWZmZXJTaXplIC8gZmlsbGVyLm51bVZlcnRpY2VzKTtcblx0ICAgICAgICAgICAgdmFyIG5WID0gTWF0aC5taW4obWF4LCBuIC0gKGlCIC0gaVMpICogbWF4KTtcblx0ICAgICAgICAgICAgdmFyIG5JID0gblYgKiBmaWxsZXIubnVtSW5kaWNlcztcblx0XG5cdCAgICAgICAgICAgIGlmICghZS5pbmRpY2VzIHx8IGUuaW5kaWNlcy5sZW5ndGggIT09IG5JKSB7XG5cdCAgICAgICAgICAgICAgICBlLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobkkpO1xuXHQgICAgICAgICAgICAgICAgblYgKj0gZmlsbGVyLm51bVZlcnRpY2VzO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgYSBpbiBzaGFkZXIuYXR0cmlidXRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGVbYV0gPSBuZXcgRmxvYXQzMkFycmF5KHNoYWRlci5hdHRyaWJ1dGVzW2FdLnNpemUgKiBuVik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB2YXIgemVyb2ZpbGxlciA9IHtcblx0ICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodiwgaVYsIGlJLCBudW1WZXJ0aWNlcywgbnVtSW5kaWNlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGljZXNhcnIgPSBbdi5pbmRpY2VzLCBpViwgaUldO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1JbmRpY2VzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbmRpY2VzYXJyLnB1c2goMCk7XG5cdCAgICAgICAgICAgICAgICB9dmFyIHZlcnRpY2VzYXJyID0gW3VuZGVmaW5lZCwgaVYsIGlJXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1WZXJ0aWNlczsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzYXJyLnB1c2goMCk7XG5cdCAgICAgICAgICAgICAgICB9Zm9yICh2YXIgayBpbiB2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09ICdpbmRpY2VzJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUuaW5kaWNlcy5hcHBseShfdGhpcywgaW5kaWNlc2Fycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXNhcnJbMF0gPSB2W2tdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUudmVydGljZXMuYXBwbHkoX3RoaXMsIHZlcnRpY2VzYXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChnbCwgc3R5bGVzLCBhZGRlciwgZGF0YSwgcGFydHMsIGdldCkge1xuXHQgICAgICAgICAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlO1xuXHRcblx0ICAgICAgICAgICAgaVMgPSAwO1xuXHQgICAgICAgICAgICBpQiA9IDA7XG5cdFxuXHQgICAgICAgICAgICBfdGhpcy5faUlzID0gbmV3IFVpbnQzMkFycmF5KGRhdGEubGVuZ3RoKTtcblx0ICAgICAgICAgICAgX3RoaXMuX2lWcyA9IG5ldyBVaW50MzJBcnJheShkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIF90aGlzLl9pQnMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIF90aGlzLl9zaXplcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcblx0XG5cdCAgICAgICAgICAgIHZhciBzdG9yZSA9IGZ1bmN0aW9uIHN0b3JlKHNlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiID0gYnVmZmVyc1tpQl07XG5cdCAgICAgICAgICAgICAgICBpZiAoIWIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBidWZmZXJzW2lCXSA9IGIgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYlthXSA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9hIGluIHNoYWRlci5hdHRyaWJ1dGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJbX2FdKTtcblx0ICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZVtfYV0sIGdsLlNUQVRJQ19EUkFXKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGIuaW5kaWNlcyk7XG5cdCAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlLmluZGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcblx0ICAgICAgICAgICAgICAgIGIubnVtSW5kaWNlcyA9IGlJO1xuXHQgICAgICAgICAgICAgICAgYi5udW1WZXJ0aWNlcyA9IGlWO1xuXHQgICAgICAgICAgICAgICAgc2VjdGlvbi5idWZmZXJzLnB1c2goYik7XG5cdCAgICAgICAgICAgICAgICBpQisrO1xuXHQgICAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBwYXJ0cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25zQnlTdHlsZVt0aGlzLnN0eWxlTmFtZV0gPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0XG5cdCAgICAgICAgICAgICAgICBpUyA9IGlCO1xuXHRcblx0ICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAoMCwgX3ByaW1pdGl2ZVRvb2xzLmdldFBhcnRpdGlvblN0eWxlKShzdHlsZXNbcF0sIGJhc2VTdHlsZSwgc3R5bGVQcm9wZXJ0eSksXG5cdCAgICAgICAgICAgICAgICAgICAgYnVmZmVyczogW10sXG5cdCAgICAgICAgICAgICAgICAgICAgc3R5bGVOYW1lOiBwXG5cdCAgICAgICAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgICAgICAgIHZhciBmaWxsZXIgPSBnZXQoc2VjdGlvbi5zdHlsZSk7XG5cdCAgICAgICAgICAgICAgICBmaWxsZXIubnVtVmVydGljZXMgPSBmaWxsZXIubnVtVmVydGljZXMgfHwgNDtcblx0ICAgICAgICAgICAgICAgIGZpbGxlci5udW1JbmRpY2VzID0gZmlsbGVyLm51bUluZGljZXMgfHwgNjtcblx0XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW3BdO1xuXHRcblx0ICAgICAgICAgICAgICAgIHZhciBwTCA9IHBhcnRMZW5ndGgoZmlsbGVyLCBwYXJ0KTtcblx0ICAgICAgICAgICAgICAgIGluaXQoZmlsbGVyLCBwTCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF4ID0gcHJpbWl0aXZlLm1heEJ1ZmZlclNpemU7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGZpbGxlci5zaXplID8gZmlsbGVyLnNpemUoZSwgcGFydFtpXSkgOiAxO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuaVYgPSBpViArIHMgKiBmaWxsZXIubnVtVmVydGljZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5pSSA9IGlJICsgcyAqIGZpbGxlci5udW1JbmRpY2VzO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobmlWID49IG1heCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZShzZWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdChmaWxsZXIsIHBMKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmlWID0gaVY7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5pSSA9IGlJO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxlci5zZXQoZSwgcGFydFtpXSwgaVYsIGlJKSkgaXNEaXJ0eSA9IHRydWU7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBwYXJ0LmlkeFtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5faUlzW2lkeF0gPSBpSTtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5faVZzW2lkeF0gPSBpVjtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5faUJzW2lkeF0gPSBpQjtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2l6ZXNbaWR4XSA9IHM7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIGlJID0gbmlJO1xuXHQgICAgICAgICAgICAgICAgICAgIGlWID0gbmlWO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc3RvcmUoc2VjdGlvbik7XG5cdFxuXHQgICAgICAgICAgICAgICAgdmFyIGFkZFNlY3Rpb24gPSBhZGQuYmluZChzZWN0aW9uKTtcblx0XG5cdCAgICAgICAgICAgICAgICBhZGRlciA/IGFkZGVyKHNlY3Rpb24sIGFkZFNlY3Rpb24pIDogYWRkU2VjdGlvbigpO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICByZXR1cm4gaXNEaXJ0eTtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB2YXIgZmIgPSB2b2lkIDA7XG5cdCAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZ2wsIGF0dHJpYnV0ZSwgZGF0YSwgZ2V0KSB7XG5cdCAgICAgICAgICAgIHZhciBpID0gMCxcblx0ICAgICAgICAgICAgICAgIHNpemUgPSBzaGFkZXIuYXR0cmlidXRlc1thdHRyaWJ1dGVdLnNpemU7XG5cdCAgICAgICAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmaWxsZXIgPSBnZXQoc2VjdGlvbi5zdHlsZSk7XG5cdCAgICAgICAgICAgICAgICBmaWxsZXIubnVtVmVydGljZXMgPSBmaWxsZXIubnVtVmVydGljZXMgfHwgNDtcblx0XG5cdCAgICAgICAgICAgICAgICBzZWN0aW9uLmJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICghZmIgfHwgZmIubGVuZ3RoICE9PSBzaXplICogZS5udW1WZXJ0aWNlcykgJiYgKGZiID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogZS5udW1WZXJ0aWNlcykpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pViA9IDA7IF9pViA8IGUubnVtVmVydGljZXM7IF9pViArPSAoZmlsbGVyLnNpemUgPyBmaWxsZXIuc2l6ZShlLCBkYXRhW2ldKSA6IDEpICogZmlsbGVyLm51bVZlcnRpY2VzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxlci5zZXQoZmIsIGRhdGFbaSsrXSwgX2lWKTtcblx0ICAgICAgICAgICAgICAgICAgICB9Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGVbYXR0cmlidXRlXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGZiLCBnbC5EWU5BTUlDX0RSQVcpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIHRoaXMudXBkYXRlRWwgPSBmdW5jdGlvbiAoZ2wsIGVsLCBwb3MsIGdldCkge1xuXHQgICAgICAgICAgICB2YXIgc3RvcmVUb1BvcyA9IGZ1bmN0aW9uIHN0b3JlVG9Qb3MoYiwgaVYsIGlJKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIHNoYWRlci5hdHRyaWJ1dGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJbYV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBzaGFkZXIuYXR0cmlidXRlc1thXS5zaXplICogaVYgKiBlW2FdLkJZVEVTX1BFUl9FTEVNRU5ULCBlW2FdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGIuaW5kaWNlcyk7XG5cdCAgICAgICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpSSAqIGUuaW5kaWNlcy5CWVRFU19QRVJfRUxFTUVOVCwgZS5pbmRpY2VzKTtcblx0ICAgICAgICAgICAgfTtcblx0XG5cdCAgICAgICAgICAgIHZhciBzZWN0aW9uID0gc2VjdGlvbnNCeVN0eWxlW2VsLnN0eWxlXTtcblx0XG5cdCAgICAgICAgICAgIHZhciBmaWxsZXIgPSBnZXQoc2VjdGlvbi5zdHlsZSk7XG5cdCAgICAgICAgICAgIGZpbGxlci5udW1WZXJ0aWNlcyA9IGZpbGxlci5udW1WZXJ0aWNlcyB8fCA0O1xuXHQgICAgICAgICAgICBmaWxsZXIubnVtSW5kaWNlcyA9IGZpbGxlci5udW1JbmRpY2VzIHx8IDY7XG5cdFxuXHQgICAgICAgICAgICBpQiA9IGlTID0gMDtcblx0XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSBzZWN0aW9uLmJ1ZmZlcnNbX3RoaXMuX2lCc1twb3NdXTtcblx0ICAgICAgICAgICAgdmFyIHMgPSBmaWxsZXIuc2l6ZSA/IGZpbGxlci5zaXplKGJ1ZmZlciwgZWwpIDogMTtcblx0ICAgICAgICAgICAgdmFyIG9sZHMgPSBfdGhpcy5fc2l6ZXNbcG9zXTtcblx0ICAgICAgICAgICAgaWYgKHMgPiBvbGRzKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3Qgc2V0IHByaW1pdGl2ZSB0byBuZXcgdmFsdWUgd2hpY2ggaGFzIGdyZWF0ZXIgc2l6ZSAoJyArIHMgKyBcIiA+IFwiICsgb2xkcyArIFwiKSAtIG5vIGVub3VnaCBlbXB0eSBzcGFjZSB0byBmaWxsIGluIEdMIGJ1ZmZlclwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaW5pdChmaWxsZXIsIG9sZHMpO1xuXHQgICAgICAgICAgICBmaWxsZXIuc2V0KGUsIGVsLCAwLCAwKTtcblx0XG5cdCAgICAgICAgICAgIGZvciAoOyBzIDwgb2xkczsgcysrKSB7XG5cdCAgICAgICAgICAgICAgICAvL3plcm8gZmlsbCBlbXB0eSBzcGFjZXNcblx0ICAgICAgICAgICAgICAgIHplcm9maWxsZXIuc2V0KGUsIHMgKiBmaWxsZXIubnVtVmVydGljZXMsIHMgKiBmaWxsZXIubnVtSW5kaWNlcywgZmlsbGVyLm51bVZlcnRpY2VzLCBmaWxsZXIubnVtSW5kaWNlcyk7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIHZhciBpViA9IF90aGlzLl9pVnNbcG9zXTtcblx0ICAgICAgICAgICAgdmFyIGlJID0gX3RoaXMuX2lJc1twb3NdO1xuXHQgICAgICAgICAgICBzdG9yZVRvUG9zKGJ1ZmZlciwgaVYsIGlJKTtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgICAgICBjb250ZXh0LnNoYWRlciA9IHNoYWRlcjtcblx0ICAgICAgICAgICAgc2hhZGVyLmJpbmQoKTtcblx0XG5cdCAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVuaWZvcm1zLnRyYW5zZm9ybSwgZmFsc2UsIGNvbnRleHQudHJhbnNmb3JtKTtcblx0XG5cdCAgICAgICAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnN0eWxlLnRleHR1cmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLnN0eWxlLnRleHR1cmUudXBkYXRlICYmIHNlY3Rpb24uc3R5bGUudGV4dHVyZS51cGRhdGUoKTtcblx0ICAgICAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblx0ICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzZWN0aW9uLnN0eWxlLnRleHR1cmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudW5pZm9ybXMudGV4dHVyZSwgMCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgY29udGV4dC5zdHlsZSA9IHNlY3Rpb24uc3R5bGU7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmluZChjb250ZXh0KSkgcmV0dXJuO1xuXHRcblx0ICAgICAgICAgICAgICAgIHNlY3Rpb24uYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZS5pbmRpY2VzKTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSBpbiBzaGFkZXIuYXR0cmlidXRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gc2hhZGVyLmF0dHJpYnV0ZXNbYV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBlW2FdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGUuaW5kZXgsIGF0dHJpYnV0ZS5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgZS5udW1JbmRpY2VzLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdFxuXHQgICAgICAgICAgICBzaGFkZXIudW5iaW5kKCk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICBfY3JlYXRlQ2xhc3MocHJpbWl0aXZlLCBudWxsLCBbe1xuXHQgICAgICAgIGtleTogJ3ZlcnRpY2VzJyxcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmVydGljZXMoYnVmZmVyLCBpVikge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgaiA9IDIgKiBpViwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyssIGorKykge1xuXHQgICAgICAgICAgICAgICAgYnVmZmVyW2pdID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ3NpbmdsZXMnLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5nbGVzKGJ1ZmZlciwgaVYpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIGogPSAxICogaVYsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrLCBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltqXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6ICdjb2xvcnMnLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xvcnMoYnVmZmVyLCBpVikge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgaiA9IDQgKiBpViwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBjLnI7XG5cdCAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IGMuZztcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gYy5iO1xuXHQgICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBjLmE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiAnaW5kaWNlcycsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluZGljZXMoYnVmZmVyLCBpViwgaUkpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDMsIGogPSBpSSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyssIGorKykge1xuXHQgICAgICAgICAgICAgICAgYnVmZmVyW2pdID0gaVYgKyBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiAncXVhZCcsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWQoYnVmZmVyLCBpViwgaUkpIHtcblx0ICAgICAgICAgICAgcHJpbWl0aXZlLmluZGljZXMoYnVmZmVyLCBpViwgaUksIDAsIDEsIDIsIDIsIDMsIDApO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6ICdtYXhCdWZmZXJTaXplJyxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDY1NTM2O1xuXHQgICAgICAgIH1cblx0ICAgIH1dKTtcblx0XG5cdCAgICByZXR1cm4gcHJpbWl0aXZlO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBwcmltaXRpdmU7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfZ2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF9nbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdC8qKlxuXHQgKiAgQ29weXJpZ2h0IChjKSAyMDE2LCBIZWxpa2FyIExhYi5cblx0ICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqXG5cdCAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgKiAgQXV0aG9yOiBEYXZpZCBUaWNoeVxuXHQgKi9cblx0XG5cdHZhciBkZWZhdWx0QXR0ciA9IHsgY29sb3I6IDQgfTtcblx0XG5cdHZhciBTaGFkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gU2hhZGVyKGdsLCB2cywgZnMsIHNoYWRlclBhcmFtcykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRlcik7XG5cdFxuXHQgICAgdGhpcy5fZ2wgPSBnbDtcblx0ICAgIHRoaXMuX3ZzID0gdnM7XG5cdCAgICB0aGlzLl9mcyA9IGZzO1xuXHRcblx0ICAgIHZhciBwcm9ncmFtID0gdGhpcy5fcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblx0XG5cdCAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgX2dsMi5kZWZhdWx0LmNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdnMpKTtcblx0ICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBfZ2wyLmRlZmF1bHQuY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZzKSk7XG5cdCAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblx0XG5cdCAgICB0aGlzLnVuaWZvcm1zID0ge307XG5cdCAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgIHZhciBuYW1lID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKS5uYW1lO1xuXHQgICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciBhdHRyUGFyYW1zID0gKHNoYWRlclBhcmFtcyB8fCB7fSkuYXR0cmlidXRlIHx8IHt9O1xuXHRcblx0ICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHQgICAgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuXHQgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG47IF9pKyspIHtcblx0ICAgICAgdmFyIF9uYW1lID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIF9pKS5uYW1lO1xuXHQgICAgICB0aGlzLmF0dHJpYnV0ZXNbX25hbWVdID0geyBpbmRleDogX2ksIHNpemU6IGF0dHJQYXJhbXNbX25hbWVdIHx8IFNoYWRlci5hdHRyaWJ1dGVbX25hbWVdIHx8IDIgfTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhTaGFkZXIsIFt7XG5cdCAgICBrZXk6ICdiaW5kJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKCkge1xuXHQgICAgICB0aGlzLl9nbC51c2VQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuXHRcblx0ICAgICAgdmFyIG4gPSB0aGlzLl9nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuX3Byb2dyYW0sIHRoaXMuX2dsLkFDVElWRV9BVFRSSUJVVEVTKTtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICB0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3VuYmluZCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kKCkge1xuXHQgICAgICB2YXIgbiA9IHRoaXMuX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fcHJvZ3JhbSwgdGhpcy5fZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIHRoaXMuX2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiAnYXR0cmlidXRlJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gZGVmYXVsdEF0dHI7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gU2hhZGVyO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBTaGFkZXI7XG5cdDtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3JzOiBEYXZpZCBUaWNoeSwgQWxlxaEgU2Fza2Fcblx0ICovXG5cdFxuXHR2YXIgVXRpbHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gVXRpbHMoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXRpbHMpO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKFV0aWxzLCBudWxsLCBbe1xuXHQgICAga2V5OiBcImV4dGVuZFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZChmcm9tKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHNbaV0pIHtcblx0ICAgICAgICAgIGZyb21ba10gPSBhcmd1bWVudHNbaV1ba107XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBmcm9tO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJpc09iamVjdFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuXHQgICAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZW1wdHlPYmplY3RcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eU9iamVjdChvYmopIHtcblx0ICAgICAgaWYgKCFVdGlscy5pc09iamVjdChvYmopKSByZXR1cm4gZmFsc2U7XG5cdFxuXHQgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfXJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJhamF4XCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYWpheCh1cmwsIGNhbGxiYWNrLCB0eXBlKSB7XG5cdCAgICAgIHZhciB4bWxodHRwO1xuXHQgICAgICAvLyBjb21wYXRpYmxlIHdpdGggSUU3KywgRmlyZWZveCwgQ2hyb21lLCBPcGVyYSwgU2FmYXJpXG5cdCAgICAgIHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgICAgeG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoY2JrKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGlmICh4bWxodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiB4bWxodHRwLnN0YXR1cyA9PSAyMDApIHtcblx0ICAgICAgICAgICAgY2JrKHR5cGUgPT0gJ2FycmF5YnVmZmVyJyA/IHhtbGh0dHAucmVzcG9uc2UgOiB4bWxodHRwLnJlc3BvbnNlVGV4dCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgfShjYWxsYmFjayk7XG5cdCAgICAgIGlmICh0eXBlKSB4bWxodHRwLnJlc3BvbnNlVHlwZSA9IHR5cGU7XG5cdCAgICAgIHhtbGh0dHAub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuXHQgICAgICB4bWxodHRwLnNlbmQoKTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBVdGlscztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gVXRpbHM7XG5cdDtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5nZXRQYXJ0aXRpb25TdHlsZSA9IGV4cG9ydHMucGFydGl0aW9uQnlTdHlsZSA9IHVuZGVmaW5lZDtcblx0XG5cdHZhciBfY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9jb2xvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb2xvcik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gcGFydGl0aW9uQnlTdHlsZShkYXRhKSB7XG5cdCAgICB2YXIgcGFydHMgPSB7fTtcblx0XG5cdCAgICB2YXIgcE4gPSB7fTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBlbCA9IGRhdGFbaV07XG5cdCAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tlbC5zdHlsZV0gPSBwYXJ0c1tlbC5zdHlsZV0gfHwgW107XG5cdCAgICAgICAgaWYgKHBhcnQuaWR4ID09PSB1bmRlZmluZWQpIHBhcnQuaWR4ID0gW107XG5cdCAgICAgICAgcGFydC5pZHgucHVzaChpKTtcblx0XG5cdCAgICAgICAgZWwuc0kgPSBwTltlbC5zdHlsZV0gPSBwTltlbC5zdHlsZV0gPT09IHVuZGVmaW5lZCA/IDAgOiBwTltlbC5zdHlsZV0gKyAxO1xuXHRcblx0ICAgICAgICBwYXJ0LnB1c2goZWwpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBwYXJ0cztcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0UGFydGl0aW9uU3R5bGUoc3R5bGUsIGJhc2VTdHlsZSwgc3R5bGVQcm9wZXJ0eSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHRcblx0ICAgIHZhciBjb3B5ID0gZnVuY3Rpb24gY29weShzKSB7XG5cdCAgICAgICAgaWYgKHMpIGZvciAodmFyIHAgaW4gcykge1xuXHQgICAgICAgICAgICByZXN1bHRbcF0gPSBzW3BdO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgY29weShiYXNlU3R5bGUpO1xuXHQgICAgY29weShzdHlsZSk7XG5cdFxuXHQgICAgaWYgKHN0eWxlUHJvcGVydHkpIHtcblx0ICAgICAgICBjb3B5KGJhc2VTdHlsZVtzdHlsZVByb3BlcnR5XSk7XG5cdCAgICAgICAgc3R5bGUgJiYgY29weShzdHlsZVtzdHlsZVByb3BlcnR5XSk7XG5cdCAgICB9XG5cdCAgICByZXN1bHQuY29sb3IgPSByZXN1bHQuY29sb3IgJiYgbmV3IF9jb2xvcjIuZGVmYXVsdChyZXN1bHQuY29sb3IpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0XG5cdGV4cG9ydHMucGFydGl0aW9uQnlTdHlsZSA9IHBhcnRpdGlvbkJ5U3R5bGU7XG5cdGV4cG9ydHMuZ2V0UGFydGl0aW9uU3R5bGUgPSBnZXRQYXJ0aXRpb25TdHlsZTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF9mb3JjZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHRcblx0dmFyIF9mb3JjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JjZSk7XG5cdFxuXHR2YXIgX3JhbmRvbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHRcblx0dmFyIF9yYW5kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZG9tKTtcblx0XG5cdHZhciBfY2lyY3VsYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0XG5cdHZhciBfY2lyY3VsYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2lyY3VsYXIpO1xuXHRcblx0dmFyIF90cmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgX3RyZWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHJlZSk7XG5cdFxuXHR2YXIgX3RyZWVUID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdFxuXHR2YXIgX3RyZWVUMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyZWVUKTtcblx0XG5cdHZhciBfaGllcmFyY2hpY2FsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdFxuXHR2YXIgX2hpZXJhcmNoaWNhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaWVyYXJjaGljYWwpO1xuXHRcblx0dmFyIF9oaWVyYXJjaGljYWwzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdFxuXHR2YXIgX2hpZXJhcmNoaWNhbDQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaWVyYXJjaGljYWwzKTtcblx0XG5cdHZhciBfc3BlY3RyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblx0XG5cdHZhciBfc3BlY3RyYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3BlY3RyYWwpO1xuXHRcblx0dmFyIF9zcGVjdHJhbDMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0XG5cdHZhciBfc3BlY3RyYWw0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3BlY3RyYWwzKTtcblx0XG5cdHZhciBfaGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXHRcblx0dmFyIF9oaXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hpdmUpO1xuXHRcblx0dmFyIF9ncmlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cdFxuXHR2YXIgX2dyaWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JpZCk7XG5cdFxuXHR2YXIgX3ZlcnNpbnVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cdFxuXHR2YXIgX3ZlcnNpbnVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlcnNpbnVzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IERhdmlkIFRpY2h5XG5cdCAqL1xuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBfY2xhc3MoKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIG51bGwsIFt7XG5cdCAgICBrZXk6ICdub3JtYWxpemUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShub2RlcywgZGltKSB7XG5cdCAgICAgIHZhciBtaW5YID0gdm9pZCAwLFxuXHQgICAgICAgICAgbWluWSA9IHZvaWQgMCxcblx0ICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGg7XG5cdFxuXHQgICAgICBpZiAoZGltKSB7XG5cdCAgICAgICAgbWluWCA9IGRpbS5taW5YO1xuXHQgICAgICAgIG1pblkgPSBkaW0ubWluWTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcblx0ICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblx0ICAgICAgICBtaW5YID0gbWluWSA9IEluZmluaXR5O1xuXHRcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgdmFyIG8gPSBub2Rlc1tpXTtcblx0ICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBvLngpO1xuXHQgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIG8ueSk7XG5cdCAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgby54KTtcblx0ICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBvLnkpO1xuXHQgICAgICAgIH07XG5cdFxuXHQgICAgICAgIGRpbSA9IHtcblx0ICAgICAgICAgIG1heFg6IG1heFgsXG5cdCAgICAgICAgICBtYXhZOiBtYXhZLFxuXHQgICAgICAgICAgbWluWDogbWluWCxcblx0ICAgICAgICAgIG1pblk6IG1pbllcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgc2NYID0gbWluWCAhPT0gZGltLm1heFggPyAxIC8gKGRpbS5tYXhYIC0gbWluWCkgOiAobWluWCAtPSAwLjUsIDEpO1xuXHQgICAgICB2YXIgc2NZID0gbWluWSAhPT0gZGltLm1heFkgPyAxIC8gKGRpbS5tYXhZIC0gbWluWSkgOiAobWluWSAtPSAwLjUsIDEpO1xuXHRcblx0ICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG47IF9pKyspIHtcblx0ICAgICAgICB2YXIgX28gPSBub2Rlc1tfaV07XG5cdCAgICAgICAgX28ueCA9IHNjWCAqIChfby54IC0gbWluWCk7XG5cdCAgICAgICAgX28ueSA9IHNjWSAqIChfby55IC0gbWluWSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBkaW07XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZm9yY2UnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBfZm9yY2UyLmRlZmF1bHQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAncmFuZG9tJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gX3JhbmRvbTIuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdjaXJjdWxhcicsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIF9jaXJjdWxhcjIuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICd0cmVlJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gX3RyZWUyLmRlZmF1bHQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAndHJlZTInLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBfdHJlZVQyLmRlZmF1bHQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaGllcmFyY2hpY2FsJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gX2hpZXJhcmNoaWNhbDIuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdoaWVyYXJjaGljYWwyJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gX2hpZXJhcmNoaWNhbDQuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdzcGVjdHJhbCcsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIF9zcGVjdHJhbDIuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdzcGVjdHJhbDInLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBfc3BlY3RyYWw0LmRlZmF1bHQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaGl2ZScsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIF9oaXZlMi5kZWZhdWx0O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2dyaWQnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiBfZ3JpZDIuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICd2ZXJzaW51cycsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIF92ZXJzaW51czIuZGVmYXVsdDtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gX2NsYXNzO1xuXHR9KCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlcywgZWRnZXMsIG9wdGlvbnMpIHtcblx0ICAgIHZhciBlZGdlRGlzdGFuY2UgPSAxNSxcblx0ICAgICAgICBlZGdlU3RyZW5ndGggPSAxLFxuXHQgICAgICAgIGZyaWN0aW9uID0gMC45LFxuXHQgICAgICAgIGNoYXJnZSA9IC0zMCxcblx0ICAgICAgICBncmF2aXR5ID0gMC40LFxuXHQgICAgICAgIHRoZXRhMiA9IC42NCxcblx0ICAgICAgICBzaXplID0gWzEsIDFdLFxuXHQgICAgICAgIGNoYXJnZURpc3RhbmNlMiA9IEluZmluaXR5O1xuXHRcblx0ICAgIHZhciBhbHBoYSA9IHZvaWQgMCxcblx0ICAgICAgICBkaXN0YW5jZXMgPSBbXSxcblx0ICAgICAgICBzdHJlbmd0aHMgPSBbXSxcblx0ICAgICAgICBjaGFyZ2VzID0gW107XG5cdFxuXHQgICAgZnVuY3Rpb24gYWNjdW11bGF0ZShxdWFkLCBhbHBoYSwgY2hhcmdlcykge1xuXHQgICAgICAgIHZhciBjeCA9IDAsXG5cdCAgICAgICAgICAgIGN5ID0gMDtcblx0ICAgICAgICBxdWFkLmNoYXJnZSA9IDA7XG5cdCAgICAgICAgaWYgKCFxdWFkLmxlYWYpIHtcblx0ICAgICAgICAgICAgdmFyIF9ub2RlcyA9IHF1YWQubm9kZXM7XG5cdCAgICAgICAgICAgIHZhciBjID0gdm9pZCAwLFxuXHQgICAgICAgICAgICAgICAgbiA9IF9ub2Rlcy5sZW5ndGg7XG5cdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgYyA9IF9ub2Rlc1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChjID09IG51bGwpIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgYWNjdW11bGF0ZShjLCBhbHBoYSwgY2hhcmdlcyk7XG5cdCAgICAgICAgICAgICAgICBxdWFkLmNoYXJnZSArPSBjLmNoYXJnZTtcblx0ICAgICAgICAgICAgICAgIGN4ICs9IGMuY2hhcmdlICogYy5jeDtcblx0ICAgICAgICAgICAgICAgIGN5ICs9IGMuY2hhcmdlICogYy5jeTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocXVhZC5wb2ludCkge1xuXHQgICAgICAgICAgICBpZiAoIXF1YWQubGVhZikge1xuXHQgICAgICAgICAgICAgICAgcXVhZC5wb2ludC54ICs9IE1hdGgucmFuZG9tKCkgLSAwLjU7XG5cdCAgICAgICAgICAgICAgICBxdWFkLnBvaW50LnkgKz0gTWF0aC5yYW5kb20oKSAtIDAuNTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgayA9IGFscGhhICogY2hhcmdlc1txdWFkLnBvaW50LmluZGV4XTtcblx0ICAgICAgICAgICAgcXVhZC5jaGFyZ2UgKz0gcXVhZC5wb2ludENoYXJnZSA9IGs7XG5cdCAgICAgICAgICAgIGN4ICs9IGsgKiBxdWFkLnBvaW50Lng7XG5cdCAgICAgICAgICAgIGN5ICs9IGsgKiBxdWFkLnBvaW50Lnk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHF1YWQuY3ggPSBjeCAvIHF1YWQuY2hhcmdlO1xuXHQgICAgICAgIHF1YWQuY3kgPSBjeSAvIHF1YWQuY2hhcmdlO1xuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIHJlcHVsc2Uobm9kZSkge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAocXVhZCwgeDEsIF8sIHgyKSB7XG5cdCAgICAgICAgICAgIGlmIChxdWFkLnBvaW50ICE9PSBub2RlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZHggPSBxdWFkLmN4IC0gbm9kZS54O1xuXHQgICAgICAgICAgICAgICAgdmFyIGR5ID0gcXVhZC5jeSAtIG5vZGUueTtcblx0ICAgICAgICAgICAgICAgIHZhciBkdyA9IHgyIC0geDE7XG5cdCAgICAgICAgICAgICAgICB2YXIgZG4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcblx0XG5cdCAgICAgICAgICAgICAgICBpZiAoZHcgKiBkdyAvIHRoZXRhMiA8IGRuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRuIDwgY2hhcmdlRGlzdGFuY2UyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gcXVhZC5jaGFyZ2UgLyBkbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5weCAtPSBkeCAqIGs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucHkgLT0gZHkgKiBrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBpZiAocXVhZC5wb2ludCAmJiBkbiAmJiBkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfayA9IHF1YWQucG9pbnRDaGFyZ2UgLyBkbjtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnB4IC09IGR4ICogX2s7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5weSAtPSBkeSAqIF9rO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiAhcXVhZC5jaGFyZ2U7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBzdGVwKCkge1xuXHQgICAgICAgIGlmICgoYWxwaGEgKj0gLjk5KSA8IC4wNSkge1xuXHQgICAgICAgICAgICBhbHBoYSA9IDA7XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIHEgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIG8gPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHMgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHQgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGwgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIGsgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHggPSB2b2lkIDAsXG5cdCAgICAgICAgICAgIHkgPSB2b2lkIDA7XG5cdCAgICAgICAgdmFyIG4gPSBub2Rlcy5sZW5ndGg7XG5cdCAgICAgICAgdmFyIG0gPSBlZGdlcy5sZW5ndGg7XG5cdFxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcblx0ICAgICAgICAgICAgcyA9IG8uc291cmNlO1xuXHQgICAgICAgICAgICB0ID0gby50YXJnZXQ7XG5cdCAgICAgICAgICAgIHggPSB0LnggLSBzLng7XG5cdCAgICAgICAgICAgIHkgPSB0LnkgLSBzLnk7XG5cdCAgICAgICAgICAgIGlmIChsID0geCAqIHggKyB5ICogeSkge1xuXHQgICAgICAgICAgICAgICAgbCA9IGFscGhhICogc3RyZW5ndGhzW2ldICogKChsID0gTWF0aC5zcXJ0KGwpKSAtIGRpc3RhbmNlc1tpXSkgLyBsO1xuXHQgICAgICAgICAgICAgICAgeCAqPSBsO1xuXHQgICAgICAgICAgICAgICAgeSAqPSBsO1xuXHQgICAgICAgICAgICAgICAgdC54IC09IHggKiAoayA9IHMud2VpZ2h0IC8gKHQud2VpZ2h0ICsgcy53ZWlnaHQpKTtcblx0ICAgICAgICAgICAgICAgIHQueSAtPSB5ICogaztcblx0ICAgICAgICAgICAgICAgIHMueCArPSB4ICogKGsgPSAxIC0gayk7XG5cdCAgICAgICAgICAgICAgICBzLnkgKz0geSAqIGs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChrID0gYWxwaGEgKiBncmF2aXR5KSB7XG5cdCAgICAgICAgICAgIHggPSBzaXplWzBdIC8gMjtcblx0ICAgICAgICAgICAgeSA9IHNpemVbMV0gLyAyO1xuXHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG47IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIG8gPSBub2Rlc1tfaV07XG5cdCAgICAgICAgICAgICAgICBvLnggKz0gKHggLSBvLngpICogaztcblx0ICAgICAgICAgICAgICAgIG8ueSArPSAoeSAtIG8ueSkgKiBrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoY2hhcmdlKSB7XG5cdCAgICAgICAgICAgIGFjY3VtdWxhdGUocSA9ICgwLCBfcXVhZFRyZWUyLmRlZmF1bHQpKG5vZGVzKSwgYWxwaGEsIGNoYXJnZXMpO1xuXHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfbyA9IG5vZGVzW19pMl07XG5cdCAgICAgICAgICAgICAgICAhX28uZml4ZWQgJiYgcS52aXNpdChyZXB1bHNlKF9vKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBybmQgPSBmdW5jdGlvbiBybmQobWluLCBtYXgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG47IF9pMysrKSB7XG5cdCAgICAgICAgICAgIG8gPSBub2Rlc1tfaTNdO1xuXHQgICAgICAgICAgICBpZiAoby5maXhlZCB8fCBvLmZpeGVkMikge1xuXHQgICAgICAgICAgICAgICAgby54ID0gby5weDtcblx0ICAgICAgICAgICAgICAgIG8ueSA9IG8ucHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvLnggLT0gKG8ucHggLSAoby5weCA9IG8ueCkpICogZnJpY3Rpb247XG5cdCAgICAgICAgICAgICAgICBvLnkgLT0gKG8ucHkgLSAoby5weSA9IG8ueSkpICogZnJpY3Rpb247XG5cdFxuXHQgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5YICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoby54IDwgb3B0aW9ucy5taW5YIHx8IG8ueCA+IG9wdGlvbnMubWF4WCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvLnggPSBybmQob3B0aW9ucy5taW5YLCBvcHRpb25zLm1heFgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoby55IDwgb3B0aW9ucy5taW5ZIHx8IG8ueSA+IG9wdGlvbnMubWF4WSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvLnkgPSBybmQob3B0aW9ucy5taW5ZLCBvcHRpb25zLm1heFkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdFxuXHQgICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbiA9IG5vZGVzLmxlbmd0aDtcblx0ICAgICAgICB2YXIgZCA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICB2YXIgcyA9IDAuMyAvIGQ7XG5cdFxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBvID0gbm9kZXNbaV07XG5cdCAgICAgICAgICAgIG8ud2VpZ2h0ID0gMDtcblx0ICAgICAgICAgICAgby54ID0gby54ICE9PSB1bmRlZmluZWQgPyBvLnggOiBzICsgaSAlIGQgLyBkO1xuXHQgICAgICAgICAgICBvLnkgPSBvLnkgIT09IHVuZGVmaW5lZCA/IG8ueSA6IHMgKyBNYXRoLmZsb29yKGkgLyBkKSAvIGQ7XG5cdCAgICAgICAgICAgIG8ucHggPSBvLng7XG5cdCAgICAgICAgICAgIG8ucHkgPSBvLnk7XG5cdCAgICAgICAgICAgIGNoYXJnZXNbaV0gPSBjaGFyZ2U7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBlZGdlcy5sZW5ndGg7IF9pNCsrKSB7XG5cdCAgICAgICAgICAgIHZhciBfbzIgPSBlZGdlc1tfaTRdO1xuXHQgICAgICAgICAgICBfbzIuc291cmNlLndlaWdodCsrO1xuXHQgICAgICAgICAgICBfbzIudGFyZ2V0LndlaWdodCsrO1xuXHQgICAgICAgICAgICBkaXN0YW5jZXNbX2k0XSA9IGVkZ2VEaXN0YW5jZTtcblx0ICAgICAgICAgICAgc3RyZW5ndGhzW19pNF0gPSBlZGdlU3RyZW5ndGg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBhbHBoYSA9IDAuMTtcblx0ICAgICAgICB3aGlsZSAoIXN0ZXAoKSkge31cblx0XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9O1xuXHR9O1xuXHRcblx0dmFyIF9xdWFkVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0dmFyIF9xdWFkVHJlZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWFkVHJlZSk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0O1xuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IERhdmlkIFRpY2h5XG5cdCAqL1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHBvaW50cykge1xuXHQgICAgdmFyIGQgPSB2b2lkIDAsXG5cdCAgICAgICAgeHMgPSB2b2lkIDAsXG5cdCAgICAgICAgeXMgPSB2b2lkIDAsXG5cdCAgICAgICAgaSA9IHZvaWQgMCxcblx0ICAgICAgICBuID0gdm9pZCAwLFxuXHQgICAgICAgIHgxXyA9IHZvaWQgMCxcblx0ICAgICAgICB5MV8gPSB2b2lkIDAsXG5cdCAgICAgICAgeDJfID0gdm9pZCAwLFxuXHQgICAgICAgIHkyXyA9IHZvaWQgMDtcblx0XG5cdCAgICB4Ml8gPSB5Ml8gPSAtKHgxXyA9IHkxXyA9IEluZmluaXR5KTtcblx0ICAgIHhzID0gW10sIHlzID0gW107XG5cdCAgICBuID0gcG9pbnRzLmxlbmd0aDtcblx0XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG5cdCAgICAgICAgZCA9IHBvaW50c1tpXTtcblx0ICAgICAgICBpZiAoZC54IDwgeDFfKSB4MV8gPSBkLng7XG5cdCAgICAgICAgaWYgKGQueSA8IHkxXykgeTFfID0gZC55O1xuXHQgICAgICAgIGlmIChkLnggPiB4Ml8pIHgyXyA9IGQueDtcblx0ICAgICAgICBpZiAoZC55ID4geTJfKSB5Ml8gPSBkLnk7XG5cdCAgICAgICAgeHMucHVzaChkLngpO1xuXHQgICAgICAgIHlzLnB1c2goZC55KTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgZHggPSB4Ml8gLSB4MV87XG5cdCAgICB2YXIgZHkgPSB5Ml8gLSB5MV87XG5cdCAgICBkeCA+IGR5ID8geTJfID0geTFfICsgZHggOiB4Ml8gPSB4MV8gKyBkeTtcblx0XG5cdCAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbGVhZjogdHJ1ZSxcblx0ICAgICAgICAgICAgbm9kZXM6IFtdLFxuXHQgICAgICAgICAgICBwb2ludDogbnVsbCxcblx0ICAgICAgICAgICAgeDogbnVsbCxcblx0ICAgICAgICAgICAgeTogbnVsbFxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgZnVuY3Rpb24gdmlzaXQoZiwgbm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcblx0ICAgICAgICBpZiAoIWYobm9kZSwgeDEsIHkxLCB4MiwgeTIpKSB7XG5cdCAgICAgICAgICAgIHZhciBzeCA9ICh4MSArIHgyKSAqIDAuNTtcblx0ICAgICAgICAgICAgdmFyIHN5ID0gKHkxICsgeTIpICogMC41O1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLm5vZGVzO1xuXHRcblx0ICAgICAgICAgICAgaWYgKGNoaWxkcmVuWzBdKSB2aXNpdChmLCBjaGlsZHJlblswXSwgeDEsIHkxLCBzeCwgc3kpO1xuXHQgICAgICAgICAgICBpZiAoY2hpbGRyZW5bMV0pIHZpc2l0KGYsIGNoaWxkcmVuWzFdLCBzeCwgeTEsIHgyLCBzeSk7XG5cdCAgICAgICAgICAgIGlmIChjaGlsZHJlblsyXSkgdmlzaXQoZiwgY2hpbGRyZW5bMl0sIHgxLCBzeSwgc3gsIHkyKTtcblx0ICAgICAgICAgICAgaWYgKGNoaWxkcmVuWzNdKSB2aXNpdChmLCBjaGlsZHJlblszXSwgc3gsIHN5LCB4MiwgeTIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBpbnNlcnQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcblx0ICAgICAgICBpZiAobi5sZWFmKSB7XG5cdCAgICAgICAgICAgIHZhciBueCA9IG4ueDtcblx0ICAgICAgICAgICAgdmFyIG55ID0gbi55O1xuXHRcblx0ICAgICAgICAgICAgaWYgKG54ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobnggPT09IHggJiYgbnkgPT09IHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuUG9pbnQgPSBuLnBvaW50O1xuXHQgICAgICAgICAgICAgICAgICAgIG4ueCA9IG4ueSA9IG4ucG9pbnQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIG5Qb2ludCwgbngsIG55LCB4MSwgeTEsIHgyLCB5Mik7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbi54ID0geCwgbi55ID0geSwgbi5wb2ludCA9IGQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZ1bmN0aW9uIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG5cdCAgICAgICAgdmFyIHhtID0gKHgxICsgeDIpICogMC41O1xuXHQgICAgICAgIHZhciB5bSA9ICh5MSArIHkyKSAqIDAuNTtcblx0ICAgICAgICB2YXIgcmlnaHQgPSB4ID49IHhtO1xuXHQgICAgICAgIHZhciBiZWxvdyA9IHkgPj0geW07XG5cdCAgICAgICAgdmFyIGkgPSBiZWxvdyA8PCAxIHwgcmlnaHQ7XG5cdFxuXHQgICAgICAgIG4ubGVhZiA9IGZhbHNlO1xuXHQgICAgICAgIG4gPSBuLm5vZGVzW2ldIHx8IChuLm5vZGVzW2ldID0gY3JlYXRlKCkpO1xuXHRcblx0ICAgICAgICByaWdodCA/IHgxID0geG0gOiB4MiA9IHhtO1xuXHQgICAgICAgIGJlbG93ID8geTEgPSB5bSA6IHkyID0geW07XG5cdCAgICAgICAgaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBmaW5kTm9kZShyb290LCB4LCB5LCB4MCwgeTAsIHgzLCB5Mykge1xuXHQgICAgICAgIHZhciBtaW5EaXN0YW5jZTIgPSBJbmZpbml0eTtcblx0ICAgICAgICB2YXIgY2xvc2VzdFBvaW50ID0gdm9pZCAwO1xuXHRcblx0ICAgICAgICAoZnVuY3Rpb24gZmluZChub2RlLCB4MSwgeTEsIHgyLCB5Mikge1xuXHQgICAgICAgICAgICBpZiAoeDEgPiB4MyB8fCB5MSA+IHkzIHx8IHgyIDwgeDAgfHwgeTIgPCB5MCkgcmV0dXJuO1xuXHRcblx0ICAgICAgICAgICAgaWYgKHBvaW50ID0gbm9kZS5wb2ludCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9wb2ludCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHZhciBfZHggPSB4IC0gbm9kZS54O1xuXHQgICAgICAgICAgICAgICAgdmFyIF9keSA9IHkgLSBub2RlLnk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UyID0gX2R4ICogX2R4ICsgX2R5ICogX2R5O1xuXHRcblx0ICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZTIgPCBtaW5EaXN0YW5jZTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UyID0gZGlzdGFuY2UyKTtcblx0ICAgICAgICAgICAgICAgICAgICB4MCA9IHggLSBkaXN0YW5jZSwgeTAgPSB5IC0gZGlzdGFuY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgeDMgPSB4ICsgZGlzdGFuY2UsIHkzID0geSArIGRpc3RhbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RQb2ludCA9IF9wb2ludDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5ub2Rlcztcblx0ICAgICAgICAgICAgdmFyIHhtID0gKHgxICsgeDIpICogLjU7XG5cdCAgICAgICAgICAgIHZhciB5bSA9ICh5MSArIHkyKSAqIC41O1xuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB4ID49IHhtO1xuXHQgICAgICAgICAgICB2YXIgYmVsb3cgPSB5ID49IHltO1xuXHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSBiZWxvdyA8PCAxIHwgcmlnaHQsIGogPSBfaSArIDQ7IF9pIDwgajsgKytfaSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUgPSBjaGlsZHJlbltfaSAmIDNdKSBzd2l0Y2ggKF9pICYgMykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmluZChub2RlLCB4MSwgeTEsIHhtLCB5bSk7YnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5MSwgeDIsIHltKTticmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpbmQobm9kZSwgeDEsIHltLCB4bSwgeTIpO2JyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmluZChub2RlLCB4bSwgeW0sIHgyLCB5Mik7YnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KShyb290LCB4MCwgeTAsIHgzLCB5Myk7XG5cdFxuXHQgICAgICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIHJvb3QgPSBjcmVhdGUoKTtcblx0ICAgIHJvb3QudmlzaXQgPSBmdW5jdGlvbiAoZikge1xuXHQgICAgICAgIHJldHVybiB2aXNpdChmLCByb290LCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuXHQgICAgfTtcblx0ICAgIHJvb3QuZmluZCA9IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICAgICAgcmV0dXJuIGZpbmROb2RlKHJvb3QsIHgsIHksIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICBpbnNlcnQocm9vdCwgcG9pbnRzW2ldLCB4c1tpXSwgeXNbaV0sIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG5cdCAgICB9LS1pO1xuXHRcblx0ICAgIHhzID0geXMgPSBwb2ludHMgPSBkID0gbnVsbDtcblx0XG5cdCAgICByZXR1cm4gcm9vdDtcblx0fTtcblx0XG5cdDsgLyoqXG5cdCAgICogIENvcHlyaWdodCAoYykgMjAxNiwgSGVsaWthciBMYWIuXG5cdCAgICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAgICpcblx0ICAgKiAgVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR1BMdjMgTGljZW5zZS5cblx0ICAgKiAgQXV0aG9yOiBEYXZpZCBUaWNoeVxuXHQgICAqL1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IERhdmlkIFRpY2h5XG5cdCAqL1xuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBfY2xhc3Mobm9kZXMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHRcblx0ICAgIHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBbe1xuXHQgICAga2V5OiBcImFwcGx5XCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdGhpcy5fbm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG8gPSB0aGlzLl9ub2Rlc1tpXTtcblx0ICAgICAgICBvLnggPSBNYXRoLnJhbmRvbSgpO1xuXHQgICAgICAgIG8ueSA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIENvcHlyaWdodCAoYykgMjAxNywgSGVsaWthciBMYWIuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR1BMdjMgTGljZW5zZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBdXRob3I6IFJlbmF0byBGYWJicmlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHRcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBfY2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBnZXQgZGVncmVlIG9mIGFsbCBub2Rlc1xuXHQgICAgLy8gbGV0IHVzZXIgZGVmaW5lIGF0IGxlYXN0OiBzdGFydGluZyBhbmdsZSBhbmQgcmFkaXVzIGFuZFxuXHQgICAgLy8gY2xvY2svY2Nsb2NrIGRpcmVjdGlvblxuXHQgICAgLy8gc2l6ZSBvZiB2ZXJ0aWNlc1xuXHQgICAgLy8gbW9yZTogYSByYXRpbyBvZiBjb21wYWN0bmVzcyBmb3IgdGhlIG1vcmUvbGVzcyBjb25uZWN0ZWQgbm9kZXNcblx0ICAgIC8vIGEgc3BpcmFsIHJhdGlvIHdpdGggYSByb3RhdGlvbiByYXRpbyBmb3IgaGF2aW5nIG1vcmUgdGhhbiAycGlcblx0ICAgIC8vIGRpc3RyaWJ1dGlvbiBvZiBub2RlcyB3aGVuIHNwaXJpbGluZ1xuXHQgICAgLy8gdXNlIHNvbWUgb3RoZXIgb3JkZXJpbmcgY3JpdGVyaW9uIHRoYW4gZGVncmVlPyBTdHJlbmd0aD9cblx0ICAgIC8vIGRlZmluZWQgYnkgdXNlciBhbmQgZm91bmQgYXMgYXR0cmlidXRlIG9mIGVhY2ggbm9kZT9cblx0ICAgIC8vIHJhbmRvbSBvcmRlcmluZywgbWluaW1hbCBjcm9zc2luZyBvZiBlZGdlcz9cblx0ICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMsIGxheW91dF9vcHRpb25zKSB7XG5cdCAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cdFxuXHQgICAgICAgIHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdCAgICAgICAgdGhpcy5fZWRnZXMgPSBlZGdlcztcblx0ICAgICAgICB0aGlzLl9hbmdsZV9zdGVwID0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGg7XG5cdCAgICAgICAgaWYgKGxheW91dF9vcHRpb25zLnN0YXJ0aW5nX2FuZ2xlID09IG51bGwpIHRoaXMuX3N0YXJ0aW5nX2FuZ2xlID0gMDtlbHNlIHRoaXMuX3N0YXJ0aW5nX2FuZ2xlID0gbGF5b3V0X29wdGlvbnMuc3RhcnRpbmdfYW5nbGU7XG5cdCAgICB9XG5cdFxuXHQgICAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcblx0ICAgICAgICBrZXk6ICdhcHBseScsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuXHQgICAgICAgICAgICB2YXIgbmQgPSAoMCwgX3V0aWxzLmRlZ3JlZXMpKHRoaXMuX25vZGVzLCB0aGlzLl9lZGdlcyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW25kLm5vZGVzW2ldLmluZGV4XS54ID0gMC4wNSArICgxICsgTWF0aC5jb3ModGhpcy5fc3RhcnRpbmdfYW5nbGUgKyBpICogdGhpcy5fYW5nbGVfc3RlcCkpICogLjQ1O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaV0uaW5kZXhdLnkgPSAwLjA1ICsgKDEgKyBNYXRoLnNpbih0aGlzLl9zdGFydGluZ19hbmdsZSArIGkgKiB0aGlzLl9hbmdsZV9zdGVwKSkgKiAuNDU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc1tuZC5ub2Rlc1tpXS5pbmRleF0ud2VpZ2h0ID0gbmQuZGVncmVlc1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1dKTtcblx0XG5cdCAgICByZXR1cm4gX2NsYXNzO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBfY2xhc3M7XG5cdDtcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5jcmVhdGUyZEFycmF5ID0gY3JlYXRlMmRBcnJheTtcblx0ZXhwb3J0cy5kZWdyZWVzID0gZGVncmVlcztcblx0ZXhwb3J0cy5nZXREZXB0aCA9IGdldERlcHRoO1xuXHRleHBvcnRzLmdldFJhbmdlcyA9IGdldFJhbmdlcztcblx0XG5cdGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTcsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IFJlbmF0byBGYWJicmlcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBjcmVhdGUyZEFycmF5KHJvd3MsIGNvbHVtbnMpIHtcblx0ICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5KHJvd3MpLmtleXMoKSkpLm1hcChmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgIHJldHVybiBBcnJheShjb2x1bW5zKS5maWxsKDApO1xuXHQgICAgfSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGRlZ3JlZXMobm9kZXMsIGVkZ2VzKSB7XG5cdCAgICAvLyBzaG91bGQgcmV0dXJuIG9yZGVyZWQgbm9kZXMgYW5kIHRoZWlyIGRlZ3JlZXMgLSBoaWdoIHRvIGxvd1xuXHQgICAgdmFyIGRlZ3JlZXMgPSBBcnJheShub2Rlcy5sZW5ndGgpLmZpbGwoMCk7XG5cdCAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgZGVncmVlc1tlLnNvdXJjZS5pbmRleF0gKz0gMTtcblx0ICAgICAgICBkZWdyZWVzW2UudGFyZ2V0LmluZGV4XSArPSAxO1xuXHQgICAgfSk7IC8vIGNoZWNrIHRvIHNlZSBpZiBub3QgZ2V0dGluZyBkb3VibGUgb2YgdGhlIGRlZ3JlZSBpbiB1bmRpcmVjdGVkIGdyYXBoc1xuXHQgICAgLy9nZXR0aW5nIHRoZSBvcmRlciBvZiBub2RlcyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IGRlZ3JlZXNcblx0ICAgIHZhciBvcmRlcmVkX25vZGVzID0gZGVncmVlcy5tYXAoZnVuY3Rpb24gKGVsLCBpKSB7XG5cdCAgICAgICAgcmV0dXJuIHsgaW5kZXg6IGksIHZhbHVlOiBlbCB9O1xuXHQgICAgfSk7XG5cdCAgICBvcmRlcmVkX25vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gKyhhLnZhbHVlIDwgYi52YWx1ZSkgfHwgKyhhLnZhbHVlID09PSBiLnZhbHVlKSAtIDE7XG5cdCAgICB9KTtcblx0ICAgIHZhciBvcmRlcmVkX2RlZ3JlZXMgPSBvcmRlcmVkX25vZGVzLm1hcChmdW5jdGlvbiAoZWwpIHtcblx0ICAgICAgICByZXR1cm4gZGVncmVlc1tlbC5pbmRleF07XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiB7IG5vZGVzOiBvcmRlcmVkX25vZGVzLFxuXHQgICAgICAgIGRlZ3JlZXM6IG9yZGVyZWRfZGVncmVlcyB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBnZXREZXB0aChvYmopIHtcblx0ICAgIHZhciBkZXB0aCA9IDA7XG5cdCAgICBpZiAob2JqLmNoaWxkcmVuKSB7XG5cdCAgICAgICAgb2JqLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcblx0ICAgICAgICAgICAgaWYgKGQuZGVwdGhfdmlzaXRlZCA9PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGxheW91dCBpcyBvbmx5IGZvciB0cmVlcyBhY3ljbGljIGdyYXBoc1wiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkLmRlcHRoX3Zpc2l0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB2YXIgdG1wRGVwdGggPSBnZXREZXB0aChkKTtcblx0ICAgICAgICAgICAgaWYgKHRtcERlcHRoID4gZGVwdGgpIHtcblx0ICAgICAgICAgICAgICAgIGRlcHRoID0gdG1wRGVwdGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAxICsgZGVwdGg7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdldFJhbmdlcyhuKSB7XG5cdCAgICBuID0gTWF0aC5hYnMobik7XG5cdCAgICBpZiAobiA8PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3RhcnQ6IDAuNSxcblx0ICAgICAgICAgICAgc3RlcDogMVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB2YXIgc3RhcnQgPSAuMDU7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHN0YXJ0OiBzdGFydCxcblx0ICAgICAgICBzdGVwOiAoMSAtIDIgKiBzdGFydCkgLyAobiAtIDEpXG5cdCAgICB9O1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQ29weXJpZ2h0IChjKSAyMDE3LCBIZWxpa2FyIExhYi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEF1dGhvcjogUmVuYXRvIEZhYmJyaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMpIHtcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBub2Rlcztcblx0ICAgICAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiAnZHJhd1RyZWVDZW50ZXJlZCcsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUcmVlQ2VudGVyZWQocm9vdCkge1xuXHQgICAgICAgICAgICB2YXIgdmlzaXRlZF9sZWFmc19wYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cdCAgICAgICAgICAgIHZhciBsYXllciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblx0XG5cdCAgICAgICAgICAgIHJvb3QuY2VudGVyZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICByb290LmRlcHRoX3Zpc2l0ZWQgPSBmYWxzZTsgLy8gc28gdGhhdCBnZXREZXB0aCBkb2VzIG5vdCByYWlzZSBlcnJvciBpZiBhbm90aGVyIHRyZWUgbGF5b3V0IGlzIGNhbGxlZCBzdWJzZXF1ZW50bHlcblx0ICAgICAgICAgICAgLy8gYnJhbmNoIG9yZGVyIGlzIGZvciBub3cgc3RhYmxlIGJ1dCB1bnByZWRpY3RhYmxlLCBzZWUgbGF5b3V0cy5jcmlcblx0ICAgICAgICAgICAgdmFyIHZpc2l0ZWRfbGVhZnMgPSAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHJvb3QuY2hpbGRyZW5baV07XG5cdCAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2VudGVyZWQgIT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRfbGVhZnMgKz0gdGhpcy5kcmF3VHJlZUNlbnRlcmVkKGNoaWxkLCB2aXNpdGVkX2xlYWZzICsgdmlzaXRlZF9sZWFmc19wYXJlbnQsIGxheWVyICsgMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHJvb3QuY2hpbGRyZW4gPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdmlzaXRlZF9sZWFmcysrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIG1vdmluZyB0byBwYXJlbnQsIHBvc2l0aW9uIG5vZGVcblx0ICAgICAgICAgICAgcm9vdC55ID0gdGhpcy5zdGVweSAqICh2aXNpdGVkX2xlYWZzX3BhcmVudCArICh2aXNpdGVkX2xlYWZzIC0gMSkgLyAyKSArIHRoaXMuYWxwaGF5O1xuXHQgICAgICAgICAgICByb290LnggPSAobGF5ZXIgLSAxKSAqIHRoaXMuc3RlcHggKyB0aGlzLmFscGhheDtcblx0ICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWRfbGVhZnM7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ2FwcGx5Jyxcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG5cdCAgICAgICAgICAgIC8vIG9ubHkgb25lIHJvb3Qgbm9kZSBzdXBwb3J0ZWQgZm9yIG5vd1xuXHQgICAgICAgICAgICAvLyBsZWZ0LXJpZ2h0IHRyZWUgYnkgZGVmYXVsdCwgbGV0IHVzZXIgY2hvb3NlXG5cdCAgICAgICAgICAgIC8vIHRvcC1kb3duLCBib3R0b20tdG9wLCByaWdodC1sZWZ0IGluIHN1YnNlcXVlbnQgdmVyc2lvbnNcblx0ICAgICAgICAgICAgLy8gaGllcmFyY2hpY2FsIGxheW91dHMgZm9yIG5vbi10cmVlcyAoY3ljbGljYWwgZ3JhcGhzKSBzaG91bGQgYmVcblx0ICAgICAgICAgICAgLy8gaW1wbGVtZW50ZWQgc2VwYXJhdGVseSBmb3Igbm93XG5cdCAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuX25vZGVzO1xuXHQgICAgICAgICAgICAvLyBtYWtlIGhpZXJhcmNoeSwgYW5ub3RhdGUgcGFyZW50KHMpIGFuZCBjaGlsZHJlbiBpbiB0aGUgbm9kZXNcblx0ICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobiwgaSkge1xuXHQgICAgICAgICAgICAgICAgbi5wYXJlbnRzID0gW107XG5cdCAgICAgICAgICAgICAgICBuLmNoaWxkcmVuID0gW107XG5cdCAgICAgICAgICAgICAgICBuLmNlbnRlcmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlLCBpKSB7XG5cdCAgICAgICAgICAgICAgICBlLnNvdXJjZS5jaGlsZHJlbi5wdXNoKGUudGFyZ2V0KTtcblx0ICAgICAgICAgICAgICAgIGUudGFyZ2V0LnBhcmVudHMucHVzaChlLnNvdXJjZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAvLyBmaW5kIHRoZSByb290XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2Rlc1tpXS5wYXJlbnRzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBub2Rlc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZGVwdGggPSAoMCwgX3V0aWxzLmdldERlcHRoKShyb290KTtcblx0ICAgICAgICAgICAgLy8gZWFjaCBsYXllciBvZiB0cmVlIHggPSBbMCthbHBoYSwxLWFscGhhXVxuXHQgICAgICAgICAgICB2YXIgciA9ICgwLCBfdXRpbHMuZ2V0UmFuZ2VzKShkZXB0aCk7XG5cdCAgICAgICAgICAgIHRoaXMuYWxwaGF4ID0gci5zdGFydDtcblx0ICAgICAgICAgICAgdGhpcy5zdGVweCA9IHIuc3RlcDtcblx0ICAgICAgICAgICAgLy8gcG9zeCA9IGFscGhheCArIHN0ZXB4KihkZXB0aC0xKVxuXHRcblx0ICAgICAgICAgICAgLy8gZmluZCB0aGUgbnVtYmVyIG9mIGxlYWZzIHRvIGRpc3RyaWJ1dGUgbm9kZXMgdmVydGljYWxseVxuXHQgICAgICAgICAgICB2YXIgbGVhZnMgPSAwO1xuXHQgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxlYWZzKys7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByID0gKDAsIF91dGlscy5nZXRSYW5nZXMpKGxlYWZzKTtcblx0ICAgICAgICAgICAgLy8gZWFjaCBsZWFmIHkgPSBbMCthbHBoYSwxLWFscGhhXVxuXHQgICAgICAgICAgICB0aGlzLmFscGhheSA9IHIuc3RhcnQ7XG5cdCAgICAgICAgICAgIHRoaXMuc3RlcHkgPSByLnN0ZXA7XG5cdCAgICAgICAgICAgIC8vIHBvc3kgPSBhbHBoYXkgKyBzdGVweSoobGVhZm4tMSlcblx0XG5cdCAgICAgICAgICAgIHRoaXMuZHJhd1RyZWVDZW50ZXJlZChyb290KTtcblx0ICAgICAgICB9XG5cdCAgICB9XSk7XG5cdFxuXHQgICAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQ29weXJpZ2h0IChjKSAyMDE3LCBIZWxpa2FyIExhYi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEF1dGhvcjogUmVuYXRvIEZhYmJyaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMpIHtcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBub2Rlcztcblx0ICAgICAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiAnZHJhd1RyZWVUb3AnLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VHJlZVRvcChyb290KSB7XG5cdCAgICAgICAgICAgIHZhciB2aXNpdGVkX2xlYWZzX3BhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblx0ICAgICAgICAgICAgdmFyIGxheWVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXHRcblx0ICAgICAgICAgICAgLy8gZWFjaCBub2RlIGlzIGluIHZlcnRpY2FsbHkgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgaXRzIGxlYWZzXG5cdCAgICAgICAgICAgIHJvb3QudmlzaXRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIHJvb3QuZGVwdGhfdmlzaXRlZCA9IGZhbHNlOyAvLyBzbyB0aGF0IGdldERlcHRoIGRvZXMgbm90IHJhaXNlIGVycm9yIGlmIGFub3RoZXIgdHJlZSBsYXlvdXQgaXMgY2FsbGVkIHN1YnNlcXVlbnRseVxuXHQgICAgICAgICAgICByb290LnggPSB0aGlzLmFscGhheCArIHRoaXMuc3RlcHggKiAobGF5ZXIgLSAxKTtcblx0ICAgICAgICAgICAgcm9vdC55ID0gMSAtICh0aGlzLmFscGhheSArIHRoaXMuc3RlcHkgKiB2aXNpdGVkX2xlYWZzX3BhcmVudCk7XG5cdCAgICAgICAgICAgIC8vIHZpc2l0IGNoaWxkcmVuIHVudGlsIGxlYWZzXG5cdCAgICAgICAgICAgIHZhciB2aXNpdGVkX2xlYWZzID0gMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSByb290LmNoaWxkcmVuW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNlbnRlcmVkICE9IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2aXNpdGVkX2xlYWZzICs9IHRoaXMuZHJhd1RyZWVUb3AoY2hpbGQsIHZpc2l0ZWRfbGVhZnMgKyB2aXNpdGVkX2xlYWZzX3BhcmVudCwgbGF5ZXIgKyAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocm9vdC5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdmlzaXRlZF9sZWFmcysrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2aXNpdGVkX2xlYWZzO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6ICdhcHBseScsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuXHQgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl9ub2Rlcztcblx0ICAgICAgICAgICAgLy8gbWFrZSBoaWVyYXJjaHksIGFubm90YXRlIHBhcmVudChzKSBhbmQgY2hpbGRyZW4gaW4gdGhlIG5vZGVzXG5cdCAgICAgICAgICAgIC8vIHRoaXMgbGF5b3V0IGNhbiBiZSBydW4gb24gYW55IGdyYXBoIGFjdHVhbGx5XG5cdCAgICAgICAgICAgIC8vIGZvciB3aGljaCB0aGUgY2hpbGRyZW4gbWlnaHQgYmUgc2VsZWN0ZWQgZS5nLiBmb3IgdGhlaXIgZGVncmVlXG5cdCAgICAgICAgICAgIC8vIGRyYXcgY2FuIGJlIGRlY2lkZWQgb24gb3RoZXIgbWVhc3VyZXMsIHN1Y2ggYXMgY2xvc2VuZXNzIGNlbnRyYWxpdHkgb3IgY2x1c3RlcmluZ1xuXHQgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuLCBpKSB7XG5cdCAgICAgICAgICAgICAgICBuLnBhcmVudHMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIG4uY2hpbGRyZW4gPSBbXTtcblx0ICAgICAgICAgICAgICAgIG4uY2VudGVyZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2VkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgICAgICAgICAgICAgIGUuc291cmNlLmNoaWxkcmVuLnB1c2goZS50YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgZS50YXJnZXQucGFyZW50cy5wdXNoKGUuc291cmNlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIC8vIGZpbmQgdGhlIHJvb3Rcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGVzW2ldLnBhcmVudHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IG5vZGVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBkZXB0aCA9ICgwLCBfdXRpbHMuZ2V0RGVwdGgpKHJvb3QpO1xuXHQgICAgICAgICAgICAvLyBlYWNoIGxheWVyIG9mIHRyZWUgeCA9IFswK2FscGhhLDEtYWxwaGFdXG5cdCAgICAgICAgICAgIHZhciByID0gKDAsIF91dGlscy5nZXRSYW5nZXMpKGRlcHRoKTtcblx0ICAgICAgICAgICAgdGhpcy5hbHBoYXggPSByLnN0YXJ0O1xuXHQgICAgICAgICAgICB0aGlzLnN0ZXB4ID0gci5zdGVwO1xuXHQgICAgICAgICAgICAvLyBwb3N4ID0gYWxwaGF4ICsgc3RlcHgqKGRlcHRoLTEpXG5cdFxuXHQgICAgICAgICAgICAvLyBmaW5kIHRoZSBudW1iZXIgb2YgbGVhZnMgdG8gZGlzdHJpYnV0ZSBub2RlcyB2ZXJ0aWNhbGx5XG5cdCAgICAgICAgICAgIHZhciBsZWFmcyA9IDA7XG5cdCAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZnMrKztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIC8vIGVhY2ggbGVhZiB5ID0gWzArYWxwaGEsMS1hbHBoYV1cblx0ICAgICAgICAgICAgciA9ICgwLCBfdXRpbHMuZ2V0UmFuZ2VzKShsZWFmcyk7XG5cdCAgICAgICAgICAgIHRoaXMuYWxwaGF5ID0gci5zdGFydDtcblx0ICAgICAgICAgICAgdGhpcy5zdGVweSA9IHIuc3RlcDtcblx0ICAgICAgICAgICAgLy8gcG9zeSA9IGFscGhheSArIHN0ZXB5KihsZWFmbi0xKVxuXHRcblx0ICAgICAgICAgICAgLy8gZ2l2ZSBub2RlcyB0aGVpciBwb3NpdGlvbnNcblx0ICAgICAgICAgICAgLy8gcGxvdCBlYWNoIGJyYW5jaCBpbiBkZXB0aCBmaXJzdCxcblx0ICAgICAgICAgICAgLy8gaW5jcmVtZW50IHkgcG9zaXRpb24gZm9yIGVhY2ggbGVhZlxuXHQgICAgICAgICAgICAvLyBiYWNrdHJhY2tpbmcgdG8gZ28gZnJvbSBsZWFmIHRvIHBhcmVudHNcblx0ICAgICAgICAgICAgLy8gYW5kIGRlY2lkZSBpZiBwYXJlbnQgaXMgdmlzaXRlZCAoYWx3YXlzIGluIHRyZWUgbGF5b3V0KVxuXHRcblx0ICAgICAgICAgICAgdGhpcy5kcmF3VHJlZVRvcChyb290KTtcblx0ICAgICAgICB9XG5cdCAgICB9XSk7XG5cdFxuXHQgICAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdC8qKlxuXHQgKiAgQ29weXJpZ2h0IChjKSAyMDE3LCBIZWxpa2FyIExhYi5cblx0ICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqXG5cdCAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgKiAgQXV0aG9yOiBSZW5hdG8gRmFiYnJpXG5cdCAqL1xuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHRoaXMgbGF5b3V0IHNob3VsZCBoYW5kbGUgYW55IGRpZ3JhcGhcblx0ICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMpIHtcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBub2Rlcztcblx0ICAgICAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuXHQgICAgICAgIHRoaXMuYWxwaGF5ID0gMC4wNTsgLy8geSBtYXJnaW5cblx0ICAgICAgICB0aGlzLmFscGhheCA9IDAuMDU7IC8vIHggbWFyZ2luXG5cdCAgICB9XG5cdFxuXHQgICAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcblx0ICAgICAgICBrZXk6IFwibWFrZUxheWVyc1wiLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlTGF5ZXJzKG5vZGVzLCBsYXllcikge1xuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0ZXB5ID0gKDEgLSAyICogdGhpcy5hbHBoYXkpIC8gKG5vZGVzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLnZpc2l0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLmxheWVyID0gbGF5ZXI7IC8vIG1ha2VzIHggYWZ0ZXJ3YXJkc1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLnkgPSB0aGlzLmFscGhheSArIGkgKiBzdGVweTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5vZGVzWzBdLnZpc2l0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgbm9kZXNbMF0ubGF5ZXIgPSBsYXllcjsgLy8gbWFrZXMgeCBhZnRlcndhcmRzXG5cdCAgICAgICAgICAgICAgICBub2Rlc1swXS55ID0gMC41O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBuZXh0X2xheWVyID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBub2Rlc1tfaV0ucGFyZW50cy5jb25jYXQobm9kZXNbX2ldLmNoaWxkcmVuKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVpZ2hib3JzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yc1tqXS52aXNpdGVkID09IGZhbHNlICYmICFuZXh0X2xheWVyLmluY2x1ZGVzKG5laWdoYm9yc1tqXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV4dF9sYXllci5wdXNoKG5laWdoYm9yc1tqXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChuZXh0X2xheWVyLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlTGF5ZXJzKG5leHRfbGF5ZXIsIGxheWVyICsgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiBcImFwcGx5XCIsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuXHQgICAgICAgICAgICAvLyBsZWZ0LXJpZ2h0IHRyZWUgYnkgZGVmYXVsdCwgbGV0IHVzZXIgY2hvb3NlXG5cdCAgICAgICAgICAgIC8vIHRvcC1kb3duLCBib3R0b20tdG9wLCByaWdodC1sZWZ0IGluIHN1YnNlcXVlbnQgdmVyc2lvbnNcblx0ICAgICAgICAgICAgLy8gaGllcmFyY2hpY2FsIGxheW91dHMgZm9yIHRyZWVzIChhY3ljbGljIGdyYXBocykgYXJlXG5cdCAgICAgICAgICAgIC8vIGltcGxlbWVudGVkIHNlcGFyYXRlbHkgZm9yIG5vd1xuXHQgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl9ub2Rlcztcblx0ICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobiwgaSkge1xuXHQgICAgICAgICAgICAgICAgbi5wYXJlbnRzID0gW107XG5cdCAgICAgICAgICAgICAgICBuLmNoaWxkcmVuID0gW107XG5cdCAgICAgICAgICAgICAgICBuLnZpc2l0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2VkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgICAgICAgICAgICAgIGUuc291cmNlLmNoaWxkcmVuLnB1c2goZS50YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgZS50YXJnZXQucGFyZW50cy5wdXNoKGUuc291cmNlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIC8vIGZpbmQgdGhlIHJvb3RzOlxuXHQgICAgICAgICAgICAvLyBub2RlcyBkZWZpbmVkIGJ5IHRoZSB1c2VyIGFzIHJvb3RzIE9SXG5cdCAgICAgICAgICAgIC8vIG5vZGVzIHdpdGggaW4tZGVncmVlID09IDAgT1Jcblx0ICAgICAgICAgICAgLy8gbm9kZXMgd2l0aCBncmVhdGVzdCBpbi1kZWdyZWUgKG9yIGRlZ3JlZSBpZiB1bmRpcmVjdGVkIGdyYXBoKVxuXHQgICAgICAgICAgICB2YXIgcm9vdHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGVzW2ldLmlzcm9vdCA9PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaGFzIHRvIGJlIG9uIHRoZSBqc29uIGZpbGUgb2YgdGhlIGdyYXBoXG5cdCAgICAgICAgICAgICAgICAgICAgcm9vdHMucHVzaChub2Rlc1tpXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHJvb3RzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzW19pMl0ucGFyZW50cy5sZW5ndGggPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb290cy5wdXNoKG5vZGVzW19pMl0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocm9vdHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBtYXggb3V0LWRlZ3JlZVxuXHQgICAgICAgICAgICAgICAgdmFyIG1heF9vdXRkZWdyZWUgPSAwO1xuXHQgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IG1heF9vdXRkZWdyZWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4X291dGRlZ3JlZSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgLy8gY2hvb3NlIHZlcnRpY2VzIHdpdGggZ3JlYXRlc3Qgb3V0LWRlZ3JlZVxuXHQgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PSBtYXhfb3V0ZGVncmVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGxheWVycyBhbmQgbWF4IG51bWJlciBvZiBub2RlcyBpbiBlYWNoIGxheWVyXG5cdCAgICAgICAgICAgIC8vIGhhcyB0byBiZSBmb3VuZCBieSBtYWtpbmcgdGhlIGxheW91dFxuXHQgICAgICAgICAgICAvLyB0aGVyZSBhcmUgdHdvIGFwcHJvYWNoZXMgdG8gZmluZGluZyB0aGUgbm9kZXMgaW4gZWFjaCBsYXllcjpcblx0ICAgICAgICAgICAgLy8gMSkgZWFjaCBsYXllciBoYXMgYWxsIHRoZSBuZWlnaGJvcnMgb2YgdGhlIG5vZGVzIGluIHRoZSBwcmV2aW91cyBsYXllclxuXHQgICAgICAgICAgICAvLyAyKSBmb2xsb3cgbGlua3MgYW5kIHRoZW4gcGxhY2Ugbm9uIHZpc2l0ZWQgbm9kZXMgb24gdGhlIGxheWVyIG9mIG5laWdoYm9ycyBPUlxuXHQgICAgICAgICAgICAvLyB0aGlzIGxheW91dCBpbXBsZW1lbnRzIHRoZSBmaXJzdCBvZiB0aGVzZSBhcHByb2FjaGVzLlxuXHQgICAgICAgICAgICB2YXIgZGVwdGggPSB0aGlzLm1ha2VMYXllcnMocm9vdHMsIDEpO1xuXHQgICAgICAgICAgICAvLyBlYWNoIGxheWVyIG9mIHRyZWUgeCA9IFswK2FscGhhLDEtYWxwaGFdXG5cdCAgICAgICAgICAgIHZhciBzdGVweCA9ICgxIC0gMiAqIHRoaXMuYWxwaGF4KSAvIChkZXB0aCAtIDEpO1xuXHQgICAgICAgICAgICAvLyBwb3N4ID0gYWxwaGF4ICsgc3RlcHgqKGRlcHRoLTEpXG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHRoaXMuX25vZGVzLmxlbmd0aDsgKytfaTMpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW19pM10ueCA9IHRoaXMuYWxwaGF4ICsgc3RlcHggKiAodGhpcy5fbm9kZXNbX2kzXS5sYXllciAtIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfV0pO1xuXHRcblx0ICAgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvKipcblx0ICogIENvcHlyaWdodCAoYykgMjAxNywgSGVsaWthciBMYWIuXG5cdCAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgKlxuXHQgKiAgVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR1BMdjMgTGljZW5zZS5cblx0ICogIEF1dGhvcjogUmVuYXRvIEZhYmJyaVxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIGlzT3JwaGFuKG5vZGUpIHtcblx0ICAgIHZhciBvcnBoYW4gPSB0cnVlO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnBhcmVudHMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICB2YXIgcGFyZW50XyA9IG5vZGUucGFyZW50c1tpXTtcblx0ICAgICAgICBpZiAocGFyZW50XyAhPSBub2RlKSBvcnBoYW4gPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytfaSkge1xuXHQgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bX2ldO1xuXHQgICAgICAgIGlmIChjaGlsZCAhPSBub2RlKSBvcnBoYW4gPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBvcnBoYW47XG5cdH1cblx0XG5cdHZhciBfY2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyB0aGlzIGxheW91dCBzaG91bGQgaGFuZGxlIGFueSBkaWdyYXBoXG5cdCAgICBmdW5jdGlvbiBfY2xhc3Mobm9kZXMsIGVkZ2VzKSB7XG5cdCAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cdFxuXHQgICAgICAgIHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdCAgICAgICAgdGhpcy5fZWRnZXMgPSBlZGdlcztcblx0ICAgICAgICB0aGlzLmFscGhheSA9IDAuMDU7IC8vIHkgbWFyZ2luXG5cdCAgICAgICAgdGhpcy5hbHBoYXggPSAwLjA1OyAvLyB4IG1hcmdpblxuXHQgICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHsgXCJjdXJyZW50X2NvbXBvbmVudFwiOiAwLCBcImRlcHRoXCI6IDEgfTtcblx0ICAgICAgICB0aGlzLnVudmlzaXRlZCA9IG5vZGVzO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiBcImluaXRIaWVyYXJjaHlcIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEhpZXJhcmNoeSgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobiwgaSkge1xuXHQgICAgICAgICAgICAgICAgbi5wYXJlbnRzID0gW107XG5cdCAgICAgICAgICAgICAgICBuLmNoaWxkcmVuID0gW107XG5cdCAgICAgICAgICAgICAgICBuLnZpc2l0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2VkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgICAgICAgICAgICAgIGUuc291cmNlLmNoaWxkcmVuLnB1c2goZS50YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgZS50YXJnZXQucGFyZW50cy5wdXNoKGUuc291cmNlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogXCJzZXBhcmF0ZU9ycGhhbnNcIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VwYXJhdGVPcnBoYW5zKCkge1xuXHQgICAgICAgICAgICB2YXIgb3JwaGFucyA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpc09ycGhhbihub2RlKSkgb3JwaGFucy5wdXNoKG5vZGUpO2Vsc2Ugbm9kZXMucHVzaChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gb3JwaGFucztcblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiBcImZpbmRSb290c1wiLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUm9vdHMobm9kZXMpIHtcblx0ICAgICAgICAgICAgLy8gZmluZCB0aGUgcm9vdHM6XG5cdCAgICAgICAgICAgIC8vIG5vZGVzIGRlZmluZWQgYnkgdGhlIHVzZXIgYXMgcm9vdHMgT1Jcblx0ICAgICAgICAgICAgLy8gbm9kZXMgd2l0aCBpbi1kZWdyZWUgPT0gMCBPUlxuXHQgICAgICAgICAgICAvLyBub2RlcyB3aXRoIGdyZWF0ZXN0IGluLWRlZ3JlZSAob3IgZGVncmVlIGlmIHVuZGlyZWN0ZWQgZ3JhcGgpXG5cdCAgICAgICAgICAgIHZhciByb290cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0uaXNyb290ID09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBoYXMgdG8gYmUgb24gdGhlIGpzb24gZmlsZSBvZiB0aGUgZ3JhcGhcblx0ICAgICAgICAgICAgICAgICAgICByb290cy5wdXNoKG5vZGVzW2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocm9vdHMubGVuZ3RoID09IDApIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbX2kyXS5wYXJlbnRzLmxlbmd0aCA9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzLnB1c2gobm9kZXNbX2kyXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChyb290cy5sZW5ndGggPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1heCBvdXQtZGVncmVlXG5cdCAgICAgICAgICAgICAgICB2YXIgbWF4X291dGRlZ3JlZSA9IDA7XG5cdCAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gbWF4X291dGRlZ3JlZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXhfb3V0ZGVncmVlID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAvLyBjaG9vc2UgdmVydGljZXMgd2l0aCBncmVhdGVzdCBvdXQtZGVncmVlXG5cdCAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09IG1heF9vdXRkZWdyZWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMucHVzaChub2RlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcm9vdHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogXCJwbGFjZU9ycGhhbnNcIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2VPcnBoYW5zKG5vZGVzLCBtYXhfbGF5ZXIpIHtcblx0ICAgICAgICAgICAgdmFyIHN0ZXB5ID0gKDEgLSAyICogdGhpcy5hbHBoYXkpIC8gKG5vZGVzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBub2Rlc1tpXS55ID0gdGhpcy5hbHBoYXkgKyBpICogc3RlcHk7XG5cdCAgICAgICAgICAgICAgICBub2Rlc1tpXS54ID0gbWF4X2xheWVyICsgMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkgcmV0dXJuIG1heF9sYXllciArIDE7ZWxzZSByZXR1cm4gbWF4X2xheWVyO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6IFwidW52aXNpdGVkTm9kZXNcIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW52aXNpdGVkTm9kZXMoKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgb3JwaGFucyA9IHRoaXMub3JwaGFucztcblx0ICAgICAgICAgICAgdGhpcy51bnZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUudmlzaXRlZCA9PSBmYWxzZSAmJiAhKG5vZGUgaW4gb3JwaGFucykpIG5vZGVzLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoICE9IHRoaXMudW52aXNpdGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm1heWJlX21vcmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy51bnZpc2l0ZWQgPSBub2Rlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHRoaXMubWF5YmVfbW9yZSA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6IFwicGxhY2VBZGRpdGlvbmFsXCIsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBsYWNlQWRkaXRpb25hbCgpIHtcblx0ICAgICAgICAgICAgLy8gcGxhY2Ugbm9uLXZpc2l0ZWQgbm9kZXMgaW4gYmV0d2VlbiBsYXllcnNcblx0ICAgICAgICAgICAgdmFyIGF1eF9sYXllcnMgPSB7fTtcblx0ICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNvbXBvbmVudHNbdGhpcy5jb21wb25lbnRzLmN1cnJlbnRfY29tcG9uZW50XTtcblx0ICAgICAgICAgICAgdmFyIGxheWVycyA9IGMubGF5ZXJzO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW52aXNpdGVkLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMudW52aXNpdGVkW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxvd2VzdF9sYXllciA9IHRoaXMuY29tcG9uZW50cy5kZXB0aDtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZF9mb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltqXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudmlzaXRlZCA9PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkX2ZvdW5kID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmxheWVyIDw9IGxvd2VzdF9sYXllcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGQgaGFzIHRvIGJlIHZpc2l0ZWQgdG8gaGF2ZSBhIGxheWVyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RfbGF5ZXIgPSBjaGlsZC5sYXllcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2hpbGRfZm91bmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnZpc2l0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIG5vZGUuaW5kZXggPSBsb3dlc3RfbGF5ZXItc2VwO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGxvd2VzdF9sYXllciAtIHNlcCBpbiBsYXllcnMpKSBsYXllcnNbbG93ZXN0X2xheWVyIC0gc2VwXSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGxheWVyc1tsb3dlc3RfbGF5ZXIgLSBzZXBdLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfbG93ZXN0X2xheWVyID0gbWF4X2xheWVyO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfZm91bmQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbm9kZS5wYXJlbnRzLmxlbmd0aDsgKytfaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XyA9IG5vZGUucGFyZW50c1tfal07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfLnZpc2l0ZWQgPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50X2ZvdW5kID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfLmxheWVyIDw9IF9sb3dlc3RfbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZCBoYXMgdG8gYmUgdmlzaXRlZCB0byBoYXZlIGEgbGF5ZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG93ZXN0X2xheWVyID0gcGFyZW50Xy5sYXllcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50X2ZvdW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudmlzaXRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueCA9IF9sb3dlc3RfbGF5ZXIgKyBzZXA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9sb3dlc3RfbGF5ZXIgKyBzZXAgaW4gbGF5ZXJzKSkgbGF5ZXJzW19sb3dlc3RfbGF5ZXIgKyBzZXBdID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyc1tfbG93ZXN0X2xheWVyICsgc2VwXS5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6IFwiaW5pdGlhbGl6ZUNvbXBvbmVudFwiLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50XSA9IHt9O1xuXHQgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50XS5tYXhfbm9kZXNfbGF5ZXIgPSAwO1xuXHQgICAgICAgICAgICBpZiAoY29tcG9uZW50ID4gMCkgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudF0uaW5kZXhfb2Zmc2V0ID0gdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudCAtIDFdLnZlcnRpY2FsX25vZGVzO2Vsc2UgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudF0uaW5kZXhfb2Zmc2V0ID0gMDtcblx0ICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudF0uY3VycmVudF9sYXllciA9IDE7XG5cdCAgICAgICAgICAgIC8vdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudF0ubGF5ZXJzID0ge1wibm9kZXNcIjogW10sIFwibGF5ZXJfdmFsdWVcIjogMX07XG5cdCAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tjb21wb25lbnRdLmxheWVycyA9IHt9O1xuXHQgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50XS52ZXJ0aWNhbF9ub2RlcyA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogXCJsYXllck5vZGVzXCIsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxheWVyTm9kZXMobm9kZXMpIHtcblx0ICAgICAgICAgICAgaWYgKCEodGhpcy5jb21wb25lbnRzLmN1cnJlbnRfY29tcG9uZW50IGluIHRoaXMuY29tcG9uZW50cykpIHRoaXMuaW5pdGlhbGl6ZUNvbXBvbmVudCh0aGlzLmNvbXBvbmVudHMuY3VycmVudF9jb21wb25lbnQpO1xuXHQgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29tcG9uZW50c1t0aGlzLmNvbXBvbmVudHMuY3VycmVudF9jb21wb25lbnRdO1xuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gYy52ZXJ0aWNhbF9ub2RlcykgYy52ZXJ0aWNhbF9ub2RlcyA9IG5vZGVzLmxlbmd0aDtcblx0ICAgICAgICAgICAgYy5sYXllcnNbYy5jdXJyZW50X2xheWVyXSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICBub2Rlc1tpXS52aXNpdGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGMubGF5ZXJzW2MuY3VycmVudF9sYXllcl0ucHVzaChub2Rlc1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIG5leHRfbGF5ZXIgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZXMubGVuZ3RoOyBfaTMrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBub2Rlc1tfaTNdLmNoaWxkcmVuO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYW5kaWRhdGVzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZXNbal0udmlzaXRlZCA9PSBmYWxzZSAmJiAhbmV4dF9sYXllci5pbmNsdWRlcyhjYW5kaWRhdGVzW2pdKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXh0X2xheWVyLnB1c2goY2FuZGlkYXRlc1tqXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChuZXh0X2xheWVyLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGMuY3VycmVudF9sYXllcisrO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cy5kZXB0aCA8IGMuY3VycmVudF9sYXllcikgdGhpcy5jb21wb25lbnRzLmRlcHRoID0gYy5jdXJyZW50X2xheWVyO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5sYXllck5vZGVzKG5leHRfbGF5ZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogXCJhcHBseVwiLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcblx0ICAgICAgICAgICAgLy8gbGVmdC1yaWdodCB0cmVlIGJ5IGRlZmF1bHQsIGxldCB1c2VyIGNob29zZVxuXHQgICAgICAgICAgICAvLyB0b3AtZG93biwgYm90dG9tLXRvcCwgcmlnaHQtbGVmdCBpbiBzdWJzZXF1ZW50IHZlcnNpb25zXG5cdCAgICAgICAgICAgIC8vIGhpZXJhcmNoaWNhbCBsYXlvdXRzIGZvciB0cmVlcyAoYWN5Y2xpYyBncmFwaHMpIGFyZVxuXHQgICAgICAgICAgICAvLyBpbXBsZW1lbnRlZCBzZXBhcmF0ZWx5IGZvciBub3dcblx0XG5cdCAgICAgICAgICAgIC8vIG51bWJlciBvZiBsYXllcnMgYW5kIG1heCBudW1iZXIgb2Ygbm9kZXMgaW4gZWFjaCBsYXllclxuXHQgICAgICAgICAgICAvLyBoYXMgdG8gYmUgZm91bmQgYnkgbWFraW5nIHRoZSBsYXlvdXRcblx0ICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHR3byBhcHByb2FjaGVzIHRvIGZpbmRpbmcgdGhlIG5vZGVzIGluIGVhY2ggbGF5ZXI6XG5cdCAgICAgICAgICAgIC8vIDEpIGVhY2ggbGF5ZXIgaGFzIGFsbCB0aGUgbmVpZ2hib3JzIG9mIHRoZSBub2RlcyBpbiB0aGUgcHJldmlvdXMgbGF5ZXJcblx0ICAgICAgICAgICAgLy8gMikgZm9sbG93IGxpbmtzIGFuZCB0aGVuIHBsYWNlIG5vbiB2aXNpdGVkIG5vZGVzIG9uIHRoZSBsYXllciBvZiBuZWlnaGJvcnMgT1Jcblx0ICAgICAgICAgICAgLy8gdGhpcyBsYXlvdXQgaW1wbGVtZW50cyB0aGUgc2Vjb25kIG9mIHRoZXNlIGFwcHJvYWNoZXMuXG5cdFxuXHQgICAgICAgICAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcblx0ICAgICAgICAgICAgdGhpcy5vcnBoYW5zID0gdGhpcy5zZXBhcmF0ZU9ycGhhbnMoKTtcblx0ICAgICAgICAgICAgdGhpcy51bnZpc2l0ZWROb2RlcygpO1xuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy51bnZpc2l0ZWQubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJvb3RzID0gdGhpcy5maW5kUm9vdHModGhpcy51bnZpc2l0ZWQpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5sYXllck5vZGVzKHJvb3RzKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudW52aXNpdGVkTm9kZXMoKTsgLy8gdXBkYXRlIHVudmlzaXRlZCBub2Rlc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5tYXliZV9tb2RlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm1heWJlX21vcmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlQWRkaXRpb25hbCgpOyAvLyBwbGFjZSBhZGRpdGlvbmFsIG5vZGVzIGxpbmtlZCB0byB0aGlzIGNvbXBvbmVudFxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudW52aXNpdGVkTm9kZXMoKTsgLy8gdXBkYXRlIHVudmlzaXRlZCBub2Rlc1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLmN1cnJlbnRfY29tcG9uZW50Kys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnZlcnRpY2FsX25vZGVzID0gMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHMuY3VycmVudF9jb21wb25lbnQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnZlcnRpY2FsX25vZGVzICs9IHRoaXMuY29tcG9uZW50c1tpXS52ZXJ0aWNhbF9ub2Rlcztcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgLy8gbGF5ZXJOb2RlcyBzaG91bGQgcG9wdWxhdGUgdGhlIGRpY3Rpb25hcnkgdGhpcy5jb21wb25lbnRzIG9mIGNvbXBvbmVudHMgYW5kIGF1eCB2YXJpYWJsZXM6XG5cdCAgICAgICAgICAgIC8vIGNvbXBvbmVudHNbeF0gaXMgYSBjb21wb25lbnQsIHggaXMgYW4gaW50ZWdlclxuXHQgICAgICAgICAgICAvLyBjb21wb25lbnRzW3hdLnZlcnRpY2FsX25vZGVzIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlcyBpbiBhIGxheWVyIGZvciB0aGUgY29tcG9uZW50XG5cdCAgICAgICAgICAgIC8vIGNvbXBvbmVudHNbeF0ubGF5ZXJbal0gaXMgdGhlIGotdGggbGF5ZXIgb24gdGhlIGNvbXBvbmVudCwgaiBjYW4gYmUgZnJhY3Rpb25hbFxuXHQgICAgICAgICAgICAvLyBjb21wb25lbnRzW3hdLmluZGV4X29mZnNldCBpcyB0aGUgbnVtYmVyIG9mIG5vZGVzIHBvc2l0aW9uZWQgaW4gYWJvdmUgY29tcG9uZW50c1xuXHQgICAgICAgICAgICAvLyBjb21wb25lbnRzLm5jb21wb25lbnRzIGlzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50c1xuXHQgICAgICAgICAgICAvLyBjb21wb25lbnRzLnZlcnRpY2FsX25vZGVzIGlzIHRoZSBzdW0gb2YgdGhlIG1heCBub2RlcyBpbiBhbnkgbGF5ZXIgb2YgZWFjaCBjb21wb25lbnRcblx0ICAgICAgICAgICAgLy8gY29tcG9uZW50cy5kZXB0aCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgbGF5ZXJzXG5cdFxuXHQgICAgICAgICAgICAvLyBlYWNoIGxheWVyIG9mIHRyZWUgeHkgPSBbMCthbHBoYSwxLWFscGhhXVxuXHQgICAgICAgICAgICB2YXIgc3RlcHggPSAoMSAtIDIgKiB0aGlzLmFscGhheCkgLyB0aGlzLmNvbXBvbmVudHMuZGVwdGg7XG5cdCAgICAgICAgICAgIHZhciBzdGVweSA9ICgxIC0gMiAqIHRoaXMuYWxwaGF5KSAvIHRoaXMuY29tcG9uZW50cy52ZXJ0aWNhbF9ub2Rlcztcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdGhpcy5jb21wb25lbnRzLmN1cnJlbnRfY29tcG9uZW50OyBfaTQrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tfaTRdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXJfdmFsIGluIGNvbXBvbmVudC5sYXllcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBjb21wb25lbnQubGF5ZXJzW2xheWVyX3ZhbF07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLmxlbmd0aCA9PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gbGF5ZXJbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueCA9IHRoaXMuYWxwaGF4ICsgc3RlcHggKiBsYXllcl92YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueSA9IHRoaXMuYWxwaGF5ICsgc3RlcHkgKiAoY29tcG9uZW50LmluZGV4X29mZnNldCArIGNvbXBvbmVudC52ZXJ0aWNhbF9ub2RlcyAvIDIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGF5ZXIubGVuZ3RoOyArK2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbm9kZSA9IGxheWVyW2tdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX25vZGUueCA9IHRoaXMuYWxwaGF4ICsgc3RlcHggKiBsYXllcl92YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbm9kZS55ID0gdGhpcy5hbHBoYXkgKyBzdGVweSAqIChjb21wb25lbnQuaW5kZXhfb2Zmc2V0ICsgayk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5wbGFjZU9ycGhhbnModGhpcy5vcnBoYW5zKTtcblx0ICAgICAgICB9XG5cdCAgICB9XSk7XG5cdFxuXHQgICAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQ29weXJpZ2h0IChjKSAyMDE3LCBIZWxpa2FyIExhYi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEF1dGhvcjogUmVuYXRvIEZhYmJyaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHR2YXIgX21sTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gdHdvU21hbGxlc3QoYXJyKSB7XG5cdCAgICB2YXIgbWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYXJyKSxcblx0ICAgICAgICAvLyBnZXQgdGhlIG1heCBvZiB0aGUgYXJyYXlcblx0ICAgIG1pbmkgPSBhcnIuaW5kZXhPZihtaW4pO1xuXHQgICAgYXJyW21pbmldID0gSW5maW5pdHk7IC8vIHJlcGxhY2UgbWF4IGluIHRoZSBhcnJheSB3aXRoIC1pbmZpbml0eVxuXHQgICAgdmFyIHNlY29uZF9taW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCBhcnIpLFxuXHQgICAgICAgIC8vIGdldCB0aGUgbmV3IG1heCBcblx0ICAgIHNlY29uZF9taW5pID0gYXJyLmluZGV4T2Yoc2Vjb25kX21pbik7XG5cdCAgICBhcnJbc2Vjb25kX21pbmldID0gSW5maW5pdHk7IC8vIHJlcGxhY2UgbWF4IGluIHRoZSBhcnJheSB3aXRoIC1pbmZpbml0eVxuXHQgICAgdmFyIHRoaXJkX21pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIGFyciksXG5cdCAgICAgICAgLy8gZ2V0IHRoZSBuZXcgbWF4IFxuXHQgICAgdGhpcmRfbWluaSA9IGFyci5pbmRleE9mKHRoaXJkX21pbik7XG5cdCAgICByZXR1cm4gW3NlY29uZF9taW5pLCB0aGlyZF9taW5pXTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbm9ybWFsaXplKHgsIHkpIHtcblx0ICAgIHZhciBtYXh4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeC5tYXAoTWF0aC5hYnMpKSxcblx0ICAgICAgICBtYXh5ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeS5tYXAoTWF0aC5hYnMpKTtcblx0ICAgIHZhciBtaW54ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeCksXG5cdCAgICAgICAgbWlueSA9IE1hdGgubWluLmFwcGx5KG51bGwsIHkpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgeFtpXSA9IDAuMSArICh4W2ldIC0gbWlueCkgLyAoKG1heHggLSBtaW54KSAqIDEuMjUpO1xuXHQgICAgICAgIHlbaV0gPSAwLjEgKyAoeVtpXSAtIG1pbnkpIC8gKChtYXh5IC0gbWlueSkgKiAxLjI1KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBbeCwgeV07XG5cdH1cblx0XG5cdHZhciBfY2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBnZXQgZGVncmVlIG9mIGFsbCBub2Rlc1xuXHQgICAgLy8gbGV0IHVzZXIgZGVmaW5lIGF0IGxlYXN0OiBzdGFydGluZyBhbmdsZSBhbmQgcmFkaXVzIGFuZFxuXHQgICAgLy8gY2xvY2svY2Nsb2NrIGRpcmVjdGlvblxuXHQgICAgLy8gc2l6ZSBvZiB2ZXJ0aWNlc1xuXHQgICAgLy8gbW9yZTogYSByYXRpbyBvZiBjb21wYWN0bmVzcyBmb3IgdGhlIG1vcmUvbGVzcyBjb25uZWN0ZWQgbm9kZXNcblx0ICAgIC8vIGEgc3BpcmFsIHJhdGlvIHdpdGggYSByb3RhdGlvbiByYXRpbyBmb3IgaGF2aW5nIG1vcmUgdGhhbiAycGlcblx0ICAgIC8vIGRpc3RyaWJ1dGlvbiBvZiBub2RlcyB3aGVuIHNwaXJpbGluZ1xuXHQgICAgLy8gdXNlIHNvbWUgb3RoZXIgb3JkZXJpbmcgY3JpdGVyaW9uIHRoYW4gZGVncmVlPyBTdHJlbmd0aD9cblx0ICAgIC8vIGRlZmluZWQgYnkgdXNlciBhbmQgZm91bmQgYXMgYXR0cmlidXRlIG9mIGVhY2ggbm9kZT9cblx0ICAgIC8vIHJhbmRvbSBvcmRlcmluZywgbWluaW1hbCBjcm9zc2luZyBvZiBlZGdlcz9cblx0ICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMpIHtcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBub2Rlcztcblx0ICAgICAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiAnYXBwbHknLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcblx0ICAgICAgICAgICAgdmFyIEEgPSAoMCwgX3V0aWxzLmNyZWF0ZTJkQXJyYXkpKHRoaXMuX25vZGVzLmxlbmd0aCwgdGhpcy5fbm9kZXMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgLy8gYnVpbGQgdGhlIGFkamFjZW5jeSBtYXRyaXhcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlpID0gdGhpcy5fZWRnZXNbaV0uc291cmNlLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgdmFyIGogPSB0aGlzLl9lZGdlc1tpXS50YXJnZXQuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICBBW2lpXVtqXSA9IC0xOyAvLyBub3QgY29uc2lkZXJpbmcgZWRnZSB3ZWlnaHQgZm9yIG5vdyAodGhlIGV4YW1wbGUganNvbiBmaWxlcyBkb24ndCBoYXZlIHdlaWdodClcblx0ICAgICAgICAgICAgICAgIEFbal1baWldID0gLTE7IC8vIG5vdCBjb25zaWRlcmluZyBlZGdlIHdlaWdodCBmb3Igbm93ICh0aGUgZXhhbXBsZSBqc29uIGZpbGVzIGRvbid0IGhhdmUgd2VpZ2h0KVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSBkaWFnb25hbCBvZiBkZWdyZWVzXG5cdCAgICAgICAgICAgIC8vIE5PVCBzdWJ0cmFjdCBhZGphY2VuY3kgZnJvbSBkZWdyZWVzIGJ1dDpcblx0ICAgICAgICAgICAgLy8gc3Vic3RpdHV0ZSBkaWFnb25hbCBieSBkZWdyZWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7ICsrX2kpIHtcblx0ICAgICAgICAgICAgICAgIEFbX2ldW19pXSA9IC1BW19pXS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG5cdCAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZm9vID0gbmV3IF9tbE1hdHJpeC5FaWdlbnZhbHVlRGVjb21wb3NpdGlvbihBKTtcblx0ICAgICAgICAgICAgdmFyIGlpaSA9IHR3b1NtYWxsZXN0KGZvby5yZWFsRWlnZW52YWx1ZXMpO1xuXHQgICAgICAgICAgICB2YXIgZm9vXyA9IGZvby5laWdlbnZlY3Rvck1hdHJpeC50cmFuc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdmFyIHggPSBmb29fW2lpaVswXV07XG5cdCAgICAgICAgICAgIHZhciB5ID0gZm9vX1tpaWlbMV1dO1xuXHQgICAgICAgICAgICB2YXIgeHkgPSBub3JtYWxpemUoeCwgeSk7XG5cdCAgICAgICAgICAgIC8vIHZhciBmb29vID0gbmV3IE1hdHJpeC5FaWdlbnZhbHVlRGVjb21wb3NpdGlvbihBKTtcblx0ICAgICAgICAgICAgLy8gdmFyIGZvb28gPSBuZXcgTWF0cml4LkVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uKEEpO1xuXHQgICAgICAgICAgICAvLyByZWNpcGUgZnJvbSBodHRwOi8vd3d3LnNmdS5jYS9wZXJzb25hbC9hcmNoaXZlcy9yaWNoYXJkcy9QYWdlcy9OQVMuQUpTLVdEUi5wZGZcblx0ICAgICAgICAgICAgLy8gYW5kIGltcGxlbWVudGVkIGluIG5ldHdvcmt4L2RyYXdpbmcvbGF5b3V0LnB5XG5cdCAgICAgICAgICAgIHRoaXMuX25vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUueCA9IHh5WzBdW2ldO1xuXHQgICAgICAgICAgICAgICAgbm9kZS55ID0geHlbMV1baV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1dKTtcblx0XG5cdCAgICByZXR1cm4gX2NsYXNzO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBfY2xhc3M7XG5cdDtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblx0XG5cdHZhciByZXNjYWxlID0gX2ludGVyb3BEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcblx0XG5cdGlmICghU3ltYm9sLnNwZWNpZXMpIHtcblx0ICAgIFN5bWJvbC5zcGVjaWVzID0gU3ltYm9sLmZvcignQEBzcGVjaWVzJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAY2xhc3MgTHVEZWNvbXBvc2l0aW9uXG5cdCAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sdXR6cm9lZGVyL01hcGFjay9ibG9iL21hc3Rlci9Tb3VyY2UvTHVEZWNvbXBvc2l0aW9uLmNzXG5cdCAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcblx0ICovXG5cdGNsYXNzIEx1RGVjb21wb3NpdGlvbiQkMSB7XG5cdCAgICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcblx0ICAgICAgICBtYXRyaXggPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgobWF0cml4KTtcblx0XG5cdCAgICAgICAgdmFyIGx1ID0gbWF0cml4LmNsb25lKCk7XG5cdCAgICAgICAgdmFyIHJvd3MgPSBsdS5yb3dzO1xuXHQgICAgICAgIHZhciBjb2x1bW5zID0gbHUuY29sdW1ucztcblx0ICAgICAgICB2YXIgcGl2b3RWZWN0b3IgPSBuZXcgQXJyYXkocm93cyk7XG5cdCAgICAgICAgdmFyIHBpdm90U2lnbiA9IDE7XG5cdCAgICAgICAgdmFyIGksIGosIGssIHAsIHMsIHQsIHY7XG5cdCAgICAgICAgdmFyIExVY29saiwga21heDtcblx0XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICBwaXZvdFZlY3RvcltpXSA9IGk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBMVWNvbGogPSBuZXcgQXJyYXkocm93cyk7XG5cdFxuXHQgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcblx0XG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIExVY29saltpXSA9IGx1LmdldChpLCBqKTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAga21heCA9IE1hdGgubWluKGksIGopO1xuXHQgICAgICAgICAgICAgICAgcyA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga21heDsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcyArPSBsdS5nZXQoaSwgaykgKiBMVWNvbGpba107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBMVWNvbGpbaV0gLT0gcztcblx0ICAgICAgICAgICAgICAgIGx1LnNldChpLCBqLCBMVWNvbGpbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBwID0gajtcblx0ICAgICAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPCByb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhMVWNvbGpbaV0pID4gTWF0aC5hYnMoTFVjb2xqW3BdKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHAgPSBpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBpZiAocCAhPT0gaikge1xuXHQgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvbHVtbnM7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgPSBsdS5nZXQocCwgayk7XG5cdCAgICAgICAgICAgICAgICAgICAgbHUuc2V0KHAsIGssIGx1LmdldChqLCBrKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgbHUuc2V0KGosIGssIHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIHYgPSBwaXZvdFZlY3RvcltwXTtcblx0ICAgICAgICAgICAgICAgIHBpdm90VmVjdG9yW3BdID0gcGl2b3RWZWN0b3Jbal07XG5cdCAgICAgICAgICAgICAgICBwaXZvdFZlY3RvcltqXSA9IHY7XG5cdFxuXHQgICAgICAgICAgICAgICAgcGl2b3RTaWduID0gLXBpdm90U2lnbjtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaWYgKGogPCByb3dzICYmIGx1LmdldChqLCBqKSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPCByb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBsdS5zZXQoaSwgaiwgbHUuZ2V0KGksIGopIC8gbHUuZ2V0KGosIGopKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdGhpcy5MVSA9IGx1O1xuXHQgICAgICAgIHRoaXMucGl2b3RWZWN0b3IgPSBwaXZvdFZlY3Rvcjtcblx0ICAgICAgICB0aGlzLnBpdm90U2lnbiA9IHBpdm90U2lnbjtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgICAgICovXG5cdCAgICBpc1Npbmd1bGFyKCkge1xuXHQgICAgICAgIHZhciBkYXRhID0gdGhpcy5MVTtcblx0ICAgICAgICB2YXIgY29sID0gZGF0YS5jb2x1bW5zO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sOyBqKyspIHtcblx0ICAgICAgICAgICAgaWYgKGRhdGFbal1bal0gPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge01hdHJpeH0gdmFsdWVcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgc29sdmUodmFsdWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cdFxuXHQgICAgICAgIHZhciBsdSA9IHRoaXMuTFU7XG5cdCAgICAgICAgdmFyIHJvd3MgPSBsdS5yb3dzO1xuXHRcblx0ICAgICAgICBpZiAocm93cyAhPT0gdmFsdWUucm93cykge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWF0cml4IGRpbWVuc2lvbnMnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuaXNTaW5ndWxhcigpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTFUgbWF0cml4IGlzIHNpbmd1bGFyJyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB2YXIgY291bnQgPSB2YWx1ZS5jb2x1bW5zO1xuXHQgICAgICAgIHZhciBYID0gdmFsdWUuc3ViTWF0cml4Um93KHRoaXMucGl2b3RWZWN0b3IsIDAsIGNvdW50IC0gMSk7XG5cdCAgICAgICAgdmFyIGNvbHVtbnMgPSBsdS5jb2x1bW5zO1xuXHQgICAgICAgIHZhciBpLCBqLCBrO1xuXHRcblx0ICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29sdW1uczsgaysrKSB7XG5cdCAgICAgICAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgY29sdW1uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIFhbaV1bal0gLT0gWFtrXVtqXSAqIGx1W2ldW2tdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAoayA9IGNvbHVtbnMgLSAxOyBrID49IDA7IGstLSkge1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgWFtrXVtqXSAvPSBsdVtrXVtrXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgazsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIFhbaV1bal0gLT0gWFtrXVtqXSAqIGx1W2ldW2tdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBYO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAqL1xuXHQgICAgZ2V0IGRldGVybWluYW50KCkge1xuXHQgICAgICAgIHZhciBkYXRhID0gdGhpcy5MVTtcblx0ICAgICAgICBpZiAoIWRhdGEuaXNTcXVhcmUoKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZScpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSB0aGlzLnBpdm90U2lnbjtcblx0ICAgICAgICB2YXIgY29sID0gZGF0YS5jb2x1bW5zO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sOyBqKyspIHtcblx0ICAgICAgICAgICAgZGV0ZXJtaW5hbnQgKj0gZGF0YVtqXVtqXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRldGVybWluYW50O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgZ2V0IGxvd2VyVHJpYW5ndWxhck1hdHJpeCgpIHtcblx0ICAgICAgICB2YXIgZGF0YSA9IHRoaXMuTFU7XG5cdCAgICAgICAgdmFyIHJvd3MgPSBkYXRhLnJvd3M7XG5cdCAgICAgICAgdmFyIGNvbHVtbnMgPSBkYXRhLmNvbHVtbnM7XG5cdCAgICAgICAgdmFyIFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA+IGopIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gZGF0YVtpXVtqXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaikge1xuXHQgICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSAxO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gMDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gWDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAgICAgKi9cblx0ICAgIGdldCB1cHBlclRyaWFuZ3VsYXJNYXRyaXgoKSB7XG5cdCAgICAgICAgdmFyIGRhdGEgPSB0aGlzLkxVO1xuXHQgICAgICAgIHZhciByb3dzID0gZGF0YS5yb3dzO1xuXHQgICAgICAgIHZhciBjb2x1bW5zID0gZGF0YS5jb2x1bW5zO1xuXHQgICAgICAgIHZhciBYID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPD0gaikge1xuXHQgICAgICAgICAgICAgICAgICAgIFhbaV1bal0gPSBkYXRhW2ldW2pdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gMDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gWDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fVxuXHQgICAgICovXG5cdCAgICBnZXQgcGl2b3RQZXJtdXRhdGlvblZlY3RvcigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5waXZvdFZlY3Rvci5zbGljZSgpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBoeXBvdGVudXNlKGEsIGIpIHtcblx0ICAgIHZhciByID0gMDtcblx0ICAgIGlmIChNYXRoLmFicyhhKSA+IE1hdGguYWJzKGIpKSB7XG5cdCAgICAgICAgciA9IGIgLyBhO1xuXHQgICAgICAgIHJldHVybiBNYXRoLmFicyhhKSAqIE1hdGguc3FydCgxICsgciAqIHIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGIgIT09IDApIHtcblx0ICAgICAgICByID0gYSAvIGI7XG5cdCAgICAgICAgcmV0dXJuIE1hdGguYWJzKGIpICogTWF0aC5zcXJ0KDEgKyByICogcik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gMDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0RmlsbGVkMkRBcnJheShyb3dzLCBjb2x1bW5zLCB2YWx1ZSkge1xuXHQgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHJvd3MpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcblx0ICAgICAgICBhcnJheVtpXSA9IG5ldyBBcnJheShjb2x1bW5zKTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICBhcnJheVtpXVtqXSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBhcnJheTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvblxuXHQgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vbHV0enJvZWRlci9NYXBhY2svYmxvYi9tYXN0ZXIvU291cmNlL1Npbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uLmNzXG5cdCAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29tcHV0ZUxlZnRTaW5ndWxhclZlY3RvcnM9dHJ1ZV1cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnM9dHJ1ZV1cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRvVHJhbnNwb3NlPWZhbHNlXVxuXHQgKi9cblx0Y2xhc3MgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24kJDEge1xuXHQgICAgY29uc3RydWN0b3IodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXHQgICAgICAgIHZhbHVlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KHZhbHVlKTtcblx0XG5cdCAgICAgICAgdmFyIG0gPSB2YWx1ZS5yb3dzO1xuXHQgICAgICAgIHZhciBuID0gdmFsdWUuY29sdW1ucztcblx0ICAgICAgICB2YXIgbnUgPSBNYXRoLm1pbihtLCBuKTtcblx0XG5cdCAgICAgICAgY29uc3Qge1xuXHQgICAgICAgICAgICBjb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyA9IHRydWUsXG5cdCAgICAgICAgICAgIGNvbXB1dGVSaWdodFNpbmd1bGFyVmVjdG9ycyA9IHRydWUsXG5cdCAgICAgICAgICAgIGF1dG9UcmFuc3Bvc2UgPSBmYWxzZVxuXHQgICAgICAgIH0gPSBvcHRpb25zO1xuXHRcblx0ICAgICAgICB2YXIgd2FudHUgPSBCb29sZWFuKGNvbXB1dGVMZWZ0U2luZ3VsYXJWZWN0b3JzKTtcblx0ICAgICAgICB2YXIgd2FudHYgPSBCb29sZWFuKGNvbXB1dGVSaWdodFNpbmd1bGFyVmVjdG9ycyk7XG5cdFxuXHQgICAgICAgIHZhciBzd2FwcGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIGE7XG5cdCAgICAgICAgaWYgKG0gPCBuKSB7XG5cdCAgICAgICAgICAgIGlmICghYXV0b1RyYW5zcG9zZSkge1xuXHQgICAgICAgICAgICAgICAgYSA9IHZhbHVlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb21wdXRpbmcgU1ZEIG9uIGEgbWF0cml4IHdpdGggbW9yZSBjb2x1bW5zIHRoYW4gcm93cy4gQ29uc2lkZXIgZW5hYmxpbmcgYXV0b1RyYW5zcG9zZScpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYSA9IHZhbHVlLnRyYW5zcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgbSA9IGEucm93cztcblx0ICAgICAgICAgICAgICAgIG4gPSBhLmNvbHVtbnM7XG5cdCAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHZhciBhdXggPSB3YW50dTtcblx0ICAgICAgICAgICAgICAgIHdhbnR1ID0gd2FudHY7XG5cdCAgICAgICAgICAgICAgICB3YW50diA9IGF1eDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGEgPSB2YWx1ZS5jbG9uZSgpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIHMgPSBuZXcgQXJyYXkoTWF0aC5taW4obSArIDEsIG4pKTtcblx0ICAgICAgICB2YXIgVSA9IGdldEZpbGxlZDJEQXJyYXkobSwgbnUsIDApO1xuXHQgICAgICAgIHZhciBWID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKTtcblx0ICAgICAgICB2YXIgZSA9IG5ldyBBcnJheShuKTtcblx0ICAgICAgICB2YXIgd29yayA9IG5ldyBBcnJheShtKTtcblx0XG5cdCAgICAgICAgdmFyIG5jdCA9IE1hdGgubWluKG0gLSAxLCBuKTtcblx0ICAgICAgICB2YXIgbnJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDIsIG0pKTtcblx0XG5cdCAgICAgICAgdmFyIGksIGosIGssIHAsIHQsIGtzLCBmLCBjcywgc24sIG1heCwga2FzZSxcblx0ICAgICAgICAgICAgc2NhbGUsIHNwLCBzcG0xLCBlcG0xLCBzaywgZWssIGIsIGMsIHNoaWZ0LCBnO1xuXHRcblx0ICAgICAgICBmb3IgKGsgPSAwLCBtYXggPSBNYXRoLm1heChuY3QsIG5ydCk7IGsgPCBtYXg7IGsrKykge1xuXHQgICAgICAgICAgICBpZiAoayA8IG5jdCkge1xuXHQgICAgICAgICAgICAgICAgc1trXSA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc1trXSA9IGh5cG90ZW51c2Uoc1trXSwgYVtpXVtrXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoc1trXSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhW2tdW2tdIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzW2tdID0gLXNba107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYVtpXVtrXSAvPSBzW2tdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBhW2tdW2tdICs9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzW2tdID0gLXNba107XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoKGsgPCBuY3QpICYmIChzW2tdICE9PSAwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCArPSBhW2ldW2tdICogYVtpXVtqXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdCA9IC10IC8gYVtrXVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFbaV1bal0gKz0gdCAqIGFbaV1ba107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZVtqXSA9IGFba11bal07XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGlmICh3YW50dSAmJiAoayA8IG5jdCkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBVW2ldW2tdID0gYVtpXVtrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaWYgKGsgPCBucnQpIHtcblx0ICAgICAgICAgICAgICAgIGVba10gPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBlW2tdID0gaHlwb3RlbnVzZShlW2tdLCBlW2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChlW2tdICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVbayArIDFdIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlW2tdID0gMCAtIGVba107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVbaV0gLz0gZVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZVtrICsgMV0gKz0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVba10gPSAtZVtrXTtcblx0ICAgICAgICAgICAgICAgIGlmICgoayArIDEgPCBtKSAmJiAoZVtrXSAhPT0gMCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3b3JrW2ldID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaV0gKz0gZVtqXSAqIGFbaV1bal07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IC1lW2pdIC8gZVtrICsgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldW2pdICs9IHQgKiB3b3JrW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IGVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBwID0gTWF0aC5taW4obiwgbSArIDEpO1xuXHQgICAgICAgIGlmIChuY3QgPCBuKSB7XG5cdCAgICAgICAgICAgIHNbbmN0XSA9IGFbbmN0XVtuY3RdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobSA8IHApIHtcblx0ICAgICAgICAgICAgc1twIC0gMV0gPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobnJ0ICsgMSA8IHApIHtcblx0ICAgICAgICAgICAgZVtucnRdID0gYVtucnRdW3AgLSAxXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZVtwIC0gMV0gPSAwO1xuXHRcblx0ICAgICAgICBpZiAod2FudHUpIHtcblx0ICAgICAgICAgICAgZm9yIChqID0gbmN0OyBqIDwgbnU7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIFVbaV1bal0gPSAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgVVtqXVtqXSA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yIChrID0gbmN0IC0gMTsgayA+PSAwOyBrLS0pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzW2tdICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gayArIDE7IGogPCBudTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9IFVbaV1ba10gKiBVW2ldW2pdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAtdCAvIFVba11ba107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1bal0gKz0gdCAqIFVbaV1ba107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2tdID0gLVVbaV1ba107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIFVba11ba10gPSAxICsgVVtrXVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgayAtIDE7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2tdID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVVtpXVtrXSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIFVba11ba10gPSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAod2FudHYpIHtcblx0ICAgICAgICAgICAgZm9yIChrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoKGsgPCBucnQpICYmIChlW2tdICE9PSAwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSBWW2ldW2tdICogVltpXVtqXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gLXQgLyBWW2sgKyAxXVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gayArIDE7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bal0gKz0gdCAqIFZbaV1ba107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBWW2tdW2tdID0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIHBwID0gcCAtIDE7XG5cdCAgICAgICAgdmFyIGl0ZXIgPSAwO1xuXHQgICAgICAgIHZhciBlcHMgPSBOdW1iZXIuRVBTSUxPTjtcblx0ICAgICAgICB3aGlsZSAocCA+IDApIHtcblx0ICAgICAgICAgICAgZm9yIChrID0gcCAtIDI7IGsgPj0gLTE7IGstLSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGsgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZVtrXSkgPD0gZXBzICogKE1hdGguYWJzKHNba10pICsgTWF0aC5hYnMoc1trICsgMV0pKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVba10gPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChrID09PSBwIC0gMikge1xuXHQgICAgICAgICAgICAgICAga2FzZSA9IDQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGtzID0gcCAtIDE7IGtzID49IGs7IGtzLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoa3MgPT09IGspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHQgPSAoa3MgIT09IHAgPyBNYXRoLmFicyhlW2tzXSkgOiAwKSArIChrcyAhPT0gayArIDEgPyBNYXRoLmFicyhlW2tzIC0gMV0pIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNba3NdKSA8PSBlcHMgKiB0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNba3NdID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGtzID09PSBrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2FzZSA9IDM7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtzID09PSBwIC0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGthc2UgPSAxO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBrYXNlID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBrID0ga3M7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGsrKztcblx0XG5cdCAgICAgICAgICAgIHN3aXRjaCAoa2FzZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZiA9IGVbcCAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVbcCAtIDJdID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBwIC0gMjsgaiA+PSBrOyBqLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGh5cG90ZW51c2Uoc1tqXSwgZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gc1tqXSAvIHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNuID0gZiAvIHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNbal0gPSB0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IC1zbiAqIGVbaiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZVtqIC0gMV0gPSBjcyAqIGVbaiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50dikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjcyAqIFZbaV1bal0gKyBzbiAqIFZbaV1bcCAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bcCAtIDFdID0gLXNuICogVltpXVtqXSArIGNzICogVltpXVtwIC0gMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtqXSA9IHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXNlIDIgOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZiA9IGVbayAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVbayAtIDFdID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBrOyBqIDwgcDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBoeXBvdGVudXNlKHNbal0sIGYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHNbal0gLyB0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzbiA9IGYgLyB0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzW2pdID0gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZiA9IC1zbiAqIGVbal07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVbal0gPSBjcyAqIGVbal07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50dSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjcyAqIFVbaV1bal0gKyBzbiAqIFVbaV1bayAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1bayAtIDFdID0gLXNuICogVVtpXVtqXSArIGNzICogVVtpXVtrIC0gMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVVtpXVtqXSA9IHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXNlIDMgOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBNYXRoLm1heChNYXRoLmFicyhzW3AgLSAxXSksIE1hdGguYWJzKHNbcCAtIDJdKSwgTWF0aC5hYnMoZVtwIC0gMl0pLCBNYXRoLmFicyhzW2tdKSwgTWF0aC5hYnMoZVtrXSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNwID0gc1twIC0gMV0gLyBzY2FsZTtcblx0ICAgICAgICAgICAgICAgICAgICBzcG0xID0gc1twIC0gMl0gLyBzY2FsZTtcblx0ICAgICAgICAgICAgICAgICAgICBlcG0xID0gZVtwIC0gMl0gLyBzY2FsZTtcblx0ICAgICAgICAgICAgICAgICAgICBzayA9IHNba10gLyBzY2FsZTtcblx0ICAgICAgICAgICAgICAgICAgICBlayA9IGVba10gLyBzY2FsZTtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gKChzcG0xICsgc3ApICogKHNwbTEgLSBzcCkgKyBlcG0xICogZXBtMSkgLyAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGMgPSAoc3AgKiBlcG0xKSAqIChzcCAqIGVwbTEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKGIgIT09IDApIHx8IChjICE9PSAwKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IE1hdGguc3FydChiICogYiArIGMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gLXNoaWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gYyAvIChiICsgc2hpZnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBmID0gKHNrICsgc3ApICogKHNrIC0gc3ApICsgc2hpZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZyA9IHNrICogZWs7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gazsgaiA8IHAgLSAxOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGh5cG90ZW51c2UoZiwgZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gZiAvIHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNuID0gZyAvIHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlW2ogLSAxXSA9IHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGNzICogc1tqXSArIHNuICogZVtqXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZVtqXSA9IGNzICogZVtqXSAtIHNuICogc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHNuICogc1tqICsgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNbaiArIDFdID0gY3MgKiBzW2ogKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNzICogVltpXVtqXSArIHNuICogVltpXVtqICsgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtqICsgMV0gPSAtc24gKiBWW2ldW2pdICsgY3MgKiBWW2ldW2ogKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2pdID0gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gaHlwb3RlbnVzZShmLCBnKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBmIC8gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc24gPSBnIC8gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc1tqXSA9IHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBjcyAqIGVbal0gKyBzbiAqIHNbaiArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzW2ogKyAxXSA9IC1zbiAqIGVbal0gKyBjcyAqIHNbaiArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnID0gc24gKiBlW2ogKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZVtqICsgMV0gPSBjcyAqIGVbaiArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FudHUgJiYgKGogPCBtIC0gMSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gY3MgKiBVW2ldW2pdICsgc24gKiBVW2ldW2ogKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2ogKyAxXSA9IC1zbiAqIFVbaV1bal0gKyBjcyAqIFVbaV1baiArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1bal0gPSB0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVbcCAtIDJdID0gZjtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVyID0gaXRlciArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc1trXSA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNba10gPSAoc1trXSA8IDAgPyAtc1trXSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FudHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gcHA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1ba10gPSAtVltpXVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoayA8IHBwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzW2tdID49IHNbayArIDFdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gc1trXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc1trXSA9IHNbayArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzW2sgKyAxXSA9IHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YW50diAmJiAoayA8IG4gLSAxKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBWW2ldW2sgKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2sgKyAxXSA9IFZbaV1ba107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbnR1ICYmIChrIDwgbSAtIDEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFVbaV1bayArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVbaV1bayArIDFdID0gVVtpXVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVW2ldW2tdID0gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrKys7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZXIgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHAtLTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIG5vIGRlZmF1bHRcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHN3YXBwZWQpIHtcblx0ICAgICAgICAgICAgdmFyIHRtcCA9IFY7XG5cdCAgICAgICAgICAgIFYgPSBVO1xuXHQgICAgICAgICAgICBVID0gdG1wO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdGhpcy5tID0gbTtcblx0ICAgICAgICB0aGlzLm4gPSBuO1xuXHQgICAgICAgIHRoaXMucyA9IHM7XG5cdCAgICAgICAgdGhpcy5VID0gVTtcblx0ICAgICAgICB0aGlzLlYgPSBWO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogU29sdmUgYSBwcm9ibGVtIG9mIGxlYXN0IHNxdWFyZSAoQXg9YikgYnkgdXNpbmcgdGhlIFNWRC4gVXNlZnVsIHdoZW4gQSBpcyBzaW5ndWxhci4gV2hlbiBBIGlzIG5vdCBzaW5ndWxhciwgaXQgd291bGQgYmUgYmV0dGVyIHRvIHVzZSBxci5zb2x2ZSh2YWx1ZSkuXG5cdCAgICAgKiBFeGFtcGxlIDogV2Ugc2VhcmNoIHRvIGFwcHJveGltYXRlIHgsIHdpdGggQSBtYXRyaXggc2hhcGUgbSpuLCB4IHZlY3RvciBzaXplIG4sIGIgdmVjdG9yIHNpemUgbSAobSA+IG4pLiBXZSB3aWxsIHVzZSA6XG5cdCAgICAgKiB2YXIgc3ZkID0gU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24oQSk7XG5cdCAgICAgKiB2YXIgeCA9IHN2ZC5zb2x2ZShiKTtcblx0ICAgICAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZSAtIE1hdHJpeCAxRCB3aGljaCBpcyB0aGUgdmVjdG9yIGIgKGluIHRoZSBlcXVhdGlvbiBBeCA9IGIpXG5cdCAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IC0gVGhlIHZlY3RvciB4XG5cdCAgICAgKi9cblx0ICAgIHNvbHZlKHZhbHVlKSB7XG5cdFxuXHQgICAgICAgIHZhciBZID0gdmFsdWU7XG5cdCAgICAgICAgdmFyIGUgPSB0aGlzLnRocmVzaG9sZDtcblx0ICAgICAgICB2YXIgc2NvbHMgPSB0aGlzLnMubGVuZ3RoO1xuXHQgICAgICAgIHZhciBMcyA9IE1hdHJpeC56ZXJvcyhzY29scywgc2NvbHMpO1xuXHQgICAgICAgIHZhciBpO1xuXHRcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NvbHM7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zW2ldKSA8PSBlKSB7XG5cdCAgICAgICAgICAgICAgICBMc1tpXVtpXSA9IDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBMc1tpXVtpXSA9IDEgLyB0aGlzLnNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBVID0gdGhpcy5VO1xuXHQgICAgICAgIHZhciBWID0gdGhpcy5yaWdodFNpbmd1bGFyVmVjdG9ycztcblx0XG5cdCAgICAgICAgdmFyIFZMID0gVi5tbXVsKExzKTtcblx0ICAgICAgICB2YXIgdnJvd3MgPSBWLnJvd3M7XG5cdCAgICAgICAgdmFyIHVyb3dzID0gVS5sZW5ndGg7XG5cdCAgICAgICAgdmFyIFZMVSA9IE1hdHJpeC56ZXJvcyh2cm93cywgdXJvd3MpO1xuXHQgICAgICAgIHZhciBqLCBrLCBzdW07XG5cdFxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB1cm93czsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBzdW0gPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHNjb2xzOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdW0gKz0gVkxbaV1ba10gKiBVW2pdW2tdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgVkxVW2ldW2pdID0gc3VtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gVkxVLm1tdWwoWSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZVxuXHQgICAgICogQHJldHVybiB7TWF0cml4fVxuXHQgICAgICovXG5cdCAgICBzb2x2ZUZvckRpYWdvbmFsKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc29sdmUoTWF0cml4LmRpYWcodmFsdWUpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldCB0aGUgaW52ZXJzZSBvZiB0aGUgbWF0cml4LiBXZSBjb21wdXRlIHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4IHVzaW5nIFNWRCB3aGVuIHRoaXMgbWF0cml4IGlzIHNpbmd1bGFyIG9yIGlsbC1jb25kaXRpb25lZC4gRXhhbXBsZSA6XG5cdCAgICAgKiB2YXIgc3ZkID0gU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24oQSk7XG5cdCAgICAgKiB2YXIgaW52ZXJzZUEgPSBzdmQuaW52ZXJzZSgpO1xuXHQgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBhcHByb3hpbWF0aW9uIG9mIHRoZSBpbnZlcnNlIG9mIHRoZSBtYXRyaXhcblx0ICAgICAqL1xuXHQgICAgaW52ZXJzZSgpIHtcblx0ICAgICAgICB2YXIgViA9IHRoaXMuVjtcblx0ICAgICAgICB2YXIgZSA9IHRoaXMudGhyZXNob2xkO1xuXHQgICAgICAgIHZhciB2cm93cyA9IFYubGVuZ3RoO1xuXHQgICAgICAgIHZhciB2Y29scyA9IFZbMF0ubGVuZ3RoO1xuXHQgICAgICAgIHZhciBYID0gbmV3IE1hdHJpeCh2cm93cywgdGhpcy5zLmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGksIGo7XG5cdFxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2cm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2Y29sczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zW2pdKSA+IGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gVltpXVtqXSAvIHRoaXMuc1tqXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBVID0gdGhpcy5VO1xuXHRcblx0ICAgICAgICB2YXIgdXJvd3MgPSBVLmxlbmd0aDtcblx0ICAgICAgICB2YXIgdWNvbHMgPSBVWzBdLmxlbmd0aDtcblx0ICAgICAgICB2YXIgWSA9IG5ldyBNYXRyaXgodnJvd3MsIHVyb3dzKTtcblx0ICAgICAgICB2YXIgaywgc3VtO1xuXHRcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdXJvd3M7IGorKykge1xuXHQgICAgICAgICAgICAgICAgc3VtID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCB1Y29sczsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VtICs9IFhbaV1ba10gKiBVW2pdW2tdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgWVtpXVtqXSA9IHN1bTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIFk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICovXG5cdCAgICBnZXQgY29uZGl0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNbMF0gLyB0aGlzLnNbTWF0aC5taW4odGhpcy5tLCB0aGlzLm4pIC0gMV07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICovXG5cdCAgICBnZXQgbm9ybTIoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc1swXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgKi9cblx0ICAgIGdldCByYW5rKCkge1xuXHQgICAgICAgIHZhciB0b2wgPSBNYXRoLm1heCh0aGlzLm0sIHRoaXMubikgKiB0aGlzLnNbMF0gKiBOdW1iZXIuRVBTSUxPTjtcblx0ICAgICAgICB2YXIgciA9IDA7XG5cdCAgICAgICAgdmFyIHMgPSB0aGlzLnM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChzW2ldID4gdG9sKSB7XG5cdCAgICAgICAgICAgICAgICByKys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHI7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn1cblx0ICAgICAqL1xuXHQgICAgZ2V0IGRpYWdvbmFsKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnM7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICovXG5cdCAgICBnZXQgdGhyZXNob2xkKCkge1xuXHQgICAgICAgIHJldHVybiAoTnVtYmVyLkVQU0lMT04gLyAyKSAqIE1hdGgubWF4KHRoaXMubSwgdGhpcy5uKSAqIHRoaXMuc1swXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAgICAgKi9cblx0ICAgIGdldCBsZWZ0U2luZ3VsYXJWZWN0b3JzKCkge1xuXHQgICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVSkpIHtcblx0ICAgICAgICAgICAgdGhpcy5VID0gbmV3IE1hdHJpeCh0aGlzLlUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5VO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgZ2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCkge1xuXHQgICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVikpIHtcblx0ICAgICAgICAgICAgdGhpcy5WID0gbmV3IE1hdHJpeCh0aGlzLlYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5WO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgZ2V0IGRpYWdvbmFsTWF0cml4KCkge1xuXHQgICAgICAgIHJldHVybiBNYXRyaXguZGlhZyh0aGlzLnMpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQ2hlY2sgdGhhdCBhIHJvdyBpbmRleCBpcyBub3Qgb3V0IG9mIGJvdW5kc1xuXHQgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdXRlcl1cblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrUm93SW5kZXgobWF0cml4LCBpbmRleCwgb3V0ZXIpIHtcblx0ICAgIHZhciBtYXggPSBvdXRlciA/IG1hdHJpeC5yb3dzIDogbWF0cml4LnJvd3MgLSAxO1xuXHQgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IG1heCkge1xuXHQgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSb3cgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG5cdCAgICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBDaGVjayB0aGF0IGEgY29sdW1uIGluZGV4IGlzIG5vdCBvdXQgb2YgYm91bmRzXG5cdCAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW291dGVyXVxuXHQgKi9cblx0ZnVuY3Rpb24gY2hlY2tDb2x1bW5JbmRleChtYXRyaXgsIGluZGV4LCBvdXRlcikge1xuXHQgICAgdmFyIG1heCA9IG91dGVyID8gbWF0cml4LmNvbHVtbnMgOiBtYXRyaXguY29sdW1ucyAtIDE7XG5cdCAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4KSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcblx0ICAgIH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIENoZWNrIHRoYXQgdGhlIHByb3ZpZGVkIHZlY3RvciBpcyBhbiBhcnJheSB3aXRoIHRoZSByaWdodCBsZW5ndGhcblx0ICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuXHQgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuXHQgKi9cblx0ZnVuY3Rpb24gY2hlY2tSb3dWZWN0b3IobWF0cml4LCB2ZWN0b3IpIHtcblx0ICAgIGlmICh2ZWN0b3IudG8xREFycmF5KSB7XG5cdCAgICAgICAgdmVjdG9yID0gdmVjdG9yLnRvMURBcnJheSgpO1xuXHQgICAgfVxuXHQgICAgaWYgKHZlY3Rvci5sZW5ndGggIT09IG1hdHJpeC5jb2x1bW5zKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZlY3RvciBzaXplIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmVjdG9yO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQ2hlY2sgdGhhdCB0aGUgcHJvdmlkZWQgdmVjdG9yIGlzIGFuIGFycmF5IHdpdGggdGhlIHJpZ2h0IGxlbmd0aFxuXHQgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3Jcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9XG5cdCAqL1xuXHRmdW5jdGlvbiBjaGVja0NvbHVtblZlY3RvcihtYXRyaXgsIHZlY3Rvcikge1xuXHQgICAgaWYgKHZlY3Rvci50bzFEQXJyYXkpIHtcblx0ICAgICAgICB2ZWN0b3IgPSB2ZWN0b3IudG8xREFycmF5KCk7XG5cdCAgICB9XG5cdCAgICBpZiAodmVjdG9yLmxlbmd0aCAhPT0gbWF0cml4LnJvd3MpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2ZWN0b3I7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNoZWNrSW5kaWNlcyhtYXRyaXgsIHJvd0luZGljZXMsIGNvbHVtbkluZGljZXMpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgcm93OiBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKSxcblx0ICAgICAgICBjb2x1bW46IGNoZWNrQ29sdW1uSW5kaWNlcyhtYXRyaXgsIGNvbHVtbkluZGljZXMpXG5cdCAgICB9O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKSB7XG5cdCAgICBpZiAodHlwZW9mIHJvd0luZGljZXMgIT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5leHBlY3RlZCB0eXBlIGZvciByb3cgaW5kaWNlcycpO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciByb3dPdXQgPSByb3dJbmRpY2VzLnNvbWUociA9PiB7XG5cdCAgICAgICAgcmV0dXJuIHIgPCAwIHx8IHIgPj0gbWF0cml4LnJvd3M7XG5cdFxuXHQgICAgfSk7XG5cdFxuXHQgICAgaWYgKHJvd091dCkge1xuXHQgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyb3cgaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKCFBcnJheS5pc0FycmF5KHJvd0luZGljZXMpKSByb3dJbmRpY2VzID0gQXJyYXkuZnJvbShyb3dJbmRpY2VzKTtcblx0XG5cdCAgICByZXR1cm4gcm93SW5kaWNlcztcblx0fVxuXHRcblx0ZnVuY3Rpb24gY2hlY2tDb2x1bW5JbmRpY2VzKG1hdHJpeCwgY29sdW1uSW5kaWNlcykge1xuXHQgICAgaWYgKHR5cGVvZiBjb2x1bW5JbmRpY2VzICE9PSAnb2JqZWN0Jykge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgdHlwZSBmb3IgY29sdW1uIGluZGljZXMnKTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgY29sdW1uT3V0ID0gY29sdW1uSW5kaWNlcy5zb21lKGMgPT4ge1xuXHQgICAgICAgIHJldHVybiBjIDwgMCB8fCBjID49IG1hdHJpeC5jb2x1bW5zO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgaWYgKGNvbHVtbk91dCkge1xuXHQgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG5cdCAgICB9XG5cdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sdW1uSW5kaWNlcykpIGNvbHVtbkluZGljZXMgPSBBcnJheS5mcm9tKGNvbHVtbkluZGljZXMpO1xuXHRcblx0ICAgIHJldHVybiBjb2x1bW5JbmRpY2VzO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjaGVja1JhbmdlKG1hdHJpeCwgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgdHlwZScpO1xuXHQgICAgdmFyIG5vdEFsbE51bWJlcnMgPSBBcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkuc29tZShmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgIT09ICdudW1iZXInO1xuXHQgICAgfSk7XG5cdCAgICBpZiAobm90QWxsTnVtYmVycykgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCB0eXBlJyk7XG5cdCAgICBpZiAoc3RhcnRSb3cgPiBlbmRSb3cgfHwgc3RhcnRDb2x1bW4gPiBlbmRDb2x1bW4gfHwgc3RhcnRSb3cgPCAwIHx8IHN0YXJ0Um93ID49IG1hdHJpeC5yb3dzIHx8IGVuZFJvdyA8IDAgfHwgZW5kUm93ID49IG1hdHJpeC5yb3dzIHx8IHN0YXJ0Q29sdW1uIDwgMCB8fCBzdGFydENvbHVtbiA+PSBtYXRyaXguY29sdW1ucyB8fCBlbmRDb2x1bW4gPCAwIHx8IGVuZENvbHVtbiA+PSBtYXRyaXguY29sdW1ucykge1xuXHQgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG5cdCAgICB9XG5cdH1cblx0XG5cdFxuXHRcblx0ZnVuY3Rpb24gc3VtQnlSb3cobWF0cml4KSB7XG5cdCAgICB2YXIgc3VtID0gTWF0cml4Lnplcm9zKG1hdHJpeC5yb3dzLCAxKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7ICsraSkge1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7ICsraikge1xuXHQgICAgICAgICAgICBzdW0uc2V0KGksIDAsIHN1bS5nZXQoaSwgMCkgKyBtYXRyaXguZ2V0KGksIGopKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3VtO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzdW1CeUNvbHVtbihtYXRyaXgpIHtcblx0ICAgIHZhciBzdW0gPSBNYXRyaXguemVyb3MoMSwgbWF0cml4LmNvbHVtbnMpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgKytpKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG5cdCAgICAgICAgICAgIHN1bS5zZXQoMCwgaiwgc3VtLmdldCgwLCBqKSArIG1hdHJpeC5nZXQoaSwgaikpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBzdW07XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHN1bUFsbChtYXRyaXgpIHtcblx0ICAgIHZhciB2ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICB2ICs9IG1hdHJpeC5nZXQoaSwgaik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHY7XG5cdH1cblx0XG5cdGNsYXNzIEJhc2VWaWV3IGV4dGVuZHMgQWJzdHJhY3RNYXRyaXgoKSB7XG5cdCAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvd3MsIGNvbHVtbnMpIHtcblx0ICAgICAgICBzdXBlcigpO1xuXHQgICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuXHQgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG5cdCAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcblx0ICAgIH1cblx0XG5cdCAgICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdHJpeDtcblx0ICAgIH1cblx0fVxuXHRcblx0Y2xhc3MgTWF0cml4VHJhbnNwb3NlVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcblx0ICAgIGNvbnN0cnVjdG9yKG1hdHJpeCkge1xuXHQgICAgICAgIHN1cGVyKG1hdHJpeCwgbWF0cml4LmNvbHVtbnMsIG1hdHJpeC5yb3dzKTtcblx0ICAgIH1cblx0XG5cdCAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMubWF0cml4LnNldChjb2x1bW5JbmRleCwgcm93SW5kZXgsIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChjb2x1bW5JbmRleCwgcm93SW5kZXgpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRjbGFzcyBNYXRyaXhSb3dWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuXHQgICAgY29uc3RydWN0b3IobWF0cml4LCByb3cpIHtcblx0ICAgICAgICBzdXBlcihtYXRyaXgsIDEsIG1hdHJpeC5jb2x1bW5zKTtcblx0ICAgICAgICB0aGlzLnJvdyA9IHJvdztcblx0ICAgIH1cblx0XG5cdCAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMubWF0cml4LnNldCh0aGlzLnJvdywgY29sdW1uSW5kZXgsIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvdywgY29sdW1uSW5kZXgpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRjbGFzcyBNYXRyaXhTdWJWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuXHQgICAgY29uc3RydWN0b3IobWF0cml4LCBzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG5cdCAgICAgICAgY2hlY2tSYW5nZShtYXRyaXgsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pO1xuXHQgICAgICAgIHN1cGVyKG1hdHJpeCwgZW5kUm93IC0gc3RhcnRSb3cgKyAxLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpO1xuXHQgICAgICAgIHRoaXMuc3RhcnRSb3cgPSBzdGFydFJvdztcblx0ICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG5cdCAgICB9XG5cdFxuXHQgICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICB0aGlzLm1hdHJpeC5zZXQodGhpcy5zdGFydFJvdyArIHJvd0luZGV4LCB0aGlzLnN0YXJ0Q29sdW1uICsgY29sdW1uSW5kZXgsIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnN0YXJ0Um93ICsgcm93SW5kZXgsIHRoaXMuc3RhcnRDb2x1bW4gKyBjb2x1bW5JbmRleCk7XG5cdCAgICB9XG5cdH1cblx0XG5cdGNsYXNzIE1hdHJpeFNlbGVjdGlvblZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XG5cdCAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvd0luZGljZXMsIGNvbHVtbkluZGljZXMpIHtcblx0ICAgICAgICB2YXIgaW5kaWNlcyA9IGNoZWNrSW5kaWNlcyhtYXRyaXgsIHJvd0luZGljZXMsIGNvbHVtbkluZGljZXMpO1xuXHQgICAgICAgIHN1cGVyKG1hdHJpeCwgaW5kaWNlcy5yb3cubGVuZ3RoLCBpbmRpY2VzLmNvbHVtbi5sZW5ndGgpO1xuXHQgICAgICAgIHRoaXMucm93SW5kaWNlcyA9IGluZGljZXMucm93O1xuXHQgICAgICAgIHRoaXMuY29sdW1uSW5kaWNlcyA9IGluZGljZXMuY29sdW1uO1xuXHQgICAgfVxuXHRcblx0ICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy5tYXRyaXguc2V0KHRoaXMucm93SW5kaWNlc1tyb3dJbmRleF0sIHRoaXMuY29sdW1uSW5kaWNlc1tjb2x1bW5JbmRleF0sIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCB0aGlzLmNvbHVtbkluZGljZXNbY29sdW1uSW5kZXhdKTtcblx0ICAgIH1cblx0fVxuXHRcblx0Y2xhc3MgTWF0cml4Um93U2VsZWN0aW9uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcblx0ICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgcm93SW5kaWNlcykge1xuXHQgICAgICAgIHJvd0luZGljZXMgPSBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKTtcblx0ICAgICAgICBzdXBlcihtYXRyaXgsIHJvd0luZGljZXMubGVuZ3RoLCBtYXRyaXguY29sdW1ucyk7XG5cdCAgICAgICAgdGhpcy5yb3dJbmRpY2VzID0gcm93SW5kaWNlcztcblx0ICAgIH1cblx0XG5cdCAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMubWF0cml4LnNldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCBjb2x1bW5JbmRleCwgdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHRcblx0ICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KHRoaXMucm93SW5kaWNlc1tyb3dJbmRleF0sIGNvbHVtbkluZGV4KTtcblx0ICAgIH1cblx0fVxuXHRcblx0Y2xhc3MgTWF0cml4Q29sdW1uU2VsZWN0aW9uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcblx0ICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgY29sdW1uSW5kaWNlcykge1xuXHQgICAgICAgIGNvbHVtbkluZGljZXMgPSBjaGVja0NvbHVtbkluZGljZXMobWF0cml4LCBjb2x1bW5JbmRpY2VzKTtcblx0ICAgICAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5yb3dzLCBjb2x1bW5JbmRpY2VzLmxlbmd0aCk7XG5cdCAgICAgICAgdGhpcy5jb2x1bW5JbmRpY2VzID0gY29sdW1uSW5kaWNlcztcblx0ICAgIH1cblx0XG5cdCAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMubWF0cml4LnNldChyb3dJbmRleCwgdGhpcy5jb2x1bW5JbmRpY2VzW2NvbHVtbkluZGV4XSwgdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHRcblx0ICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbkluZGljZXNbY29sdW1uSW5kZXhdKTtcblx0ICAgIH1cblx0fVxuXHRcblx0Y2xhc3MgTWF0cml4Q29sdW1uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcblx0ICAgIGNvbnN0cnVjdG9yKG1hdHJpeCwgY29sdW1uKSB7XG5cdCAgICAgICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgMSk7XG5cdCAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG5cdCAgICB9XG5cdFxuXHQgICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICB0aGlzLm1hdHJpeC5zZXQocm93SW5kZXgsIHRoaXMuY29sdW1uLCB2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdFxuXHQgICAgZ2V0KHJvd0luZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChyb3dJbmRleCwgdGhpcy5jb2x1bW4pO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRjbGFzcyBNYXRyaXhGbGlwUm93VmlldyBleHRlbmRzIEJhc2VWaWV3IHtcblx0ICAgIGNvbnN0cnVjdG9yKG1hdHJpeCkge1xuXHQgICAgICAgIHN1cGVyKG1hdHJpeCwgbWF0cml4LnJvd3MsIG1hdHJpeC5jb2x1bW5zKTtcblx0ICAgIH1cblx0XG5cdCAgICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMubWF0cml4LnNldCh0aGlzLnJvd3MgLSByb3dJbmRleCAtIDEsIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdFxuXHQgICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQodGhpcy5yb3dzIC0gcm93SW5kZXggLSAxLCBjb2x1bW5JbmRleCk7XG5cdCAgICB9XG5cdH1cblx0XG5cdGNsYXNzIE1hdHJpeEZsaXBDb2x1bW5WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuXHQgICAgY29uc3RydWN0b3IobWF0cml4KSB7XG5cdCAgICAgICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgbWF0cml4LmNvbHVtbnMpO1xuXHQgICAgfVxuXHRcblx0ICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy5tYXRyaXguc2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbnMgLSBjb2x1bW5JbmRleCAtIDEsIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChyb3dJbmRleCwgdGhpcy5jb2x1bW5zIC0gY29sdW1uSW5kZXggLSAxKTtcblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gQWJzdHJhY3RNYXRyaXgoc3VwZXJDdG9yKSB7XG5cdCAgICBpZiAoc3VwZXJDdG9yID09PSB1bmRlZmluZWQpIHN1cGVyQ3RvciA9IE9iamVjdDtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlYWwgbWF0cml4XG5cdCAgICAgKiBAY2xhc3MgTWF0cml4XG5cdCAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheXxNYXRyaXh9IG5Sb3dzIC0gTnVtYmVyIG9mIHJvd3Mgb2YgdGhlIG5ldyBtYXRyaXgsXG5cdCAgICAgKiAyRCBhcnJheSBjb250YWluaW5nIHRoZSBkYXRhIG9yIE1hdHJpeCBpbnN0YW5jZSB0byBjbG9uZVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuQ29sdW1uc10gLSBOdW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgbmV3IG1hdHJpeFxuXHQgICAgICovXG5cdCAgICBjbGFzcyBNYXRyaXggZXh0ZW5kcyBzdXBlckN0b3Ige1xuXHQgICAgICAgIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgTWF0cml4IHdpdGggdGhlIGNob3NlbiBkaW1lbnNpb25zIGZyb20gYSAxRCBhcnJheVxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdSb3dzIC0gTnVtYmVyIG9mIHJvd3Ncblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3Q29sdW1ucyAtIE51bWJlciBvZiBjb2x1bW5zXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbmV3RGF0YSAtIEEgMUQgYXJyYXkgY29udGFpbmluZyBkYXRhIGZvciB0aGUgbWF0cml4XG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIGZyb20xREFycmF5KG5ld1Jvd3MsIG5ld0NvbHVtbnMsIG5ld0RhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG5ld1Jvd3MgKiBuZXdDb2x1bW5zO1xuXHQgICAgICAgICAgICBpZiAobGVuZ3RoICE9PSBuZXdEYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0RhdGEgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGdpdmVuIGRpbWVuc2lvbnMnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gbmV3IHRoaXMobmV3Um93cywgbmV3Q29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG5ld1Jvd3M7IHJvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCBuZXdDb2x1bW5zOyBjb2x1bW4rKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5ld01hdHJpeC5zZXQocm93LCBjb2x1bW4sIG5ld0RhdGFbcm93ICogbmV3Q29sdW1ucyArIGNvbHVtbl0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdNYXRyaXg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgcm93IHZlY3RvciwgYSBtYXRyaXggd2l0aCBvbmx5IG9uZSByb3cuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbmV3RGF0YSAtIEEgMUQgYXJyYXkgY29udGFpbmluZyBkYXRhIGZvciB0aGUgdmVjdG9yXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIHJvd1ZlY3RvcihuZXdEYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgdGhpcygxLCBuZXdEYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmVjdG9yLnNldCgwLCBpLCBuZXdEYXRhW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvbHVtbiB2ZWN0b3IsIGEgbWF0cml4IHdpdGggb25seSBvbmUgY29sdW1uLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG5ld0RhdGEgLSBBIDFEIGFycmF5IGNvbnRhaW5pbmcgZGF0YSBmb3IgdGhlIHZlY3RvclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgbmV3IG1hdHJpeFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0YXRpYyBjb2x1bW5WZWN0b3IobmV3RGF0YSkge1xuXHQgICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IHRoaXMobmV3RGF0YS5sZW5ndGgsIDEpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZlY3Rvci5zZXQoaSwgMCwgbmV3RGF0YVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZlY3Rvcjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHVuZGVmaW5lZC4gU2FtZSBhcyB1c2luZyBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzIC0gTnVtYmVyIG9mIHJvd3Ncblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyAtIE51bWJlciBvZiBjb2x1bW5zXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgbWF0cml4XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIGVtcHR5KHJvd3MsIGNvbHVtbnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHJvd3MsIGNvbHVtbnMpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zLiBWYWx1ZXMgd2lsbCBiZSBzZXQgdG8gemVyby5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAtIE51bWJlciBvZiByb3dzXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnMgLSBOdW1iZXIgb2YgY29sdW1uc1xuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgbmV3IG1hdHJpeFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0YXRpYyB6ZXJvcyhyb3dzLCBjb2x1bW5zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5KHJvd3MsIGNvbHVtbnMpLmZpbGwoMCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHNldCB0byBvbmUuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zIC0gTnVtYmVyIG9mIGNvbHVtbnNcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IC0gVGhlIG5ldyBtYXRyaXhcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdGF0aWMgb25lcyhyb3dzLCBjb2x1bW5zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5KHJvd3MsIGNvbHVtbnMpLmZpbGwoMSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMuIFZhbHVlcyB3aWxsIGJlIHJhbmRvbWx5IHNldC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAtIE51bWJlciBvZiByb3dzXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnMgLSBOdW1iZXIgb2YgY29sdW1uc1xuXHQgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtybmc9TWF0aC5yYW5kb21dIC0gUmFuZG9tIG51bWJlciBnZW5lcmF0b3Jcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IFRoZSBuZXcgbWF0cml4XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIHJhbmQocm93cywgY29sdW1ucywgcm5nKSB7XG5cdCAgICAgICAgICAgIGlmIChybmcgPT09IHVuZGVmaW5lZCkgcm5nID0gTWF0aC5yYW5kb207XG5cdCAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmVtcHR5KHJvd3MsIGNvbHVtbnMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGksIGosIHJuZygpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zLiBWYWx1ZXMgd2lsbCBiZSByYW5kb20gaW50ZWdlcnMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3MgLSBOdW1iZXIgb2Ygcm93c1xuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zIC0gTnVtYmVyIG9mIGNvbHVtbnNcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFZhbHVlPTEwMDBdIC0gTWF4aW11bSB2YWx1ZVxuXHQgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtybmc9TWF0aC5yYW5kb21dIC0gUmFuZG9tIG51bWJlciBnZW5lcmF0b3Jcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IFRoZSBuZXcgbWF0cml4XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIHJhbmRJbnQocm93cywgY29sdW1ucywgbWF4VmFsdWUsIHJuZykge1xuXHQgICAgICAgICAgICBpZiAobWF4VmFsdWUgPT09IHVuZGVmaW5lZCkgbWF4VmFsdWUgPSAxMDAwO1xuXHQgICAgICAgICAgICBpZiAocm5nID09PSB1bmRlZmluZWQpIHJuZyA9IE1hdGgucmFuZG9tO1xuXHQgICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5lbXB0eShyb3dzLCBjb2x1bW5zKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5mbG9vcihybmcoKSAqIG1heFZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGksIGosIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbWF0cml4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZGltZW5zaW9uLiBWYWx1ZXMgb2YgdGhlIGRpYWdvbmFsIHdpbGwgYmUgMSBhbmQgb3RoZXJzIHdpbGwgYmUgMC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93cyAtIE51bWJlciBvZiByb3dzXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2x1bW5zPXJvd3NdIC0gTnVtYmVyIG9mIGNvbHVtbnNcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTFdIC0gVmFsdWUgdG8gZmlsbCB0aGUgZGlhZ29uYWwgd2l0aFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgbmV3IGlkZW50aXR5IG1hdHJpeFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0YXRpYyBleWUocm93cywgY29sdW1ucywgdmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCkgY29sdW1ucyA9IHJvd3M7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB2YWx1ZSA9IDE7XG5cdCAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2x1bW5zKTtcblx0ICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuemVyb3Mocm93cywgY29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgZGlhZ29uYWwgbWF0cml4IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIC0gQXJyYXkgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIGRpYWdvbmFsXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3dzXSAtIE51bWJlciBvZiByb3dzIChEZWZhdWx0OiBkYXRhLmxlbmd0aClcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbHVtbnNdIC0gTnVtYmVyIG9mIGNvbHVtbnMgKERlZmF1bHQ6IHJvd3MpXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSAtIFRoZSBuZXcgZGlhZ29uYWwgbWF0cml4XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIGRpYWcoZGF0YSwgcm93cywgY29sdW1ucykge1xuXHQgICAgICAgICAgICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICBpZiAocm93cyA9PT0gdW5kZWZpbmVkKSByb3dzID0gbDtcblx0ICAgICAgICAgICAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCkgY29sdW1ucyA9IHJvd3M7XG5cdCAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihsLCByb3dzLCBjb2x1bW5zKTtcblx0ICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuemVyb3Mocm93cywgY29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaSwgZGF0YVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSBtYXRyaXggd2hvc2UgZWxlbWVudHMgYXJlIHRoZSBtaW5pbXVtIGJldHdlZW4gbWF0cml4MSBhbmQgbWF0cml4MlxuXHQgICAgICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXgxXG5cdCAgICAgICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeDJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIG1pbihtYXRyaXgxLCBtYXRyaXgyKSB7XG5cdCAgICAgICAgICAgIG1hdHJpeDEgPSB0aGlzLmNoZWNrTWF0cml4KG1hdHJpeDEpO1xuXHQgICAgICAgICAgICBtYXRyaXgyID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgyKTtcblx0ICAgICAgICAgICAgdmFyIHJvd3MgPSBtYXRyaXgxLnJvd3M7XG5cdCAgICAgICAgICAgIHZhciBjb2x1bW5zID0gbWF0cml4MS5jb2x1bW5zO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMocm93cywgY29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgTWF0aC5taW4obWF0cml4MS5nZXQoaSwgaiksIG1hdHJpeDIuZ2V0KGksIGopKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSBtYXRyaXggd2hvc2UgZWxlbWVudHMgYXJlIHRoZSBtYXhpbXVtIGJldHdlZW4gbWF0cml4MSBhbmQgbWF0cml4MlxuXHQgICAgICAgICAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXgxXG5cdCAgICAgICAgICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeDJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RhdGljIG1heChtYXRyaXgxLCBtYXRyaXgyKSB7XG5cdCAgICAgICAgICAgIG1hdHJpeDEgPSB0aGlzLmNoZWNrTWF0cml4KG1hdHJpeDEpO1xuXHQgICAgICAgICAgICBtYXRyaXgyID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgyKTtcblx0ICAgICAgICAgICAgdmFyIHJvd3MgPSBtYXRyaXgxLnJvd3M7XG5cdCAgICAgICAgICAgIHZhciBjb2x1bW5zID0gbWF0cml4MS5jb2x1bW5zO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMocm93cywgY29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgTWF0aC5tYXgobWF0cml4MS5nZXQoaSwgaiksIG1hdHJpeDIuZ2V0KGksIGopKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENoZWNrIHRoYXQgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgTWF0cml4IGFuZCB0cmllcyB0byBpbnN0YW50aWF0ZSBvbmUgaWYgbm90XG5cdCAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdGF0aWMgY2hlY2tNYXRyaXgodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIE1hdHJpeC5pc01hdHJpeCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyB0aGlzKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBNYXRyaXgsIGZhbHNlIG90aGVyd2lzZVxuXHQgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcblx0ICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0YXRpYyBpc01hdHJpeCh2YWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmICh2YWx1ZS5rbGFzcyA9PT0gJ01hdHJpeCcpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQHByb3Age251bWJlcn0gc2l6ZSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hdHJpeC5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBnZXQgc2l6ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93cyAqIHRoaXMuY29sdW1ucztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFwcGxpZXMgYSBjYWxsYmFjayBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXguIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgaW4gdGhlIG1hdHJpeCAodGhpcykgY29udGV4dC5cblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gcGFyYW1ldGVycyA6IGkgKHJvdykgYW5kIGogKGNvbHVtbilcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBhcHBseShjYWxsYmFjaykge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaWkgPSB0aGlzLnJvd3M7XG5cdCAgICAgICAgICAgIHZhciBqaiA9IHRoaXMuY29sdW1ucztcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpqOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGksIGopO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIG5ldyAxRCBhcnJheSBmaWxsZWQgcm93IGJ5IHJvdyB3aXRoIHRoZSBtYXRyaXggdmFsdWVzXG5cdCAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG8xREFycmF5KCkge1xuXHQgICAgICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkodGhpcy5zaXplKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGFycmF5W2kgKiB0aGlzLmNvbHVtbnMgKyBqXSA9IHRoaXMuZ2V0KGksIGopO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhcnJheTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSAyRCBhcnJheSBjb250YWluaW5nIGEgY29weSBvZiB0aGUgZGF0YVxuXHQgICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvMkRBcnJheSgpIHtcblx0ICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkodGhpcy5yb3dzKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgY29weVtpXSA9IG5ldyBBcnJheSh0aGlzLmNvbHVtbnMpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvcHlbaV1bal0gPSB0aGlzLmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gY29weTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBoYXMgb25lIHJvd1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGlzUm93VmVjdG9yKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dzID09PSAxO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbWF0cml4IGhhcyBvbmUgY29sdW1uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaXNDb2x1bW5WZWN0b3IoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMgPT09IDE7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBtYXRyaXggaGFzIG9uZSByb3cgb3Igb25lIGNvbHVtblxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGlzVmVjdG9yKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMucm93cyA9PT0gMSkgfHwgKHRoaXMuY29sdW1ucyA9PT0gMSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBtYXRyaXggaGFzIHRoZSBzYW1lIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaXNTcXVhcmUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3MgPT09IHRoaXMuY29sdW1ucztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1hdHJpeCBpcyBzcXVhcmUgYW5kIGhhcyB0aGUgc2FtZSB2YWx1ZXMgb24gYm90aCBzaWRlcyBvZiB0aGUgZGlhZ29uYWxcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpc1N5bW1ldHJpYygpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNTcXVhcmUoKSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgIT09IHRoaXMuZ2V0KGosIGkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXRzIGEgZ2l2ZW4gZWxlbWVudCBvZiB0aGUgbWF0cml4LiBtYXQuc2V0KDMsNCwxKSBpcyBlcXVpdmFsZW50IHRvIG1hdFszXVs0XT0xXG5cdCAgICAgICAgICogQGFic3RyYWN0XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gSW5kZXggb2YgdGhlIHJvd1xuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIEluZGV4IG9mIHRoZSBjb2x1bW5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgZWxlbWVudFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQnKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdGhlIGdpdmVuIGVsZW1lbnQgb2YgdGhlIG1hdHJpeC4gbWF0LmdldCgzLDQpIGlzIGVxdWl2YWxlbnQgdG8gbWF0cml4WzNdWzRdXG5cdCAgICAgICAgICogQGFic3RyYWN0XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gSW5kZXggb2YgdGhlIHJvd1xuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIEluZGV4IG9mIHRoZSBjb2x1bW5cblx0ICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0IG1ldGhvZCBpcyB1bmltcGxlbWVudGVkJyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCB0aGF0IGlzIGEgcmVwZXRpdGlvbiBvZiB0aGUgY3VycmVudCBtYXRyaXguIE5ldyBtYXRyaXggaGFzIHJvd1JlcCB0aW1lcyB0aGUgbnVtYmVyIG9mXG5cdCAgICAgICAgICogcm93cyBvZiB0aGUgbWF0cml4LCBhbmQgY29sUmVwIHRpbWVzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgbWF0cml4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd1JlcCAtIE51bWJlciBvZiB0aW1lcyB0aGUgcm93cyBzaG91bGQgYmUgcmVwZWF0ZWRcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sUmVwIC0gTnVtYmVyIG9mIHRpbWVzIHRoZSBjb2x1bW5zIHNob3VsZCBiZSByZVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KFtbMSwyXV0pO1xuXHQgICAgICAgICAqIG1hdHJpeC5yZXBlYXQoMik7IC8vIFtbMSwyXSxbMSwyXV1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXBlYXQocm93UmVwLCBjb2xSZXApIHtcblx0ICAgICAgICAgICAgcm93UmVwID0gcm93UmVwIHx8IDE7XG5cdCAgICAgICAgICAgIGNvbFJlcCA9IGNvbFJlcCB8fCAxO1xuXHQgICAgICAgICAgICB2YXIgbWF0cml4ID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKHRoaXMucm93cyAqIHJvd1JlcCwgdGhpcy5jb2x1bW5zICogY29sUmVwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dSZXA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xSZXA7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXRTdWJNYXRyaXgodGhpcywgdGhpcy5yb3dzICogaSwgdGhpcy5jb2x1bW5zICogaik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbGxzIHRoZSBtYXRyaXggd2l0aCBhIGdpdmVuIHZhbHVlLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBOZXcgdmFsdWVcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaWxsKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBqLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBOZWdhdGVzIHRoZSBtYXRyaXguIEFsbCBlbGVtZW50cyB3aWxsIGJlIG11bHRpcGxpZWQgYnkgKC0xKVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG5lZygpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsUygtMSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IGZyb20gdGhlIGdpdmVuIHJvdyBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFJvdyBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGdldFJvdyhpbmRleCkge1xuXHQgICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4KTtcblx0ICAgICAgICAgICAgdmFyIHJvdyA9IG5ldyBBcnJheSh0aGlzLmNvbHVtbnMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICByb3dbaV0gPSB0aGlzLmdldChpbmRleCwgaSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJvdztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSBuZXcgcm93IHZlY3RvciBmcm9tIHRoZSBnaXZlbiByb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0Um93VmVjdG9yKGluZGV4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnJvd1ZlY3Rvcih0aGlzLmdldFJvdyhpbmRleCkpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU2V0cyBhIHJvdyBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gYXJyYXkgLSBBcnJheSBvciB2ZWN0b3Jcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzZXRSb3coaW5kZXgsIGFycmF5KSB7XG5cdCAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgpO1xuXHQgICAgICAgICAgICBhcnJheSA9IGNoZWNrUm93VmVjdG9yKHRoaXMsIGFycmF5KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXQoaW5kZXgsIGksIGFycmF5W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFN3YXBzIHR3byByb3dzXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdzEgLSBGaXJzdCByb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93MiAtIFNlY29uZCByb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzd2FwUm93cyhyb3cxLCByb3cyKSB7XG5cdCAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93MSk7XG5cdCAgICAgICAgICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93Mik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5nZXQocm93MSwgaSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChyb3cxLCBpLCB0aGlzLmdldChyb3cyLCBpKSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChyb3cyLCBpLCB0ZW1wKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgZnJvbSB0aGUgZ2l2ZW4gY29sdW1uIGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ29sdW1uIGluZGV4XG5cdCAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZ2V0Q29sdW1uKGluZGV4KSB7XG5cdCAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gbmV3IEFycmF5KHRoaXMucm93cyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGNvbHVtbltpXSA9IHRoaXMuZ2V0KGksIGluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gY29sdW1uO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIG5ldyBjb2x1bW4gdmVjdG9yIGZyb20gdGhlIGdpdmVuIGNvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBnZXRDb2x1bW5WZWN0b3IoaW5kZXgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKGluZGV4KSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXRzIGEgY29sdW1uIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSBhcnJheSAtIEFycmF5IG9yIHZlY3RvclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNldENvbHVtbihpbmRleCwgYXJyYXkpIHtcblx0ICAgICAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCk7XG5cdCAgICAgICAgICAgIGFycmF5ID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgYXJyYXkpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBpbmRleCwgYXJyYXlbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU3dhcHMgdHdvIGNvbHVtbnNcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uMSAtIEZpcnN0IGNvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4yIC0gU2Vjb25kIGNvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN3YXBDb2x1bW5zKGNvbHVtbjEsIGNvbHVtbjIpIHtcblx0ICAgICAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4xKTtcblx0ICAgICAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4yKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmdldChpLCBjb2x1bW4xKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGNvbHVtbjEsIHRoaXMuZ2V0KGksIGNvbHVtbjIpKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGNvbHVtbjIsIHRlbXApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIHRvIGVhY2ggcm93XG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZFJvd1ZlY3Rvcih2ZWN0b3IpIHtcblx0ICAgICAgICAgICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICsgdmVjdG9yW2pdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFN1YnRyYWN0cyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIGZyb20gZWFjaCByb3dcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yIC0gQXJyYXkgb3IgdmVjdG9yXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3ViUm93VmVjdG9yKHZlY3Rvcikge1xuXHQgICAgICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgLSB2ZWN0b3Jbal0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogTXVsdGlwbGllcyB0aGUgdmFsdWVzIG9mIGEgdmVjdG9yIHdpdGggZWFjaCByb3dcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fE1hdHJpeH0gdmVjdG9yIC0gQXJyYXkgb3IgdmVjdG9yXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbXVsUm93VmVjdG9yKHZlY3Rvcikge1xuXHQgICAgICAgICAgICB2ZWN0b3IgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCB2ZWN0b3IpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKiB2ZWN0b3Jbal0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGl2aWRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggcm93IGJ5IHRob3NlIG9mIGEgdmVjdG9yXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRpdlJvd1ZlY3Rvcih2ZWN0b3IpIHtcblx0ICAgICAgICAgICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC8gdmVjdG9yW2pdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciB0byBlYWNoIGNvbHVtblxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3Jcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBhZGRDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG5cdCAgICAgICAgICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSArIHZlY3RvcltpXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTdWJ0cmFjdHMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciBmcm9tIGVhY2ggY29sdW1uXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN1YkNvbHVtblZlY3Rvcih2ZWN0b3IpIHtcblx0ICAgICAgICAgICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC0gdmVjdG9yW2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIE11bHRpcGxpZXMgdGhlIHZhbHVlcyBvZiBhIHZlY3RvciB3aXRoIGVhY2ggY29sdW1uXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvciAtIEFycmF5IG9yIHZlY3RvclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG11bENvbHVtblZlY3Rvcih2ZWN0b3IpIHtcblx0ICAgICAgICAgICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICogdmVjdG9yW2ldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERpdmlkZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNvbHVtbiBieSB0aG9zZSBvZiBhIHZlY3RvclxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3IgLSBBcnJheSBvciB2ZWN0b3Jcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkaXZDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG5cdCAgICAgICAgICAgIHZlY3RvciA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIHZlY3Rvcik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAvIHZlY3RvcltpXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZXMgb2YgYSByb3cgd2l0aCBhIHNjYWxhclxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFJvdyBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG11bFJvdyhpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGluZGV4LCBpLCB0aGlzLmdldChpbmRleCwgaSkgKiB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBNdWx0aXBsaWVzIHRoZSB2YWx1ZXMgb2YgYSBjb2x1bW4gd2l0aCBhIHNjYWxhclxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG11bENvbHVtbihpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGluZGV4LCB0aGlzLmdldChpLCBpbmRleCkgKiB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBtYXRyaXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbWF4KCkge1xuXHQgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KDAsIDApO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopID4gdikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgaik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWVcblx0ICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBtYXhJbmRleCgpIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCAwKTtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IFswLCAwXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChpLCBqKSA+IHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGopO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZHhbMF0gPSBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZHhbMV0gPSBqO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gaWR4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgbWF0cml4XG5cdCAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG1pbigpIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCAwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChpLCBqKSA8IHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGopO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtaW5pbXVtIHZhbHVlXG5cdCAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbWluSW5kZXgoKSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgMCk7XG5cdCAgICAgICAgICAgIHZhciBpZHggPSBbMCwgMF07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPCB2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWR4WzBdID0gaTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWR4WzFdID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGlkeDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgb2Ygb25lIHJvd1xuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBSb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbWF4Um93KHJvdykge1xuXHQgICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdyk7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQocm93LCAwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgaSkgPiB2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHJvdywgaSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHY7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF4aW11bSB2YWx1ZSBvZiBvbmUgcm93XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFJvdyBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG1heFJvd0luZGV4KHJvdykge1xuXHQgICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdyk7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQocm93LCAwKTtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IFtyb3csIDBdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQocm93LCBpKSA+IHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQocm93LCBpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZHhbMV0gPSBpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBpZHg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mIG9uZSByb3dcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gUm93IGluZGV4XG5cdCAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG1pblJvdyhyb3cpIHtcblx0ICAgICAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuXHQgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KHJvdywgMCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChyb3csIGkpIDwgdikge1xuXHQgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdldChyb3csIGkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWUgb2Ygb25lIHJvd1xuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgLSBSb3cgaW5kZXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBtaW5Sb3dJbmRleChyb3cpIHtcblx0ICAgICAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuXHQgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0KHJvdywgMCk7XG5cdCAgICAgICAgICAgIHZhciBpZHggPSBbcm93LCAwXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgaSkgPCB2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KHJvdywgaSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWR4WzFdID0gaTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gaWR4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBvbmUgY29sdW1uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIENvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBtYXhDb2x1bW4oY29sdW1uKSB7XG5cdCAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcblx0ICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCBjb2x1bW4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA+IHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgY29sdW1uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIHZhbHVlIG9mIG9uZSBjb2x1bW5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gQ29sdW1uIGluZGV4XG5cdCAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbWF4Q29sdW1uSW5kZXgoY29sdW1uKSB7XG5cdCAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcblx0ICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldCgwLCBjb2x1bW4pO1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gWzAsIGNvbHVtbl07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChpLCBjb2x1bW4pID4gdikge1xuXHQgICAgICAgICAgICAgICAgICAgIHYgPSB0aGlzLmdldChpLCBjb2x1bW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIGlkeFswXSA9IGk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGlkeDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgb2Ygb25lIGNvbHVtblxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gaW5kZXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbWluQ29sdW1uKGNvbHVtbikge1xuXHQgICAgICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGNvbHVtbikgPCB2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHY7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWluaW11bSB2YWx1ZSBvZiBvbmUgY29sdW1uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiAtIENvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG1pbkNvbHVtbkluZGV4KGNvbHVtbikge1xuXHQgICAgICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IFswLCBjb2x1bW5dO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA8IHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2ID0gdGhpcy5nZXQoaSwgY29sdW1uKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZHhbMF0gPSBpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBpZHg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRpYWdvbmFsIHZhbHVlcyBvZiB0aGUgbWF0cml4XG5cdCAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGlhZygpIHtcblx0ICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcblx0ICAgICAgICAgICAgdmFyIGRpYWcgPSBuZXcgQXJyYXkobWluKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZGlhZ1tpXSA9IHRoaXMuZ2V0KGksIGkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBkaWFnO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgc3VtIGJ5IHRoZSBhcmd1bWVudCBnaXZlbiwgaWYgbm8gYXJndW1lbnQgZ2l2ZW4sXG5cdCAgICAgICAgICogaXQgcmV0dXJucyB0aGUgc3VtIG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBieSAtIHN1bSBieSAncm93JyBvciAnY29sdW1uJy5cblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh8bnVtYmVyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN1bShieSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGJ5KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdyb3cnOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW1CeVJvdyh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbHVtbic6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bUJ5Q29sdW1uKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtQWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZWFuIG9mIGFsbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4XG5cdCAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIG1lYW4oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnN1bSgpIC8gdGhpcy5zaXplO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBhbGwgZWxlbWVudHMgb2YgdGhlIG1hdHJpeFxuXHQgICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9kKCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvZCA9IDE7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9kICo9IHRoaXMuZ2V0KGksIGopO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9kO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgbm9ybSBvZiBhIG1hdHJpeC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFwiZnJvYmVuaXVzXCIgKGRlZmF1bHQpIG9yIFwibWF4XCIgcmV0dXJuIHJlc3AuIHRoZSBGcm9iZW5pdXMgbm9ybSBhbmQgdGhlIG1heCBub3JtLlxuXHQgICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBub3JtKHR5cGUgPSAnZnJvYmVuaXVzJykge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gMDtcblx0ICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtYXgnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXgoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnJvYmVuaXVzJykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGhpcy5nZXQoaSwgaikgKiB0aGlzLmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdW5rbm93biBub3JtIHR5cGU6ICR7dHlwZX1gKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29tcHV0ZXMgdGhlIGN1bXVsYXRpdmUgc3VtIG9mIHRoZSBtYXRyaXggZWxlbWVudHMgKGluIHBsYWNlLCByb3cgYnkgcm93KVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGN1bXVsYXRpdmVTdW0oKSB7XG5cdCAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VtICs9IHRoaXMuZ2V0KGksIGopO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHN1bSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb21wdXRlcyB0aGUgZG90IChzY2FsYXIpIHByb2R1Y3QgYmV0d2VlbiB0aGUgbWF0cml4IGFuZCBhbm90aGVyXG5cdCAgICAgICAgICogQHBhcmFtIHtNYXRyaXh9IHZlY3RvcjIgdmVjdG9yXG5cdCAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRvdCh2ZWN0b3IyKSB7XG5cdCAgICAgICAgICAgIGlmIChNYXRyaXguaXNNYXRyaXgodmVjdG9yMikpIHZlY3RvcjIgPSB2ZWN0b3IyLnRvMURBcnJheSgpO1xuXHQgICAgICAgICAgICB2YXIgdmVjdG9yMSA9IHRoaXMudG8xREFycmF5KCk7XG5cdCAgICAgICAgICAgIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2ZWN0b3JzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHNpemUnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZG90ID0gMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZWN0b3IxLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBkb3QgKz0gdmVjdG9yMVtpXSAqIHZlY3RvcjJbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGRvdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgdGhlIG1hdHJpeCBwcm9kdWN0IGJldHdlZW4gdGhpcyBhbmQgb3RoZXJcblx0ICAgICAgICAgKiBAcGFyYW0ge01hdHJpeH0gb3RoZXJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgbW11bChvdGhlcikge1xuXHQgICAgICAgICAgICBvdGhlciA9IHRoaXMuY29uc3RydWN0b3IuY2hlY2tNYXRyaXgob3RoZXIpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5zICE9PSBvdGhlci5yb3dzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdOdW1iZXIgb2YgY29sdW1ucyBvZiBsZWZ0IG1hdHJpeCBhcmUgbm90IGVxdWFsIHRvIG51bWJlciBvZiByb3dzIG9mIHJpZ2h0IG1hdHJpeC4nKTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnJvd3M7XG5cdCAgICAgICAgICAgIHZhciBuID0gdGhpcy5jb2x1bW5zO1xuXHQgICAgICAgICAgICB2YXIgcCA9IG90aGVyLmNvbHVtbnM7XG5cdFxuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKG0sIHApO1xuXHRcblx0ICAgICAgICAgICAgdmFyIEJjb2xqID0gbmV3IEFycmF5KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHA7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBCY29saltrXSA9IG90aGVyLmdldChrLCBqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbjsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gdGhpcy5nZXQoaSwgaykgKiBCY29saltrXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHN0cmFzc2VuMngyKG90aGVyKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10oMiwgMik7XG5cdCAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZ2V0KDAsIDApO1xuXHQgICAgICAgICAgICBjb25zdCBiMTEgPSBvdGhlci5nZXQoMCwgMCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMuZ2V0KDAsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBiMTIgPSBvdGhlci5nZXQoMCwgMSk7XG5cdCAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZ2V0KDEsIDApO1xuXHQgICAgICAgICAgICBjb25zdCBiMjEgPSBvdGhlci5nZXQoMSwgMCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZ2V0KDEsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBiMjIgPSBvdGhlci5nZXQoMSwgMSk7XG5cdFxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludGVybWVkaWF0ZSB2YWx1ZXMuXG5cdCAgICAgICAgICAgIGNvbnN0IG0xID0gKGExMSArIGEyMikgKiAoYjExICsgYjIyKTtcblx0ICAgICAgICAgICAgY29uc3QgbTIgPSAoYTIxICsgYTIyKSAqIGIxMTtcblx0ICAgICAgICAgICAgY29uc3QgbTMgPSBhMTEgKiAoYjEyIC0gYjIyKTtcblx0ICAgICAgICAgICAgY29uc3QgbTQgPSBhMjIgKiAoYjIxIC0gYjExKTtcblx0ICAgICAgICAgICAgY29uc3QgbTUgPSAoYTExICsgYTEyKSAqIGIyMjtcblx0ICAgICAgICAgICAgY29uc3QgbTYgPSAoYTIxIC0gYTExKSAqIChiMTEgKyBiMTIpO1xuXHQgICAgICAgICAgICBjb25zdCBtNyA9IChhMTIgLSBhMjIpICogKGIyMSArIGIyMik7XG5cdFxuXHQgICAgICAgICAgICAvLyBDb21iaW5lIGludGVybWVkaWF0ZSB2YWx1ZXMgaW50byB0aGUgb3V0cHV0LlxuXHQgICAgICAgICAgICBjb25zdCBjMDAgPSBtMSArIG00IC0gbTUgKyBtNztcblx0ICAgICAgICAgICAgY29uc3QgYzAxID0gbTMgKyBtNTtcblx0ICAgICAgICAgICAgY29uc3QgYzEwID0gbTIgKyBtNDtcblx0ICAgICAgICAgICAgY29uc3QgYzExID0gbTEgLSBtMiArIG0zICsgbTY7XG5cdFxuXHQgICAgICAgICAgICByZXN1bHQuc2V0KDAsIDAsIGMwMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zZXQoMCwgMSwgYzAxKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnNldCgxLCAwLCBjMTApO1xuXHQgICAgICAgICAgICByZXN1bHQuc2V0KDEsIDEsIGMxMSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBzdHJhc3NlbjN4MyhvdGhlcikge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMuY29uc3RydWN0b3JbU3ltYm9sLnNwZWNpZXNdKDMsIDMpO1xuXHRcblx0ICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5nZXQoMCwgMCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMuZ2V0KDAsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLmdldCgwLCAyKTtcblx0ICAgICAgICAgICAgY29uc3QgYTEwID0gdGhpcy5nZXQoMSwgMCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZ2V0KDEsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmdldCgxLCAyKTtcblx0ICAgICAgICAgICAgY29uc3QgYTIwID0gdGhpcy5nZXQoMiwgMCk7XG5cdCAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZ2V0KDIsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBhMjIgPSB0aGlzLmdldCgyLCAyKTtcblx0XG5cdCAgICAgICAgICAgIGNvbnN0IGIwMCA9IG90aGVyLmdldCgwLCAwKTtcblx0ICAgICAgICAgICAgY29uc3QgYjAxID0gb3RoZXIuZ2V0KDAsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBiMDIgPSBvdGhlci5nZXQoMCwgMik7XG5cdCAgICAgICAgICAgIGNvbnN0IGIxMCA9IG90aGVyLmdldCgxLCAwKTtcblx0ICAgICAgICAgICAgY29uc3QgYjExID0gb3RoZXIuZ2V0KDEsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBiMTIgPSBvdGhlci5nZXQoMSwgMik7XG5cdCAgICAgICAgICAgIGNvbnN0IGIyMCA9IG90aGVyLmdldCgyLCAwKTtcblx0ICAgICAgICAgICAgY29uc3QgYjIxID0gb3RoZXIuZ2V0KDIsIDEpO1xuXHQgICAgICAgICAgICBjb25zdCBiMjIgPSBvdGhlci5nZXQoMiwgMik7XG5cdFxuXHQgICAgICAgICAgICBjb25zdCBtMSA9IChhMDAgKyBhMDEgKyBhMDIgLSBhMTAgLSBhMTEgLSBhMjEgLSBhMjIpICogYjExO1xuXHQgICAgICAgICAgICBjb25zdCBtMiA9IChhMDAgLSBhMTApICogKC1iMDEgKyBiMTEpO1xuXHQgICAgICAgICAgICBjb25zdCBtMyA9IGExMSAqICgtYjAwICsgYjAxICsgYjEwIC0gYjExIC0gYjEyIC0gYjIwICsgYjIyKTtcblx0ICAgICAgICAgICAgY29uc3QgbTQgPSAoLWEwMCArIGExMCArIGExMSkgKiAoYjAwIC0gYjAxICsgYjExKTtcblx0ICAgICAgICAgICAgY29uc3QgbTUgPSAoYTEwICsgYTExKSAqICgtYjAwICsgYjAxKTtcblx0ICAgICAgICAgICAgY29uc3QgbTYgPSBhMDAgKiBiMDA7XG5cdCAgICAgICAgICAgIGNvbnN0IG03ID0gKC1hMDAgKyBhMjAgKyBhMjEpICogKGIwMCAtIGIwMiArIGIxMik7XG5cdCAgICAgICAgICAgIGNvbnN0IG04ID0gKC1hMDAgKyBhMjApICogKGIwMiAtIGIxMik7XG5cdCAgICAgICAgICAgIGNvbnN0IG05ID0gKGEyMCArIGEyMSkgKiAoLWIwMCArIGIwMik7XG5cdCAgICAgICAgICAgIGNvbnN0IG0xMCA9IChhMDAgKyBhMDEgKyBhMDIgLSBhMTEgLSBhMTIgLSBhMjAgLSBhMjEpICogYjEyO1xuXHQgICAgICAgICAgICBjb25zdCBtMTEgPSBhMjEgKiAoLWIwMCArIGIwMiArIGIxMCAtIGIxMSAtIGIxMiAtIGIyMCArIGIyMSk7XG5cdCAgICAgICAgICAgIGNvbnN0IG0xMiA9ICgtYTAyICsgYTIxICsgYTIyKSAqIChiMTEgKyBiMjAgLSBiMjEpO1xuXHQgICAgICAgICAgICBjb25zdCBtMTMgPSAoYTAyIC0gYTIyKSAqIChiMTEgLSBiMjEpO1xuXHQgICAgICAgICAgICBjb25zdCBtMTQgPSBhMDIgKiBiMjA7XG5cdCAgICAgICAgICAgIGNvbnN0IG0xNSA9IChhMjEgKyBhMjIpICogKC1iMjAgKyBiMjEpO1xuXHQgICAgICAgICAgICBjb25zdCBtMTYgPSAoLWEwMiArIGExMSArIGExMikgKiAoYjEyICsgYjIwIC0gYjIyKTtcblx0ICAgICAgICAgICAgY29uc3QgbTE3ID0gKGEwMiAtIGExMikgKiAoYjEyIC0gYjIyKTtcblx0ICAgICAgICAgICAgY29uc3QgbTE4ID0gKGExMSArIGExMikgKiAoLWIyMCArIGIyMik7XG5cdCAgICAgICAgICAgIGNvbnN0IG0xOSA9IGEwMSAqIGIxMDtcblx0ICAgICAgICAgICAgY29uc3QgbTIwID0gYTEyICogYjIxO1xuXHQgICAgICAgICAgICBjb25zdCBtMjEgPSBhMTAgKiBiMDI7XG5cdCAgICAgICAgICAgIGNvbnN0IG0yMiA9IGEyMCAqIGIwMTtcblx0ICAgICAgICAgICAgY29uc3QgbTIzID0gYTIyICogYjIyO1xuXHRcblx0ICAgICAgICAgICAgY29uc3QgYzAwID0gbTYgKyBtMTQgKyBtMTk7XG5cdCAgICAgICAgICAgIGNvbnN0IGMwMSA9IG0xICsgbTQgKyBtNSArIG02ICsgbTEyICsgbTE0ICsgbTE1O1xuXHQgICAgICAgICAgICBjb25zdCBjMDIgPSBtNiArIG03ICsgbTkgKyBtMTAgKyBtMTQgKyBtMTYgKyBtMTg7XG5cdCAgICAgICAgICAgIGNvbnN0IGMxMCA9IG0yICsgbTMgKyBtNCArIG02ICsgbTE0ICsgbTE2ICsgbTE3O1xuXHQgICAgICAgICAgICBjb25zdCBjMTEgPSBtMiArIG00ICsgbTUgKyBtNiArIG0yMDtcblx0ICAgICAgICAgICAgY29uc3QgYzEyID0gbTE0ICsgbTE2ICsgbTE3ICsgbTE4ICsgbTIxO1xuXHQgICAgICAgICAgICBjb25zdCBjMjAgPSBtNiArIG03ICsgbTggKyBtMTEgKyBtMTIgKyBtMTMgKyBtMTQ7XG5cdCAgICAgICAgICAgIGNvbnN0IGMyMSA9IG0xMiArIG0xMyArIG0xNCArIG0xNSArIG0yMjtcblx0ICAgICAgICAgICAgY29uc3QgYzIyID0gbTYgKyBtNyArIG04ICsgbTkgKyBtMjM7XG5cdFxuXHQgICAgICAgICAgICByZXN1bHQuc2V0KDAsIDAsIGMwMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zZXQoMCwgMSwgYzAxKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnNldCgwLCAyLCBjMDIpO1xuXHQgICAgICAgICAgICByZXN1bHQuc2V0KDEsIDAsIGMxMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zZXQoMSwgMSwgYzExKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnNldCgxLCAyLCBjMTIpO1xuXHQgICAgICAgICAgICByZXN1bHQuc2V0KDIsIDAsIGMyMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5zZXQoMiwgMSwgYzIxKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnNldCgyLCAyLCBjMjIpO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyB0aGUgbWF0cml4IHByb2R1Y3QgYmV0d2VlbiB4IGFuZCB5LiBNb3JlIGVmZmljaWVudCB0aGFuIG1tdWwob3RoZXIpIG9ubHkgd2hlbiB3ZSBtdWx0aXBseSBzcXVhcmVkIG1hdHJpeCBhbmQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgbWF0cml4IGlzID4gMTAwMC5cblx0ICAgICAgICAgKiBAcGFyYW0ge01hdHJpeH0geVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBtbXVsU3RyYXNzZW4oeSkge1xuXHQgICAgICAgICAgICB2YXIgeCA9IHRoaXMuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFyIHIxID0geC5yb3dzO1xuXHQgICAgICAgICAgICB2YXIgYzEgPSB4LmNvbHVtbnM7XG5cdCAgICAgICAgICAgIHZhciByMiA9IHkucm93cztcblx0ICAgICAgICAgICAgdmFyIGMyID0geS5jb2x1bW5zO1xuXHQgICAgICAgICAgICBpZiAoYzEgIT09IHIyKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBNdWx0aXBseWluZyAke3IxfSB4ICR7YzF9IGFuZCAke3IyfSB4ICR7YzJ9IG1hdHJpeDogZGltZW5zaW9ucyBkbyBub3QgbWF0Y2guYCk7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIC8vIFB1dCBhIG1hdHJpeCBpbnRvIHRoZSB0b3AgbGVmdCBvZiBhIG1hdHJpeCBvZiB6ZXJvcy5cblx0ICAgICAgICAgICAgLy8gYHJvd3NgIGFuZCBgY29sc2AgYXJlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQgbWF0cml4LlxuXHQgICAgICAgICAgICBmdW5jdGlvbiBlbWJlZChtYXQsIHJvd3MsIGNvbHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByID0gbWF0LnJvd3M7XG5cdCAgICAgICAgICAgICAgICB2YXIgYyA9IG1hdC5jb2x1bW5zO1xuXHQgICAgICAgICAgICAgICAgaWYgKChyID09PSByb3dzKSAmJiAoYyA9PT0gY29scykpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0YXQgPSBNYXRyaXguemVyb3Mocm93cywgY29scyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0YXQgPSByZXN1bHRhdC5zZXRTdWJNYXRyaXgobWF0LCAwLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0YXQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0XG5cdFxuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYm90aCBtYXRyaWNlcyBhcmUgdGhlIHNhbWUgc2l6ZS5cblx0ICAgICAgICAgICAgLy8gVGhpcyBpcyBleGNsdXNpdmVseSBmb3Igc2ltcGxpY2l0eTpcblx0ICAgICAgICAgICAgLy8gdGhpcyBhbGdvcml0aG0gY2FuIGJlIGltcGxlbWVudGVkIHdpdGggbWF0cmljZXMgb2YgZGlmZmVyZW50IHNpemVzLlxuXHRcblx0ICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChyMSwgcjIpO1xuXHQgICAgICAgICAgICB2YXIgYyA9IE1hdGgubWF4KGMxLCBjMik7XG5cdCAgICAgICAgICAgIHggPSBlbWJlZCh4LCByLCBjKTtcblx0ICAgICAgICAgICAgeSA9IGVtYmVkKHksIHIsIGMpO1xuXHRcblx0ICAgICAgICAgICAgLy8gT3VyIHJlY3Vyc2l2ZSBtdWx0aXBsaWNhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgICAgZnVuY3Rpb24gYmxvY2tNdWx0KGEsIGIsIHJvd3MsIGNvbHMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEZvciBzbWFsbCBtYXRyaWNlcywgcmVzb3J0IHRvIG5haXZlIG11bHRpcGxpY2F0aW9uLlxuXHQgICAgICAgICAgICAgICAgaWYgKHJvd3MgPD0gNTEyIHx8IGNvbHMgPD0gNTEyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubW11bChiKTsgLy8gYSBpcyBlcXVpdmFsZW50IHRvIHRoaXNcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAvLyBBcHBseSBkeW5hbWljIHBhZGRpbmcuXG5cdCAgICAgICAgICAgICAgICBpZiAoKHJvd3MgJSAyID09PSAxKSAmJiAoY29scyAlIDIgPT09IDEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9IGVtYmVkKGEsIHJvd3MgKyAxLCBjb2xzICsgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IGVtYmVkKGIsIHJvd3MgKyAxLCBjb2xzICsgMSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgJSAyID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9IGVtYmVkKGEsIHJvd3MgKyAxLCBjb2xzKTtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gZW1iZWQoYiwgcm93cyArIDEsIGNvbHMpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xzICUgMiA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGEgPSBlbWJlZChhLCByb3dzLCBjb2xzICsgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IGVtYmVkKGIsIHJvd3MsIGNvbHMgKyAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICB2YXIgaGFsZlJvd3MgPSBwYXJzZUludChhLnJvd3MgLyAyKTtcblx0ICAgICAgICAgICAgICAgIHZhciBoYWxmQ29scyA9IHBhcnNlSW50KGEuY29sdW1ucyAvIDIpO1xuXHQgICAgICAgICAgICAgICAgLy8gU3ViZGl2aWRlIGlucHV0IG1hdHJpY2VzLlxuXHQgICAgICAgICAgICAgICAgdmFyIGExMSA9IGEuc3ViTWF0cml4KDAsIGhhbGZSb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcblx0ICAgICAgICAgICAgICAgIHZhciBiMTEgPSBiLnN1Yk1hdHJpeCgwLCBoYWxmUm93cyAtIDEsIDAsIGhhbGZDb2xzIC0gMSk7XG5cdFxuXHQgICAgICAgICAgICAgICAgdmFyIGExMiA9IGEuc3ViTWF0cml4KDAsIGhhbGZSb3dzIC0gMSwgaGFsZkNvbHMsIGEuY29sdW1ucyAtIDEpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGIxMiA9IGIuc3ViTWF0cml4KDAsIGhhbGZSb3dzIC0gMSwgaGFsZkNvbHMsIGIuY29sdW1ucyAtIDEpO1xuXHRcblx0ICAgICAgICAgICAgICAgIHZhciBhMjEgPSBhLnN1Yk1hdHJpeChoYWxmUm93cywgYS5yb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcblx0ICAgICAgICAgICAgICAgIHZhciBiMjEgPSBiLnN1Yk1hdHJpeChoYWxmUm93cywgYi5yb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcblx0XG5cdCAgICAgICAgICAgICAgICB2YXIgYTIyID0gYS5zdWJNYXRyaXgoaGFsZlJvd3MsIGEucm93cyAtIDEsIGhhbGZDb2xzLCBhLmNvbHVtbnMgLSAxKTtcblx0ICAgICAgICAgICAgICAgIHZhciBiMjIgPSBiLnN1Yk1hdHJpeChoYWxmUm93cywgYi5yb3dzIC0gMSwgaGFsZkNvbHMsIGIuY29sdW1ucyAtIDEpO1xuXHRcblx0ICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaW50ZXJtZWRpYXRlIHZhbHVlcy5cblx0ICAgICAgICAgICAgICAgIHZhciBtMSA9IGJsb2NrTXVsdChNYXRyaXguYWRkKGExMSwgYTIyKSwgTWF0cml4LmFkZChiMTEsIGIyMiksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbTIgPSBibG9ja011bHQoTWF0cml4LmFkZChhMjEsIGEyMiksIGIxMSwgaGFsZlJvd3MsIGhhbGZDb2xzKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtMyA9IGJsb2NrTXVsdChhMTEsIE1hdHJpeC5zdWIoYjEyLCBiMjIpLCBoYWxmUm93cywgaGFsZkNvbHMpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG00ID0gYmxvY2tNdWx0KGEyMiwgTWF0cml4LnN1YihiMjEsIGIxMSksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbTUgPSBibG9ja011bHQoTWF0cml4LmFkZChhMTEsIGExMiksIGIyMiwgaGFsZlJvd3MsIGhhbGZDb2xzKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtNiA9IGJsb2NrTXVsdChNYXRyaXguc3ViKGEyMSwgYTExKSwgTWF0cml4LmFkZChiMTEsIGIxMiksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbTcgPSBibG9ja011bHQoTWF0cml4LnN1YihhMTIsIGEyMiksIE1hdHJpeC5hZGQoYjIxLCBiMjIpLCBoYWxmUm93cywgaGFsZkNvbHMpO1xuXHRcblx0ICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgaW50ZXJtZWRpYXRlIHZhbHVlcyBpbnRvIHRoZSBvdXRwdXQuXG5cdCAgICAgICAgICAgICAgICB2YXIgYzExID0gTWF0cml4LmFkZChtMSwgbTQpO1xuXHQgICAgICAgICAgICAgICAgYzExLnN1YihtNSk7XG5cdCAgICAgICAgICAgICAgICBjMTEuYWRkKG03KTtcblx0ICAgICAgICAgICAgICAgIHZhciBjMTIgPSBNYXRyaXguYWRkKG0zLCBtNSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgYzIxID0gTWF0cml4LmFkZChtMiwgbTQpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGMyMiA9IE1hdHJpeC5zdWIobTEsIG0yKTtcblx0ICAgICAgICAgICAgICAgIGMyMi5hZGQobTMpO1xuXHQgICAgICAgICAgICAgICAgYzIyLmFkZChtNik7XG5cdFxuXHQgICAgICAgICAgICAgICAgLy9Dcm9wIG91dHB1dCB0byB0aGUgZGVzaXJlZCBzaXplICh1bmRvIGR5bmFtaWMgcGFkZGluZykuXG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0YXQgPSBNYXRyaXguemVyb3MoMiAqIGMxMS5yb3dzLCAyICogYzExLmNvbHVtbnMpO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0YXQgPSByZXN1bHRhdC5zZXRTdWJNYXRyaXgoYzExLCAwLCAwKTtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdGF0ID0gcmVzdWx0YXQuc2V0U3ViTWF0cml4KGMxMiwgYzExLnJvd3MsIDApO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0YXQgPSByZXN1bHRhdC5zZXRTdWJNYXRyaXgoYzIxLCAwLCBjMTEuY29sdW1ucyk7XG5cdCAgICAgICAgICAgICAgICByZXN1bHRhdCA9IHJlc3VsdGF0LnNldFN1Yk1hdHJpeChjMjIsIGMxMS5yb3dzLCBjMTEuY29sdW1ucyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0YXQuc3ViTWF0cml4KDAsIHJvd3MgLSAxLCAwLCBjb2xzIC0gMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJsb2NrTXVsdCh4LCB5LCByLCBjKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSByb3ctYnktcm93IHNjYWxlZCBtYXRyaXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSAtIE1pbmltdW0gc2NhbGVkIHZhbHVlXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gLSBNYXhpbXVtIHNjYWxlZCB2YWx1ZVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgc2NhbGVkIG1hdHJpeFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNjYWxlUm93cyhtaW4sIG1heCkge1xuXHQgICAgICAgICAgICBtaW4gPSBtaW4gPT09IHVuZGVmaW5lZCA/IDAgOiBtaW47XG5cdCAgICAgICAgICAgIG1heCA9IG1heCA9PT0gdW5kZWZpbmVkID8gMSA6IG1heDtcblx0ICAgICAgICAgICAgaWYgKG1pbiA+PSBtYXgpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtaW4gc2hvdWxkIGJlIHN0cmljdGx5IHNtYWxsZXIgdGhhbiBtYXgnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgbmV3TWF0cml4ID0gdGhpcy5jb25zdHJ1Y3Rvci5lbXB0eSh0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzY2FsZWQgPSByZXNjYWxlKHRoaXMuZ2V0Um93KGkpLCB7bWluLCBtYXh9KTtcblx0ICAgICAgICAgICAgICAgIG5ld01hdHJpeC5zZXRSb3coaSwgc2NhbGVkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIG5ldyBjb2x1bW4tYnktY29sdW1uIHNjYWxlZCBtYXRyaXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSAtIE1pbmltdW0gc2NhbGVkIHZhbHVlXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gLSBNYXhpbXVtIHNjYWxlZCB2YWx1ZVxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgbmV3IHNjYWxlZCBtYXRyaXhcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KFtbMSwyXSxbLTEsMF1dKTtcblx0ICAgICAgICAgKiB2YXIgc2NhbGVkTWF0cml4ID0gbWF0cml4LnNjYWxlQ29sdW1ucygpOyAvLyBbWzEsMV0sWzAsMF1dXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc2NhbGVDb2x1bW5zKG1pbiwgbWF4KSB7XG5cdCAgICAgICAgICAgIG1pbiA9IG1pbiA9PT0gdW5kZWZpbmVkID8gMCA6IG1pbjtcblx0ICAgICAgICAgICAgbWF4ID0gbWF4ID09PSB1bmRlZmluZWQgPyAxIDogbWF4O1xuXHQgICAgICAgICAgICBpZiAobWluID49IG1heCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBzaG91bGQgYmUgc3RyaWN0bHkgc21hbGxlciB0aGFuIG1heCcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSB0aGlzLmNvbnN0cnVjdG9yLmVtcHR5KHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNjYWxlZCA9IHJlc2NhbGUodGhpcy5nZXRDb2x1bW4oaSksIHtcblx0ICAgICAgICAgICAgICAgICAgICBtaW46IG1pbixcblx0ICAgICAgICAgICAgICAgICAgICBtYXg6IG1heFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBuZXdNYXRyaXguc2V0Q29sdW1uKGksIHNjYWxlZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG5ld01hdHJpeDtcblx0ICAgICAgICB9XG5cdFxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSBLcm9uZWNrZXIgcHJvZHVjdCAoYWxzbyBrbm93biBhcyB0ZW5zb3IgcHJvZHVjdCkgYmV0d2VlbiB0aGlzIGFuZCBvdGhlclxuXHQgICAgICAgICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Lcm9uZWNrZXJfcHJvZHVjdFxuXHQgICAgICAgICAqIEBwYXJhbSB7TWF0cml4fSBvdGhlclxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBrcm9uZWNrZXJQcm9kdWN0KG90aGVyKSB7XG5cdCAgICAgICAgICAgIG90aGVyID0gdGhpcy5jb25zdHJ1Y3Rvci5jaGVja01hdHJpeChvdGhlcik7XG5cdFxuXHQgICAgICAgICAgICB2YXIgbSA9IHRoaXMucm93cztcblx0ICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmNvbHVtbnM7XG5cdCAgICAgICAgICAgIHZhciBwID0gb3RoZXIucm93cztcblx0ICAgICAgICAgICAgdmFyIHEgPSBvdGhlci5jb2x1bW5zO1xuXHRcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShtICogcCwgbiAqIHEpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHA7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHE7IGwrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3AgKiBpICsga11bcSAqIGogKyBsXSA9IHRoaXMuZ2V0KGksIGopICogb3RoZXIuZ2V0KGssIGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBUcmFuc3Bvc2VzIHRoZSBtYXRyaXggYW5kIHJldHVybnMgYSBuZXcgb25lIGNvbnRhaW5pbmcgdGhlIHJlc3VsdFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0cmFuc3Bvc2UoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10odGhpcy5jb2x1bW5zLCB0aGlzLnJvd3MpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChqLCBpLCB0aGlzLmdldChpLCBqKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNvcnRzIHRoZSByb3dzIChpbiBwbGFjZSlcblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlRnVuY3Rpb24gLSB1c3VhbCBBcnJheS5wcm90b3R5cGUuc29ydCBjb21wYXJpc29uIGZ1bmN0aW9uXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc29ydFJvd3MoY29tcGFyZUZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkgY29tcGFyZUZ1bmN0aW9uID0gY29tcGFyZU51bWJlcnM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0Um93KGksIHRoaXMuZ2V0Um93KGkpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTb3J0cyB0aGUgY29sdW1ucyAoaW4gcGxhY2UpXG5cdCAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyZUZ1bmN0aW9uIC0gdXN1YWwgQXJyYXkucHJvdG90eXBlLnNvcnQgY29tcGFyaXNvbiBmdW5jdGlvblxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNvcnRDb2x1bW5zKGNvbXBhcmVGdW5jdGlvbikge1xuXHQgICAgICAgICAgICBpZiAoY29tcGFyZUZ1bmN0aW9uID09PSB1bmRlZmluZWQpIGNvbXBhcmVGdW5jdGlvbiA9IGNvbXBhcmVOdW1iZXJzO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldENvbHVtbihpLCB0aGlzLmdldENvbHVtbihpKS5zb3J0KGNvbXBhcmVGdW5jdGlvbikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgbWF0cml4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IC0gRmlyc3Qgcm93IGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFJvdyAtIExhc3Qgcm93IGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gRmlyc3QgY29sdW1uIGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZENvbHVtbiAtIExhc3QgY29sdW1uIGluZGV4XG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN1Yk1hdHJpeChzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG5cdCAgICAgICAgICAgIGNoZWNrUmFuZ2UodGhpcywgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG5cdCAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10oZW5kUm93IC0gc3RhcnRSb3cgKyAxLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3c7IGkgPD0gZW5kUm93OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydENvbHVtbjsgaiA8PSBlbmRDb2x1bW47IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5ld01hdHJpeFtpIC0gc3RhcnRSb3ddW2ogLSBzdGFydENvbHVtbl0gPSB0aGlzLmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgbWF0cml4IGJhc2VkIG9uIGFuIGFycmF5IG9mIHJvdyBpbmRpY2VzXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyAtIEFycmF5IGNvbnRhaW5pbmcgdGhlIHJvdyBpbmRpY2VzXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydENvbHVtbiA9IDBdIC0gRmlyc3QgY29sdW1uIGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRDb2x1bW4gPSB0aGlzLmNvbHVtbnMtMV0gLSBMYXN0IGNvbHVtbiBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdWJNYXRyaXhSb3coaW5kaWNlcywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuXHQgICAgICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPT09IHVuZGVmaW5lZCkgc3RhcnRDb2x1bW4gPSAwO1xuXHQgICAgICAgICAgICBpZiAoZW5kQ29sdW1uID09PSB1bmRlZmluZWQpIGVuZENvbHVtbiA9IHRoaXMuY29sdW1ucyAtIDE7XG5cdCAgICAgICAgICAgIGlmICgoc3RhcnRDb2x1bW4gPiBlbmRDb2x1bW4pIHx8IChzdGFydENvbHVtbiA8IDApIHx8IChzdGFydENvbHVtbiA+PSB0aGlzLmNvbHVtbnMpIHx8IChlbmRDb2x1bW4gPCAwKSB8fCAoZW5kQ29sdW1uID49IHRoaXMuY29sdW1ucykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShpbmRpY2VzLmxlbmd0aCwgZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRDb2x1bW47IGogPD0gZW5kQ29sdW1uOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5kaWNlc1tpXSA8IDAgfHwgaW5kaWNlc1tpXSA+PSB0aGlzLnJvd3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JvdyBpbmRleCBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRpY2VzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbmV3TWF0cml4LnNldChpLCBqIC0gc3RhcnRDb2x1bW4sIHRoaXMuZ2V0KGluZGljZXNbaV0sIGopKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIHN1YnNldCBvZiB0aGUgbWF0cml4IGJhc2VkIG9uIGFuIGFycmF5IG9mIGNvbHVtbiBpbmRpY2VzXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyAtIEFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbHVtbiBpbmRpY2VzXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydFJvdyA9IDBdIC0gRmlyc3Qgcm93IGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRSb3cgPSB0aGlzLnJvd3MtMV0gLSBMYXN0IHJvdyBpbmRleFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdWJNYXRyaXhDb2x1bW4oaW5kaWNlcywgc3RhcnRSb3csIGVuZFJvdykge1xuXHQgICAgICAgICAgICBpZiAoc3RhcnRSb3cgPT09IHVuZGVmaW5lZCkgc3RhcnRSb3cgPSAwO1xuXHQgICAgICAgICAgICBpZiAoZW5kUm93ID09PSB1bmRlZmluZWQpIGVuZFJvdyA9IHRoaXMucm93cyAtIDE7XG5cdCAgICAgICAgICAgIGlmICgoc3RhcnRSb3cgPiBlbmRSb3cpIHx8IChzdGFydFJvdyA8IDApIHx8IChzdGFydFJvdyA+PSB0aGlzLnJvd3MpIHx8IChlbmRSb3cgPCAwKSB8fCAoZW5kUm93ID49IHRoaXMucm93cykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShlbmRSb3cgLSBzdGFydFJvdyArIDEsIGluZGljZXMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnRSb3c7IGogPD0gZW5kUm93OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5kaWNlc1tpXSA8IDAgfHwgaW5kaWNlc1tpXSA+PSB0aGlzLmNvbHVtbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRpY2VzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbmV3TWF0cml4LnNldChqIC0gc3RhcnRSb3csIGksIHRoaXMuZ2V0KGosIGluZGljZXNbaV0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3TWF0cml4O1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU2V0IGEgcGFydCBvZiB0aGUgbWF0cml4IHRvIHRoZSBnaXZlbiBzdWItbWF0cml4XG5cdCAgICAgICAgICogQHBhcmFtIHtNYXRyaXh8QXJyYXk8IEFycmF5ID59IG1hdHJpeCAtIFRoZSBzb3VyY2UgbWF0cml4IGZyb20gd2hpY2ggdG8gZXh0cmFjdCB2YWx1ZXMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCByb3cgdG8gc2V0XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjb2x1bW4gdG8gc2V0XG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNldFN1Yk1hdHJpeChtYXRyaXgsIHN0YXJ0Um93LCBzdGFydENvbHVtbikge1xuXHQgICAgICAgICAgICBtYXRyaXggPSB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrTWF0cml4KG1hdHJpeCk7XG5cdCAgICAgICAgICAgIHZhciBlbmRSb3cgPSBzdGFydFJvdyArIG1hdHJpeC5yb3dzIC0gMTtcblx0ICAgICAgICAgICAgdmFyIGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uICsgbWF0cml4LmNvbHVtbnMgLSAxO1xuXHQgICAgICAgICAgICBjaGVja1JhbmdlKHRoaXMsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNbc3RhcnRSb3cgKyBpXVtzdGFydENvbHVtbiArIGpdID0gbWF0cml4LmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybiBhIG5ldyBtYXRyaXggYmFzZWQgb24gYSBzZWxlY3Rpb24gb2Ygcm93cyBhbmQgY29sdW1uc1xuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcm93SW5kaWNlcyAtIFRoZSByb3cgaW5kaWNlcyB0byBzZWxlY3QuIE9yZGVyIG1hdHRlcnMgYW5kIGFuIGluZGV4IGNhbiBiZSBtb3JlIHRoYW4gb25jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbHVtbkluZGljZXMgLSBUaGUgY29sdW1uIGluZGljZXMgdG8gc2VsZWN0LiBPcmRlciBtYXR0ZXJzIGFuZCBhbiBpbmRleCBjYW4gYmUgdXNlIG1vcmUgdGhhbiBvbmNlLlxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH0gVGhlIG5ldyBtYXRyaXhcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzZWxlY3Rpb24ocm93SW5kaWNlcywgY29sdW1uSW5kaWNlcykge1xuXHQgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGNoZWNrSW5kaWNlcyh0aGlzLCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKTtcblx0ICAgICAgICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXShyb3dJbmRpY2VzLmxlbmd0aCwgY29sdW1uSW5kaWNlcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMucm93Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcm93SW5kZXggPSBpbmRpY2VzLnJvd1tpXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5kaWNlcy5jb2x1bW4ubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBpbmRpY2VzLmNvbHVtbltqXTtcblx0ICAgICAgICAgICAgICAgICAgICBuZXdNYXRyaXhbaV1bal0gPSB0aGlzLmdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdNYXRyaXg7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIHRoZSB0cmFjZSBvZiB0aGUgbWF0cml4IChzdW0gb2YgdGhlIGRpYWdvbmFsIGVsZW1lbnRzKVxuXHQgICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0cmFjZSgpIHtcblx0ICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcblx0ICAgICAgICAgICAgdmFyIHRyYWNlID0gMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdHJhY2UgKz0gdGhpcy5nZXQoaSwgaSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRyYWNlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLypcblx0ICAgICAgICAgTWF0cml4IHZpZXdzXG5cdCAgICAgICAgICovXG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSB0cmFuc3Bvc2l0aW9uIG9mIHRoZSBtYXRyaXhcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhUcmFuc3Bvc2VWaWV3fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRyYW5zcG9zZVZpZXcoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4VHJhbnNwb3NlVmlldyh0aGlzKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSByb3cgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGluZGV4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIHJvdyBpbmRleCBvZiB0aGUgdmVjdG9yXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4Um93Vmlld31cblx0ICAgICAgICAgKi9cblx0ICAgICAgICByb3dWaWV3KHJvdykge1xuXHQgICAgICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4Um93Vmlldyh0aGlzLCByb3cpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV0dXJucyBhIHZpZXcgb2YgdGhlIGNvbHVtbiB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uIC0gY29sdW1uIGluZGV4IG9mIHRoZSB2ZWN0b3Jcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhDb2x1bW5WaWV3fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbHVtblZpZXcoY29sdW1uKSB7XG5cdCAgICAgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXhDb2x1bW5WaWV3KHRoaXMsIGNvbHVtbik7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgbWF0cml4IGZsaXBwZWQgaW4gdGhlIHJvdyBheGlzXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4RmxpcFJvd1ZpZXd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmxpcFJvd1ZpZXcoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4RmxpcFJvd1ZpZXcodGhpcyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiB0aGUgbWF0cml4IGZsaXBwZWQgaW4gdGhlIGNvbHVtbiBheGlzXG5cdCAgICAgICAgICogQHJldHVybiB7TWF0cml4RmxpcENvbHVtblZpZXd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmxpcENvbHVtblZpZXcoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4RmxpcENvbHVtblZpZXcodGhpcyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXR1cm5zIGEgdmlldyBvZiBhIHN1Ym1hdHJpeCBnaXZpbmcgdGhlIGluZGV4IGJvdW5kYXJpZXNcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRSb3cgLSBmaXJzdCByb3cgaW5kZXggb2YgdGhlIHN1Ym1hdHJpeFxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRSb3cgLSBsYXN0IHJvdyBpbmRleCBvZiB0aGUgc3VibWF0cml4XG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Q29sdW1uIC0gZmlyc3QgY29sdW1uIGluZGV4IG9mIHRoZSBzdWJtYXRyaXhcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQ29sdW1uIC0gbGFzdCBjb2x1bW4gaW5kZXggb2YgdGhlIHN1Ym1hdHJpeFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeFN1YlZpZXd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3ViTWF0cml4VmlldyhzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4U3ViVmlldyh0aGlzLCBzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSBjcm9zcyBvZiB0aGUgcm93IGluZGljZXMgYW5kIHRoZSBjb2x1bW4gaW5kaWNlc1xuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogLy8gcmVzdWx0aW5nIHZlY3RvciBpcyBbWzJdLCBbMl1dXG5cdCAgICAgICAgICogdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoW1sxLDIsM10sIFs0LDUsNl1dKS5zZWxlY3Rpb25WaWV3KFswLCAwXSwgWzFdKVxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcm93SW5kaWNlc1xuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29sdW1uSW5kaWNlc1xuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeFNlbGVjdGlvblZpZXd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc2VsZWN0aW9uVmlldyhyb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4U2VsZWN0aW9uVmlldyh0aGlzLCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSByb3cgaW5kaWNlc1xuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogLy8gcmVzdWx0aW5nIHZlY3RvciBpcyBbWzEsMiwzXSwgWzEsMiwzXV1cblx0ICAgICAgICAgKiB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeChbWzEsMiwzXSwgWzQsNSw2XV0pLnJvd1NlbGVjdGlvblZpZXcoWzAsIDBdKVxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcm93SW5kaWNlc1xuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeFJvd1NlbGVjdGlvblZpZXd9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcm93U2VsZWN0aW9uVmlldyhyb3dJbmRpY2VzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4Um93U2VsZWN0aW9uVmlldyh0aGlzLCByb3dJbmRpY2VzKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgYSB2aWV3IG9mIHRoZSBjb2x1bW4gaW5kaWNlc1xuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICogLy8gcmVzdWx0aW5nIHZlY3RvciBpcyBbWzIsIDJdLCBbNSwgNV1dXG5cdCAgICAgICAgICogdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoW1sxLDIsM10sIFs0LDUsNl1dKS5jb2x1bW5TZWxlY3Rpb25WaWV3KFsxLCAxXSlcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvbHVtbkluZGljZXNcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXhDb2x1bW5TZWxlY3Rpb25WaWV3fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbHVtblNlbGVjdGlvblZpZXcoY29sdW1uSW5kaWNlcykge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeENvbHVtblNlbGVjdGlvblZpZXcodGhpcywgY29sdW1uSW5kaWNlcyk7XG5cdCAgICAgICAgfVxuXHRcblx0XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeCBhcyBhIE51bWJlclxuXHQgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAqICAgbmV3IE1hdHJpeChbWzEsMiwzXSwgWzQsNSw2XV0pLmRldCgpXG5cdCAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgICAgKi9cblx0ICAgICAgICBkZXQoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzU3F1YXJlKCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1ucyA9PT0gMikge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIDIgeCAyIG1hdHJpeFxuXHQgICAgICAgICAgICAgICAgICAgIGEgPSB0aGlzLmdldCgwLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5nZXQoMCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuZ2V0KDEsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLmdldCgxLCAxKTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKiBkIC0gKGIgKiBjKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb2x1bW5zID09PSAzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gMyB4IDMgbWF0cml4XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN1Yk1hdHJpeDAsIHN1Yk1hdHJpeDEsIHN1Yk1hdHJpeDI7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViTWF0cml4MCA9IHRoaXMuc2VsZWN0aW9uVmlldyhbMSwgMl0sIFsxLCAyXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViTWF0cml4MSA9IHRoaXMuc2VsZWN0aW9uVmlldyhbMSwgMl0sIFswLCAyXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViTWF0cml4MiA9IHRoaXMuc2VsZWN0aW9uVmlldyhbMSwgMl0sIFswLCAxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuZ2V0KDAsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLmdldCgwLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5nZXQoMCwgMik7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhICogc3ViTWF0cml4MC5kZXQoKSAtIGIgKiBzdWJNYXRyaXgxLmRldCgpICsgYyAqIHN1Yk1hdHJpeDIuZGV0KCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBkZXRlcm1pbmFudCB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTHVEZWNvbXBvc2l0aW9uJCQxKHRoaXMpLmRldGVybWluYW50O1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdEZXRlcm1pbmFudCBjYW4gb25seSBiZSBjYWxjdWxhdGVkIGZvciBhIHNxdWFyZSBtYXRyaXguJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJldHVybnMgaW52ZXJzZSBvZiBhIG1hdHJpeCBpZiBpdCBleGlzdHMgb3IgdGhlIHBzZXVkb2ludmVyc2Vcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIC0gdGhyZXNob2xkIGZvciB0YWtpbmcgaW52ZXJzZSBvZiBzaW5ndWxhciB2YWx1ZXMgKGRlZmF1bHQgPSAxZS0xNSlcblx0ICAgICAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoZSAocHNldWRvKWludmVydGVkIG1hdHJpeC5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwc2V1ZG9JbnZlcnNlKHRocmVzaG9sZCkge1xuXHQgICAgICAgICAgICBpZiAodGhyZXNob2xkID09PSB1bmRlZmluZWQpIHRocmVzaG9sZCA9IE51bWJlci5FUFNJTE9OO1xuXHQgICAgICAgICAgICB2YXIgc3ZkU29sdXRpb24gPSBuZXcgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24kJDEodGhpcywge2F1dG9UcmFuc3Bvc2U6IHRydWV9KTtcblx0XG5cdCAgICAgICAgICAgIHZhciBVID0gc3ZkU29sdXRpb24ubGVmdFNpbmd1bGFyVmVjdG9ycztcblx0ICAgICAgICAgICAgdmFyIFYgPSBzdmRTb2x1dGlvbi5yaWdodFNpbmd1bGFyVmVjdG9ycztcblx0ICAgICAgICAgICAgdmFyIHMgPSBzdmRTb2x1dGlvbi5kaWFnb25hbDtcblx0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNbaV0pID4gdGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc1tpXSA9IDEuMCAvIHNbaV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHNbaV0gPSAwLjA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIC8vIGNvbnZlcnQgbGlzdCB0byBkaWFnb25hbFxuXHQgICAgICAgICAgICBzID0gdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wuc3BlY2llc10uZGlhZyhzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIFYubW11bChzLm1tdWwoVS50cmFuc3Bvc2VWaWV3KCkpKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYW4gZXhhY3QgYW5kIGluZGVwZW5kZW50IGNvcHkgb2YgdGhlIG1hdHJpeFxuXHQgICAgICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZSgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ld01hdHJpeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5zcGVjaWVzXSh0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IHRoaXMuY29sdW1uczsgY29sdW1uKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXdNYXRyaXguc2V0KHJvdywgY29sdW1uLCB0aGlzLmdldChyb3csIGNvbHVtbikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdNYXRyaXg7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIE1hdHJpeC5wcm90b3R5cGUua2xhc3MgPSAnTWF0cml4Jztcblx0XG5cdCAgICBmdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGEgLSBiO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qXG5cdCAgICAgU3lub255bXNcblx0ICAgICAqL1xuXHRcblx0ICAgIE1hdHJpeC5yYW5kb20gPSBNYXRyaXgucmFuZDtcblx0ICAgIE1hdHJpeC5kaWFnb25hbCA9IE1hdHJpeC5kaWFnO1xuXHQgICAgTWF0cml4LnByb3RvdHlwZS5kaWFnb25hbCA9IE1hdHJpeC5wcm90b3R5cGUuZGlhZztcblx0ICAgIE1hdHJpeC5pZGVudGl0eSA9IE1hdHJpeC5leWU7XG5cdCAgICBNYXRyaXgucHJvdG90eXBlLm5lZ2F0ZSA9IE1hdHJpeC5wcm90b3R5cGUubmVnO1xuXHQgICAgTWF0cml4LnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0ID0gTWF0cml4LnByb3RvdHlwZS5rcm9uZWNrZXJQcm9kdWN0O1xuXHQgICAgTWF0cml4LnByb3RvdHlwZS5kZXRlcm1pbmFudCA9IE1hdHJpeC5wcm90b3R5cGUuZGV0O1xuXHRcblx0ICAgIC8qXG5cdCAgICAgQWRkIGR5bmFtaWNhbGx5IGluc3RhbmNlIGFuZCBzdGF0aWMgbWV0aG9kcyBmb3IgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnNcblx0ICAgICAqL1xuXHRcblx0ICAgIHZhciBpbnBsYWNlT3BlcmF0b3IgPSBgXG5cdChmdW5jdGlvbiAlbmFtZSUodmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy4lbmFtZSVTKHZhbHVlKTtcblx0ICAgIHJldHVybiB0aGlzLiVuYW1lJU0odmFsdWUpO1xuXHR9KVxuXHRgO1xuXHRcblx0ICAgIHZhciBpbnBsYWNlT3BlcmF0b3JTY2FsYXIgPSBgXG5cdChmdW5jdGlvbiAlbmFtZSVTKHZhbHVlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuXHQgICAgICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAlb3AlIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0fSlcblx0YDtcblx0XG5cdCAgICB2YXIgaW5wbGFjZU9wZXJhdG9yTWF0cml4ID0gYFxuXHQoZnVuY3Rpb24gJW5hbWUlTShtYXRyaXgpIHtcblx0ICAgIG1hdHJpeCA9IHRoaXMuY29uc3RydWN0b3IuY2hlY2tNYXRyaXgobWF0cml4KTtcblx0ICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG5cdCAgICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuXHQgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICVvcCUgbWF0cml4LmdldChpLCBqKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH0pXG5cdGA7XG5cdFxuXHQgICAgdmFyIHN0YXRpY09wZXJhdG9yID0gYFxuXHQoZnVuY3Rpb24gJW5hbWUlKG1hdHJpeCwgdmFsdWUpIHtcblx0ICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpc1tTeW1ib2wuc3BlY2llc10obWF0cml4KTtcblx0ICAgIHJldHVybiBuZXdNYXRyaXguJW5hbWUlKHZhbHVlKTtcblx0fSlcblx0YDtcblx0XG5cdCAgICB2YXIgaW5wbGFjZU1ldGhvZCA9IGBcblx0KGZ1bmN0aW9uICVuYW1lJSgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KGksIGosICVtZXRob2QlKHRoaXMuZ2V0KGksIGopKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH0pXG5cdGA7XG5cdFxuXHQgICAgdmFyIHN0YXRpY01ldGhvZCA9IGBcblx0KGZ1bmN0aW9uICVuYW1lJShtYXRyaXgpIHtcblx0ICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpc1tTeW1ib2wuc3BlY2llc10obWF0cml4KTtcblx0ICAgIHJldHVybiBuZXdNYXRyaXguJW5hbWUlKCk7XG5cdH0pXG5cdGA7XG5cdFxuXHQgICAgdmFyIGlucGxhY2VNZXRob2RXaXRoQXJncyA9IGBcblx0KGZ1bmN0aW9uICVuYW1lJSglYXJncyUpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KGksIGosICVtZXRob2QlKHRoaXMuZ2V0KGksIGopLCAlYXJncyUpKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0fSlcblx0YDtcblx0XG5cdCAgICB2YXIgc3RhdGljTWV0aG9kV2l0aEFyZ3MgPSBgXG5cdChmdW5jdGlvbiAlbmFtZSUobWF0cml4LCAlYXJncyUpIHtcblx0ICAgIHZhciBuZXdNYXRyaXggPSBuZXcgdGhpc1tTeW1ib2wuc3BlY2llc10obWF0cml4KTtcblx0ICAgIHJldHVybiBuZXdNYXRyaXguJW5hbWUlKCVhcmdzJSk7XG5cdH0pXG5cdGA7XG5cdFxuXHRcblx0ICAgIHZhciBpbnBsYWNlTWV0aG9kV2l0aE9uZUFyZ1NjYWxhciA9IGBcblx0KGZ1bmN0aW9uICVuYW1lJVModmFsdWUpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KGksIGosICVtZXRob2QlKHRoaXMuZ2V0KGksIGopLCB2YWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHR9KVxuXHRgO1xuXHQgICAgdmFyIGlucGxhY2VNZXRob2RXaXRoT25lQXJnTWF0cml4ID0gYFxuXHQoZnVuY3Rpb24gJW5hbWUlTShtYXRyaXgpIHtcblx0ICAgIG1hdHJpeCA9IHRoaXMuY29uc3RydWN0b3IuY2hlY2tNYXRyaXgobWF0cml4KTtcblx0ICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG5cdCAgICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuXHQgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KGksIGosICVtZXRob2QlKHRoaXMuZ2V0KGksIGopLCBtYXRyaXguZ2V0KGksIGopKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH0pXG5cdGA7XG5cdFxuXHQgICAgdmFyIGlucGxhY2VNZXRob2RXaXRoT25lQXJnID0gYFxuXHQoZnVuY3Rpb24gJW5hbWUlKHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMuJW5hbWUlUyh2YWx1ZSk7XG5cdCAgICByZXR1cm4gdGhpcy4lbmFtZSVNKHZhbHVlKTtcblx0fSlcblx0YDtcblx0XG5cdCAgICB2YXIgc3RhdGljTWV0aG9kV2l0aE9uZUFyZyA9IHN0YXRpY01ldGhvZFdpdGhBcmdzO1xuXHRcblx0ICAgIHZhciBvcGVyYXRvcnMgPSBbXG5cdCAgICAgICAgLy8gQXJpdGhtZXRpYyBvcGVyYXRvcnNcblx0ICAgICAgICBbJysnLCAnYWRkJ10sXG5cdCAgICAgICAgWyctJywgJ3N1YicsICdzdWJ0cmFjdCddLFxuXHQgICAgICAgIFsnKicsICdtdWwnLCAnbXVsdGlwbHknXSxcblx0ICAgICAgICBbJy8nLCAnZGl2JywgJ2RpdmlkZSddLFxuXHQgICAgICAgIFsnJScsICdtb2QnLCAnbW9kdWx1cyddLFxuXHQgICAgICAgIC8vIEJpdHdpc2Ugb3BlcmF0b3JzXG5cdCAgICAgICAgWycmJywgJ2FuZCddLFxuXHQgICAgICAgIFsnfCcsICdvciddLFxuXHQgICAgICAgIFsnXicsICd4b3InXSxcblx0ICAgICAgICBbJzw8JywgJ2xlZnRTaGlmdCddLFxuXHQgICAgICAgIFsnPj4nLCAnc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdCddLFxuXHQgICAgICAgIFsnPj4+JywgJ3JpZ2h0U2hpZnQnLCAnemVyb0ZpbGxSaWdodFNoaWZ0J11cblx0ICAgIF07XG5cdFxuXHQgICAgdmFyIGk7XG5cdCAgICB2YXIgZXZhbDIgPSBldmFsO1xuXHQgICAgZm9yICh2YXIgb3BlcmF0b3Igb2Ygb3BlcmF0b3JzKSB7XG5cdCAgICAgICAgdmFyIGlucGxhY2VPcCA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VPcGVyYXRvciwge25hbWU6IG9wZXJhdG9yWzFdLCBvcDogb3BlcmF0b3JbMF19KSk7XG5cdCAgICAgICAgdmFyIGlucGxhY2VPcFMgPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihpbnBsYWNlT3BlcmF0b3JTY2FsYXIsIHtuYW1lOiBvcGVyYXRvclsxXSArICdTJywgb3A6IG9wZXJhdG9yWzBdfSkpO1xuXHQgICAgICAgIHZhciBpbnBsYWNlT3BNID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oaW5wbGFjZU9wZXJhdG9yTWF0cml4LCB7bmFtZTogb3BlcmF0b3JbMV0gKyAnTScsIG9wOiBvcGVyYXRvclswXX0pKTtcblx0ICAgICAgICB2YXIgc3RhdGljT3AgPSBldmFsMihmaWxsVGVtcGxhdGVGdW5jdGlvbihzdGF0aWNPcGVyYXRvciwge25hbWU6IG9wZXJhdG9yWzFdfSkpO1xuXHQgICAgICAgIGZvciAoaSA9IDE7IGkgPCBvcGVyYXRvci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBNYXRyaXgucHJvdG90eXBlW29wZXJhdG9yW2ldXSA9IGlucGxhY2VPcDtcblx0ICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVtvcGVyYXRvcltpXSArICdTJ10gPSBpbnBsYWNlT3BTO1xuXHQgICAgICAgICAgICBNYXRyaXgucHJvdG90eXBlW29wZXJhdG9yW2ldICsgJ00nXSA9IGlucGxhY2VPcE07XG5cdCAgICAgICAgICAgIE1hdHJpeFtvcGVyYXRvcltpXV0gPSBzdGF0aWNPcDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIG1ldGhvZHMgPSBbXG5cdCAgICAgICAgWyd+JywgJ25vdCddXG5cdCAgICBdO1xuXHRcblx0ICAgIFtcblx0ICAgICAgICAnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2NicnQnLCAnY2VpbCcsXG5cdCAgICAgICAgJ2NsejMyJywgJ2NvcycsICdjb3NoJywgJ2V4cCcsICdleHBtMScsICdmbG9vcicsICdmcm91bmQnLCAnbG9nJywgJ2xvZzFwJyxcblx0ICAgICAgICAnbG9nMTAnLCAnbG9nMicsICdyb3VuZCcsICdzaWduJywgJ3NpbicsICdzaW5oJywgJ3NxcnQnLCAndGFuJywgJ3RhbmgnLCAndHJ1bmMnXG5cdCAgICBdLmZvckVhY2goZnVuY3Rpb24gKG1hdGhNZXRob2QpIHtcblx0ICAgICAgICBtZXRob2RzLnB1c2goWydNYXRoLicgKyBtYXRoTWV0aG9kLCBtYXRoTWV0aG9kXSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBmb3IgKHZhciBtZXRob2Qgb2YgbWV0aG9kcykge1xuXHQgICAgICAgIHZhciBpbnBsYWNlTWV0aCA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2QsIHtuYW1lOiBtZXRob2RbMV0sIG1ldGhvZDogbWV0aG9kWzBdfSkpO1xuXHQgICAgICAgIHZhciBzdGF0aWNNZXRoID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oc3RhdGljTWV0aG9kLCB7bmFtZTogbWV0aG9kWzFdfSkpO1xuXHQgICAgICAgIGZvciAoaSA9IDE7IGkgPCBtZXRob2QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVttZXRob2RbaV1dID0gaW5wbGFjZU1ldGg7XG5cdCAgICAgICAgICAgIE1hdHJpeFttZXRob2RbaV1dID0gc3RhdGljTWV0aDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIG1ldGhvZHNXaXRoQXJncyA9IFtcblx0ICAgICAgICBbJ01hdGgucG93JywgMSwgJ3BvdyddXG5cdCAgICBdO1xuXHRcblx0ICAgIGZvciAodmFyIG1ldGhvZFdpdGhBcmcgb2YgbWV0aG9kc1dpdGhBcmdzKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSAnYXJnMCc7XG5cdCAgICAgICAgZm9yIChpID0gMTsgaSA8IG1ldGhvZFdpdGhBcmdbMV07IGkrKykge1xuXHQgICAgICAgICAgICBhcmdzICs9IGAsIGFyZyR7aX1gO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobWV0aG9kV2l0aEFyZ1sxXSAhPT0gMSkge1xuXHQgICAgICAgICAgICB2YXIgaW5wbGFjZU1ldGhXaXRoQXJncyA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2RXaXRoQXJncywge1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbWV0aG9kV2l0aEFyZ1syXSxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kV2l0aEFyZ1swXSxcblx0ICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3Ncblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB2YXIgc3RhdGljTWV0aFdpdGhBcmdzID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oc3RhdGljTWV0aG9kV2l0aEFyZ3MsIHtuYW1lOiBtZXRob2RXaXRoQXJnWzJdLCBhcmdzOiBhcmdzfSkpO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgbWV0aG9kV2l0aEFyZy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVttZXRob2RXaXRoQXJnW2ldXSA9IGlucGxhY2VNZXRoV2l0aEFyZ3M7XG5cdCAgICAgICAgICAgICAgICBNYXRyaXhbbWV0aG9kV2l0aEFyZ1tpXV0gPSBzdGF0aWNNZXRoV2l0aEFyZ3M7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgdG1wbFZhciA9IHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG1ldGhvZFdpdGhBcmdbMl0sXG5cdCAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2RXaXRoQXJnWzBdXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHZhciBpbnBsYWNlTWV0aG9kMiA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2RXaXRoT25lQXJnLCB0bXBsVmFyKSk7XG5cdCAgICAgICAgICAgIHZhciBpbnBsYWNlTWV0aG9kUyA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2RXaXRoT25lQXJnU2NhbGFyLCB0bXBsVmFyKSk7XG5cdCAgICAgICAgICAgIHZhciBpbnBsYWNlTWV0aG9kTSA9IGV2YWwyKGZpbGxUZW1wbGF0ZUZ1bmN0aW9uKGlucGxhY2VNZXRob2RXaXRoT25lQXJnTWF0cml4LCB0bXBsVmFyKSk7XG5cdCAgICAgICAgICAgIHZhciBzdGF0aWNNZXRob2QyID0gZXZhbDIoZmlsbFRlbXBsYXRlRnVuY3Rpb24oc3RhdGljTWV0aG9kV2l0aE9uZUFyZywgdG1wbFZhcikpO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAyOyBpIDwgbWV0aG9kV2l0aEFyZy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVttZXRob2RXaXRoQXJnW2ldXSA9IGlucGxhY2VNZXRob2QyO1xuXHQgICAgICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVttZXRob2RXaXRoQXJnW2ldICsgJ00nXSA9IGlucGxhY2VNZXRob2RNO1xuXHQgICAgICAgICAgICAgICAgTWF0cml4LnByb3RvdHlwZVttZXRob2RXaXRoQXJnW2ldICsgJ1MnXSA9IGlucGxhY2VNZXRob2RTO1xuXHQgICAgICAgICAgICAgICAgTWF0cml4W21ldGhvZFdpdGhBcmdbaV1dID0gc3RhdGljTWV0aG9kMjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmdW5jdGlvbiBmaWxsVGVtcGxhdGVGdW5jdGlvbih0ZW1wbGF0ZSwgdmFsdWVzKSB7XG5cdCAgICAgICAgZm9yICh2YXIgdmFsdWUgaW4gdmFsdWVzKSB7XG5cdCAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShuZXcgUmVnRXhwKCclJyArIHZhbHVlICsgJyUnLCAnZycpLCB2YWx1ZXNbdmFsdWVdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBNYXRyaXg7XG5cdH1cblx0XG5cdGNsYXNzIE1hdHJpeCBleHRlbmRzIEFic3RyYWN0TWF0cml4KEFycmF5KSB7XG5cdCAgICBjb25zdHJ1Y3RvcihuUm93cywgbkNvbHVtbnMpIHtcblx0ICAgICAgICB2YXIgaTtcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgblJvd3MgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkoblJvd3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoTWF0cml4LmlzTWF0cml4KG5Sb3dzKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gblJvd3MuY2xvbmUoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoblJvd3MpICYmIG5Sb3dzID4gMCkgeyAvLyBDcmVhdGUgYW4gZW1wdHkgbWF0cml4XG5cdCAgICAgICAgICAgIHN1cGVyKG5Sb3dzKTtcblx0ICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobkNvbHVtbnMpICYmIG5Db2x1bW5zID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5Sb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gbmV3IEFycmF5KG5Db2x1bW5zKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25Db2x1bW5zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoblJvd3MpKSB7IC8vIENvcHkgdGhlIHZhbHVlcyBmcm9tIHRoZSAyRCBhcnJheVxuXHQgICAgICAgICAgICBjb25zdCBtYXRyaXggPSBuUm93cztcblx0ICAgICAgICAgICAgblJvd3MgPSBtYXRyaXgubGVuZ3RoO1xuXHQgICAgICAgICAgICBuQ29sdW1ucyA9IG1hdHJpeFswXS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgbkNvbHVtbnMgIT09ICdudW1iZXInIHx8IG5Db2x1bW5zID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYSAyRCBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50Jyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc3VwZXIoblJvd3MpO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG1hdHJpeFtpXS5sZW5ndGggIT09IG5Db2x1bW5zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luY29uc2lzdGVudCBhcnJheSBkaW1lbnNpb25zJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzW2ldID0gW10uY29uY2F0KG1hdHJpeFtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMucm93cyA9IG5Sb3dzO1xuXHQgICAgICAgIHRoaXMuY29sdW1ucyA9IG5Db2x1bW5zO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHRcblx0ICAgIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgdGhpc1tyb3dJbmRleF1bY29sdW1uSW5kZXhdID0gdmFsdWU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdFxuXHQgICAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzW3Jvd0luZGV4XVtjb2x1bW5JbmRleF07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIGEgcm93IGZyb20gdGhlIGdpdmVuIGluZGV4XG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXhcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH0gdGhpc1xuXHQgICAgICovXG5cdCAgICByZW1vdmVSb3coaW5kZXgpIHtcblx0ICAgICAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4KTtcblx0ICAgICAgICBpZiAodGhpcy5yb3dzID09PSAxKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBIG1hdHJpeCBjYW5ub3QgaGF2ZSBsZXNzIHRoYW4gb25lIHJvdycpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgdGhpcy5yb3dzIC09IDE7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBZGRzIGEgcm93IGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleCA9IHRoaXMucm93c10gLSBSb3cgaW5kZXhcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSBhcnJheSAtIEFycmF5IG9yIHZlY3RvclxuXHQgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG5cdCAgICAgKi9cblx0ICAgIGFkZFJvdyhpbmRleCwgYXJyYXkpIHtcblx0ICAgICAgICBpZiAoYXJyYXkgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBhcnJheSA9IGluZGV4O1xuXHQgICAgICAgICAgICBpbmRleCA9IHRoaXMucm93cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgICAgYXJyYXkgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCBhcnJheSwgdHJ1ZSk7XG5cdCAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDAsIGFycmF5KTtcblx0ICAgICAgICB0aGlzLnJvd3MgKz0gMTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgYSBjb2x1bW4gZnJvbSB0aGUgZ2l2ZW4gaW5kZXhcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIENvbHVtbiBpbmRleFxuXHQgICAgICogQHJldHVybiB7TWF0cml4fSB0aGlzXG5cdCAgICAgKi9cblx0ICAgIHJlbW92ZUNvbHVtbihpbmRleCkge1xuXHQgICAgICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgaW5kZXgpO1xuXHQgICAgICAgIGlmICh0aGlzLmNvbHVtbnMgPT09IDEpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0EgbWF0cml4IGNhbm5vdCBoYXZlIGxlc3MgdGhhbiBvbmUgY29sdW1uJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpc1tpXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmNvbHVtbnMgLT0gMTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEFkZHMgYSBjb2x1bW4gYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4ID0gdGhpcy5jb2x1bW5zXSAtIENvbHVtbiBpbmRleFxuXHQgICAgICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IGFycmF5IC0gQXJyYXkgb3IgdmVjdG9yXG5cdCAgICAgKiBAcmV0dXJuIHtNYXRyaXh9IHRoaXNcblx0ICAgICAqL1xuXHQgICAgYWRkQ29sdW1uKGluZGV4LCBhcnJheSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgYXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIGFycmF5ID0gaW5kZXg7XG5cdCAgICAgICAgICAgIGluZGV4ID0gdGhpcy5jb2x1bW5zO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4LCB0cnVlKTtcblx0ICAgICAgICBhcnJheSA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIGFycmF5KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXNbaV0uc3BsaWNlKGluZGV4LCAwLCBhcnJheVtpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29sdW1ucyArPSAxO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRjbGFzcyBXcmFwcGVyTWF0cml4MUQgZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeCgpIHtcblx0ICAgIC8qKlxuXHQgICAgICogQGNsYXNzIFdyYXBwZXJNYXRyaXgxRFxuXHQgICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXRhXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMucm93cyA9IDFdXG5cdCAgICAgKi9cblx0ICAgIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuXHQgICAgICAgIGNvbnN0IHtcblx0ICAgICAgICAgICAgcm93cyA9IDFcblx0ICAgICAgICB9ID0gb3B0aW9ucztcblx0XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoICUgcm93cyAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBkYXRhIGxlbmd0aCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBudW1iZXIgb2Ygcm93cycpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzdXBlcigpO1xuXHQgICAgICAgIHRoaXMucm93cyA9IHJvd3M7XG5cdCAgICAgICAgdGhpcy5jb2x1bW5zID0gZGF0YS5sZW5ndGggLyByb3dzO1xuXHQgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cdCAgICB9XG5cdFxuXHQgICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9jYWxjdWxhdGVJbmRleChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuXHQgICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSB2YWx1ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0XG5cdCAgICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fY2FsY3VsYXRlSW5kZXgocm93SW5kZXgsIGNvbHVtbkluZGV4KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcblx0ICAgIH1cblx0XG5cdCAgICBfY2FsY3VsYXRlSW5kZXgocm93LCBjb2x1bW4pIHtcblx0ICAgICAgICByZXR1cm4gKHJvdyAqIHRoaXMuY29sdW1ucykgKyBjb2x1bW47XG5cdCAgICB9XG5cdFxuXHQgICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuXHQgICAgICAgIHJldHVybiBNYXRyaXg7XG5cdCAgICB9XG5cdH1cblx0XG5cdGNsYXNzIFdyYXBwZXJNYXRyaXgyRCBleHRlbmRzIEFic3RyYWN0TWF0cml4KCkge1xuXHQgICAgLyoqXG5cdCAgICAgKiBAY2xhc3MgV3JhcHBlck1hdHJpeDJEXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBkYXRhXG5cdCAgICAgKi9cblx0ICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcblx0ICAgICAgICBzdXBlcigpO1xuXHQgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cdCAgICAgICAgdGhpcy5yb3dzID0gZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgdGhpcy5jb2x1bW5zID0gZGF0YVswXS5sZW5ndGg7XG5cdCAgICB9XG5cdFxuXHQgICAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICB0aGlzLmRhdGFbcm93SW5kZXhdW2NvbHVtbkluZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHRcblx0ICAgIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0luZGV4XVtjb2x1bW5JbmRleF07XG5cdCAgICB9XG5cdFxuXHQgICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuXHQgICAgICAgIHJldHVybiBNYXRyaXg7XG5cdCAgICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fEFycmF5PG51bWJlcj59IGFycmF5XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnJvd3MgPSAxXVxuXHQgKiBAcmV0dXJuIHtXcmFwcGVyTWF0cml4MUR8V3JhcHBlck1hdHJpeDJEfVxuXHQgKi9cblx0ZnVuY3Rpb24gd3JhcChhcnJheSwgb3B0aW9ucykge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdCAgICAgICAgaWYgKGFycmF5WzBdICYmIEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV3JhcHBlck1hdHJpeDJEKGFycmF5KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXJNYXRyaXgxRChhcnJheSwgb3B0aW9ucyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXknKTtcblx0ICAgIH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEBjbGFzcyBRckRlY29tcG9zaXRpb25cblx0ICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2x1dHpyb2VkZXIvTWFwYWNrL2Jsb2IvbWFzdGVyL1NvdXJjZS9RckRlY29tcG9zaXRpb24uY3Ncblx0ICogQHBhcmFtIHtNYXRyaXh9IHZhbHVlXG5cdCAqL1xuXHRjbGFzcyBRckRlY29tcG9zaXRpb24kJDEge1xuXHQgICAgY29uc3RydWN0b3IodmFsdWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cdFxuXHQgICAgICAgIHZhciBxciA9IHZhbHVlLmNsb25lKCk7XG5cdCAgICAgICAgdmFyIG0gPSB2YWx1ZS5yb3dzO1xuXHQgICAgICAgIHZhciBuID0gdmFsdWUuY29sdW1ucztcblx0ICAgICAgICB2YXIgcmRpYWcgPSBuZXcgQXJyYXkobik7XG5cdCAgICAgICAgdmFyIGksIGosIGssIHM7XG5cdFxuXHQgICAgICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5ybSA9IDA7XG5cdCAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG5ybSA9IGh5cG90ZW51c2UobnJtLCBxci5nZXQoaSwgaykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChucm0gIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGlmIChxci5nZXQoaywgaykgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbnJtID0gLW5ybTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBxci5zZXQoaSwgaywgcXIuZ2V0KGksIGspIC8gbnJtKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHFyLnNldChrLCBrLCBxci5nZXQoaywgaykgKyAxKTtcblx0ICAgICAgICAgICAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzICs9IHFyLmdldChpLCBrKSAqIHFyLmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcyA9IC1zIC8gcXIuZ2V0KGssIGspO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcXIuc2V0KGksIGosIHFyLmdldChpLCBqKSArIHMgKiBxci5nZXQoaSwgaykpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZGlhZ1trXSA9IC1ucm07XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB0aGlzLlFSID0gcXI7XG5cdCAgICAgICAgdGhpcy5SZGlhZyA9IHJkaWFnO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogU29sdmUgYSBwcm9ibGVtIG9mIGxlYXN0IHNxdWFyZSAoQXg9YikgYnkgdXNpbmcgdGhlIFFSIGRlY29tcG9zaXRpb24uIFVzZWZ1bCB3aGVuIEEgaXMgcmVjdGFuZ3VsYXIsIGJ1dCBub3Qgd29ya2luZyB3aGVuIEEgaXMgc2luZ3VsYXIuXG5cdCAgICAgKiBFeGFtcGxlIDogV2Ugc2VhcmNoIHRvIGFwcHJveGltYXRlIHgsIHdpdGggQSBtYXRyaXggc2hhcGUgbSpuLCB4IHZlY3RvciBzaXplIG4sIGIgdmVjdG9yIHNpemUgbSAobSA+IG4pLiBXZSB3aWxsIHVzZSA6XG5cdCAgICAgKiB2YXIgcXIgPSBRckRlY29tcG9zaXRpb24oQSk7XG5cdCAgICAgKiB2YXIgeCA9IHFyLnNvbHZlKGIpO1xuXHQgICAgICogQHBhcmFtIHtNYXRyaXh9IHZhbHVlIC0gTWF0cml4IDFEIHdoaWNoIGlzIHRoZSB2ZWN0b3IgYiAoaW4gdGhlIGVxdWF0aW9uIEF4ID0gYilcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH0gLSBUaGUgdmVjdG9yIHhcblx0ICAgICAqL1xuXHQgICAgc29sdmUodmFsdWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IE1hdHJpeC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cdFxuXHQgICAgICAgIHZhciBxciA9IHRoaXMuUVI7XG5cdCAgICAgICAgdmFyIG0gPSBxci5yb3dzO1xuXHRcblx0ICAgICAgICBpZiAodmFsdWUucm93cyAhPT0gbSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5pc0Z1bGxSYW5rKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgcmFuayBkZWZpY2llbnQnKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHZhciBjb3VudCA9IHZhbHVlLmNvbHVtbnM7XG5cdCAgICAgICAgdmFyIFggPSB2YWx1ZS5jbG9uZSgpO1xuXHQgICAgICAgIHZhciBuID0gcXIuY29sdW1ucztcblx0ICAgICAgICB2YXIgaSwgaiwgaywgcztcblx0XG5cdCAgICAgICAgZm9yIChrID0gMDsgayA8IG47IGsrKykge1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgcyA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcyArPSBxcltpXVtrXSAqIFhbaV1bal07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzID0gLXMgLyBxcltrXVtrXTtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdICs9IHMgKiBxcltpXVtrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKGsgPSBuIC0gMTsgayA+PSAwOyBrLS0pIHtcblx0ICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIFhba11bal0gLz0gdGhpcy5SZGlhZ1trXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgazsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIFhbaV1bal0gLT0gWFtrXVtqXSAqIHFyW2ldW2tdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gWC5zdWJNYXRyaXgoMCwgbiAtIDEsIDAsIGNvdW50IC0gMSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICAgICAqL1xuXHQgICAgaXNGdWxsUmFuaygpIHtcblx0ICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuUVIuY29sdW1ucztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5SZGlhZ1tpXSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgZ2V0IHVwcGVyVHJpYW5ndWxhck1hdHJpeCgpIHtcblx0ICAgICAgICB2YXIgcXIgPSB0aGlzLlFSO1xuXHQgICAgICAgIHZhciBuID0gcXIuY29sdW1ucztcblx0ICAgICAgICB2YXIgWCA9IG5ldyBNYXRyaXgobiwgbik7XG5cdCAgICAgICAgdmFyIGksIGo7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IGopIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gcXJbaV1bal07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGopIHtcblx0ICAgICAgICAgICAgICAgICAgICBYW2ldW2pdID0gdGhpcy5SZGlhZ1tpXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgWFtpXVtqXSA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFg7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7TWF0cml4fVxuXHQgICAgICovXG5cdCAgICBnZXQgb3J0aG9nb25hbE1hdHJpeCgpIHtcblx0ICAgICAgICB2YXIgcXIgPSB0aGlzLlFSO1xuXHQgICAgICAgIHZhciByb3dzID0gcXIucm93cztcblx0ICAgICAgICB2YXIgY29sdW1ucyA9IHFyLmNvbHVtbnM7XG5cdCAgICAgICAgdmFyIFggPSBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuXHQgICAgICAgIHZhciBpLCBqLCBrLCBzO1xuXHRcblx0ICAgICAgICBmb3IgKGsgPSBjb2x1bW5zIC0gMTsgayA+PSAwOyBrLS0pIHtcblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgWFtpXVtrXSA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgWFtrXVtrXSA9IDE7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IGs7IGogPCBjb2x1bW5zOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChxcltrXVtrXSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHMgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGs7IGkgPCByb3dzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBxcltpXVtrXSAqIFhbaV1bal07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgICAgICBzID0gLXMgLyBxcltrXVtrXTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gazsgaSA8IHJvd3M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBYW2ldW2pdICs9IHMgKiBxcltpXVtrXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFg7XG5cdCAgICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBvZiBhIE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVNWRD1mYWxzZV1cblx0ICogQHJldHVybiB7TWF0cml4fVxuXHQgKi9cblx0ZnVuY3Rpb24gaW52ZXJzZSQkMShtYXRyaXgsIHVzZVNWRCA9IGZhbHNlKSB7XG5cdCAgICBtYXRyaXggPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgobWF0cml4KTtcblx0ICAgIGlmICh1c2VTVkQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uJCQxKG1hdHJpeCkuaW52ZXJzZSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gc29sdmUkJDEobWF0cml4LCBNYXRyaXguZXllKG1hdHJpeC5yb3dzKSk7XG5cdCAgICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge01hdHJpeH0gbGVmdEhhbmRTaWRlXG5cdCAqIEBwYXJhbSB7TWF0cml4fSByaWdodEhhbmRTaWRlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZVNWRCA9IGZhbHNlXVxuXHQgKiBAcmV0dXJuIHtNYXRyaXh9XG5cdCAqL1xuXHRmdW5jdGlvbiBzb2x2ZSQkMShsZWZ0SGFuZFNpZGUsIHJpZ2h0SGFuZFNpZGUsIHVzZVNWRCA9IGZhbHNlKSB7XG5cdCAgICBsZWZ0SGFuZFNpZGUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgobGVmdEhhbmRTaWRlKTtcblx0ICAgIHJpZ2h0SGFuZFNpZGUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgocmlnaHRIYW5kU2lkZSk7XG5cdCAgICBpZiAodXNlU1ZEKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiQkMShsZWZ0SGFuZFNpZGUpLnNvbHZlKHJpZ2h0SGFuZFNpZGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbGVmdEhhbmRTaWRlLmlzU3F1YXJlKCkgPyBuZXcgTHVEZWNvbXBvc2l0aW9uJCQxKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSkgOiBuZXcgUXJEZWNvbXBvc2l0aW9uJCQxKGxlZnRIYW5kU2lkZSkuc29sdmUocmlnaHRIYW5kU2lkZSk7XG5cdCAgICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAY2xhc3MgRWlnZW52YWx1ZURlY29tcG9zaXRpb25cblx0ICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2x1dHpyb2VkZXIvTWFwYWNrL2Jsb2IvbWFzdGVyL1NvdXJjZS9FaWdlbnZhbHVlRGVjb21wb3NpdGlvbi5jc1xuXHQgKiBAcGFyYW0ge01hdHJpeH0gbWF0cml4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hc3N1bWVTeW1tZXRyaWM9ZmFsc2VdXG5cdCAqL1xuXHRjbGFzcyBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbiQkMSB7XG5cdCAgICBjb25zdHJ1Y3RvcihtYXRyaXgsIG9wdGlvbnMgPSB7fSkge1xuXHQgICAgICAgIGNvbnN0IHtcblx0ICAgICAgICAgICAgYXNzdW1lU3ltbWV0cmljID0gZmFsc2Vcblx0ICAgICAgICB9ID0gb3B0aW9ucztcblx0XG5cdCAgICAgICAgbWF0cml4ID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KG1hdHJpeCk7XG5cdCAgICAgICAgaWYgKCFtYXRyaXguaXNTcXVhcmUoKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBpcyBub3QgYSBzcXVhcmUgbWF0cml4Jyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB2YXIgbiA9IG1hdHJpeC5jb2x1bW5zO1xuXHQgICAgICAgIHZhciBWID0gZ2V0RmlsbGVkMkRBcnJheShuLCBuLCAwKTtcblx0ICAgICAgICB2YXIgZCA9IG5ldyBBcnJheShuKTtcblx0ICAgICAgICB2YXIgZSA9IG5ldyBBcnJheShuKTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBtYXRyaXg7XG5cdCAgICAgICAgdmFyIGksIGo7XG5cdFxuXHQgICAgICAgIHZhciBpc1N5bW1ldHJpYyA9IGZhbHNlO1xuXHQgICAgICAgIGlmIChhc3N1bWVTeW1tZXRyaWMpIHtcblx0ICAgICAgICAgICAgaXNTeW1tZXRyaWMgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGlzU3ltbWV0cmljID0gbWF0cml4LmlzU3ltbWV0cmljKCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoaXNTeW1tZXRyaWMpIHtcblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIFZbaV1bal0gPSB2YWx1ZS5nZXQoaSwgaik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJlZDIobiwgZSwgZCwgVik7XG5cdCAgICAgICAgICAgIHRxbDIobiwgZSwgZCwgVik7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIEggPSBnZXRGaWxsZWQyREFycmF5KG4sIG4sIDApO1xuXHQgICAgICAgICAgICB2YXIgb3J0ID0gbmV3IEFycmF5KG4pO1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtpXVtqXSA9IHZhbHVlLmdldChpLCBqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcnRoZXMobiwgSCwgb3J0LCBWKTtcblx0ICAgICAgICAgICAgaHFyMihuLCBlLCBkLCBWLCBIKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHRoaXMubiA9IG47XG5cdCAgICAgICAgdGhpcy5lID0gZTtcblx0ICAgICAgICB0aGlzLmQgPSBkO1xuXHQgICAgICAgIHRoaXMuViA9IFY7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn1cblx0ICAgICAqL1xuXHQgICAgZ2V0IHJlYWxFaWdlbnZhbHVlcygpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5kO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59XG5cdCAgICAgKi9cblx0ICAgIGdldCBpbWFnaW5hcnlFaWdlbnZhbHVlcygpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5lO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgZ2V0IGVpZ2VudmVjdG9yTWF0cml4KCkge1xuXHQgICAgICAgIGlmICghTWF0cml4LmlzTWF0cml4KHRoaXMuVikpIHtcblx0ICAgICAgICAgICAgdGhpcy5WID0gbmV3IE1hdHJpeCh0aGlzLlYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5WO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge01hdHJpeH1cblx0ICAgICAqL1xuXHQgICAgZ2V0IGRpYWdvbmFsTWF0cml4KCkge1xuXHQgICAgICAgIHZhciBuID0gdGhpcy5uO1xuXHQgICAgICAgIHZhciBlID0gdGhpcy5lO1xuXHQgICAgICAgIHZhciBkID0gdGhpcy5kO1xuXHQgICAgICAgIHZhciBYID0gbmV3IE1hdHJpeChuLCBuKTtcblx0ICAgICAgICB2YXIgaSwgajtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIFhbaV1bal0gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIFhbaV1baV0gPSBkW2ldO1xuXHQgICAgICAgICAgICBpZiAoZVtpXSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIFhbaV1baSArIDFdID0gZVtpXTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChlW2ldIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgWFtpXVtpIC0gMV0gPSBlW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBYO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiB0cmVkMihuLCBlLCBkLCBWKSB7XG5cdCAgICB2YXIgZiwgZywgaCwgaSwgaiwgayxcblx0ICAgICAgICBoaCwgc2NhbGU7XG5cdFxuXHQgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuXHQgICAgICAgIGRbal0gPSBWW24gLSAxXVtqXTtcblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKGkgPSBuIC0gMTsgaSA+IDA7IGktLSkge1xuXHQgICAgICAgIHNjYWxlID0gMDtcblx0ICAgICAgICBoID0gMDtcblx0ICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG5cdCAgICAgICAgICAgIHNjYWxlID0gc2NhbGUgKyBNYXRoLmFicyhkW2tdKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChzY2FsZSA9PT0gMCkge1xuXHQgICAgICAgICAgICBlW2ldID0gZFtpIC0gMV07XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGRbal0gPSBWW2kgLSAxXVtqXTtcblx0ICAgICAgICAgICAgICAgIFZbaV1bal0gPSAwO1xuXHQgICAgICAgICAgICAgICAgVltqXVtpXSA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICBkW2tdIC89IHNjYWxlO1xuXHQgICAgICAgICAgICAgICAgaCArPSBkW2tdICogZFtrXTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZiA9IGRbaSAtIDFdO1xuXHQgICAgICAgICAgICBnID0gTWF0aC5zcXJ0KGgpO1xuXHQgICAgICAgICAgICBpZiAoZiA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGcgPSAtZztcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZVtpXSA9IHNjYWxlICogZztcblx0ICAgICAgICAgICAgaCA9IGggLSBmICogZztcblx0ICAgICAgICAgICAgZFtpIC0gMV0gPSBmIC0gZztcblx0ICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZVtqXSA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGYgPSBkW2pdO1xuXHQgICAgICAgICAgICAgICAgVltqXVtpXSA9IGY7XG5cdCAgICAgICAgICAgICAgICBnID0gZVtqXSArIFZbal1bal0gKiBmO1xuXHQgICAgICAgICAgICAgICAgZm9yIChrID0gaiArIDE7IGsgPD0gaSAtIDE7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGcgKz0gVltrXVtqXSAqIGRba107XG5cdCAgICAgICAgICAgICAgICAgICAgZVtrXSArPSBWW2tdW2pdICogZjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVbal0gPSBnO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBmID0gMDtcblx0ICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZVtqXSAvPSBoO1xuXHQgICAgICAgICAgICAgICAgZiArPSBlW2pdICogZFtqXTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaGggPSBmIC8gKGggKyBoKTtcblx0ICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZVtqXSAtPSBoaCAqIGRbal07XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGYgPSBkW2pdO1xuXHQgICAgICAgICAgICAgICAgZyA9IGVbal07XG5cdCAgICAgICAgICAgICAgICBmb3IgKGsgPSBqOyBrIDw9IGkgLSAxOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBWW2tdW2pdIC09IChmICogZVtrXSArIGcgKiBkW2tdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGRbal0gPSBWW2kgLSAxXVtqXTtcblx0ICAgICAgICAgICAgICAgIFZbaV1bal0gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRbaV0gPSBoO1xuXHQgICAgfVxuXHRcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG5cdCAgICAgICAgVltuIC0gMV1baV0gPSBWW2ldW2ldO1xuXHQgICAgICAgIFZbaV1baV0gPSAxO1xuXHQgICAgICAgIGggPSBkW2kgKyAxXTtcblx0ICAgICAgICBpZiAoaCAhPT0gMCkge1xuXHQgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDw9IGk7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgZFtrXSA9IFZba11baSArIDFdIC8gaDtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8PSBpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGcgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8PSBpOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBnICs9IFZba11baSArIDFdICogVltrXVtqXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgVltrXVtqXSAtPSBnICogZFtrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZm9yIChrID0gMDsgayA8PSBpOyBrKyspIHtcblx0ICAgICAgICAgICAgVltrXVtpICsgMV0gPSAwO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgZFtqXSA9IFZbbiAtIDFdW2pdO1xuXHQgICAgICAgIFZbbiAtIDFdW2pdID0gMDtcblx0ICAgIH1cblx0XG5cdCAgICBWW24gLSAxXVtuIC0gMV0gPSAxO1xuXHQgICAgZVswXSA9IDA7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHRxbDIobiwgZSwgZCwgVikge1xuXHRcblx0ICAgIHZhciBnLCBoLCBpLCBqLCBrLCBsLCBtLCBwLCByLFxuXHQgICAgICAgIGRsMSwgYywgYzIsIGMzLCBlbDEsIHMsIHMyLFxuXHQgICAgICAgIGl0ZXI7XG5cdFxuXHQgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIGVbaSAtIDFdID0gZVtpXTtcblx0ICAgIH1cblx0XG5cdCAgICBlW24gLSAxXSA9IDA7XG5cdFxuXHQgICAgdmFyIGYgPSAwO1xuXHQgICAgdmFyIHRzdDEgPSAwO1xuXHQgICAgdmFyIGVwcyA9IE51bWJlci5FUFNJTE9OO1xuXHRcblx0ICAgIGZvciAobCA9IDA7IGwgPCBuOyBsKyspIHtcblx0ICAgICAgICB0c3QxID0gTWF0aC5tYXgodHN0MSwgTWF0aC5hYnMoZFtsXSkgKyBNYXRoLmFicyhlW2xdKSk7XG5cdCAgICAgICAgbSA9IGw7XG5cdCAgICAgICAgd2hpbGUgKG0gPCBuKSB7XG5cdCAgICAgICAgICAgIGlmIChNYXRoLmFicyhlW21dKSA8PSBlcHMgKiB0c3QxKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBtKys7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAobSA+IGwpIHtcblx0ICAgICAgICAgICAgaXRlciA9IDA7XG5cdCAgICAgICAgICAgIGRvIHtcblx0ICAgICAgICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcblx0XG5cdCAgICAgICAgICAgICAgICBnID0gZFtsXTtcblx0ICAgICAgICAgICAgICAgIHAgPSAoZFtsICsgMV0gLSBnKSAvICgyICogZVtsXSk7XG5cdCAgICAgICAgICAgICAgICByID0gaHlwb3RlbnVzZShwLCAxKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHIgPSAtcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBkW2xdID0gZVtsXSAvIChwICsgcik7XG5cdCAgICAgICAgICAgICAgICBkW2wgKyAxXSA9IGVbbF0gKiAocCArIHIpO1xuXHQgICAgICAgICAgICAgICAgZGwxID0gZFtsICsgMV07XG5cdCAgICAgICAgICAgICAgICBoID0gZyAtIGRbbF07XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBsICsgMjsgaSA8IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGRbaV0gLT0gaDtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBmID0gZiArIGg7XG5cdFxuXHQgICAgICAgICAgICAgICAgcCA9IGRbbV07XG5cdCAgICAgICAgICAgICAgICBjID0gMTtcblx0ICAgICAgICAgICAgICAgIGMyID0gYztcblx0ICAgICAgICAgICAgICAgIGMzID0gYztcblx0ICAgICAgICAgICAgICAgIGVsMSA9IGVbbCArIDFdO1xuXHQgICAgICAgICAgICAgICAgcyA9IDA7XG5cdCAgICAgICAgICAgICAgICBzMiA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBtIC0gMTsgaSA+PSBsOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBjMyA9IGMyO1xuXHQgICAgICAgICAgICAgICAgICAgIGMyID0gYztcblx0ICAgICAgICAgICAgICAgICAgICBzMiA9IHM7XG5cdCAgICAgICAgICAgICAgICAgICAgZyA9IGMgKiBlW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGggPSBjICogcDtcblx0ICAgICAgICAgICAgICAgICAgICByID0gaHlwb3RlbnVzZShwLCBlW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICBlW2kgKyAxXSA9IHMgKiByO1xuXHQgICAgICAgICAgICAgICAgICAgIHMgPSBlW2ldIC8gcjtcblx0ICAgICAgICAgICAgICAgICAgICBjID0gcCAvIHI7XG5cdCAgICAgICAgICAgICAgICAgICAgcCA9IGMgKiBkW2ldIC0gcyAqIGc7XG5cdCAgICAgICAgICAgICAgICAgICAgZFtpICsgMV0gPSBoICsgcyAqIChjICogZyArIHMgKiBkW2ldKTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG47IGsrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoID0gVltrXVtpICsgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFZba11baSArIDFdID0gcyAqIFZba11baV0gKyBjICogaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVltrXVtpXSA9IGMgKiBWW2tdW2ldIC0gcyAqIGg7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIHAgPSAtcyAqIHMyICogYzMgKiBlbDEgKiBlW2xdIC8gZGwxO1xuXHQgICAgICAgICAgICAgICAgZVtsXSA9IHMgKiBwO1xuXHQgICAgICAgICAgICAgICAgZFtsXSA9IGMgKiBwO1xuXHRcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB3aGlsZSAoTWF0aC5hYnMoZVtsXSkgPiBlcHMgKiB0c3QxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZFtsXSA9IGRbbF0gKyBmO1xuXHQgICAgICAgIGVbbF0gPSAwO1xuXHQgICAgfVxuXHRcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG5cdCAgICAgICAgayA9IGk7XG5cdCAgICAgICAgcCA9IGRbaV07XG5cdCAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspIHtcblx0ICAgICAgICAgICAgaWYgKGRbal0gPCBwKSB7XG5cdCAgICAgICAgICAgICAgICBrID0gajtcblx0ICAgICAgICAgICAgICAgIHAgPSBkW2pdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoayAhPT0gaSkge1xuXHQgICAgICAgICAgICBkW2tdID0gZFtpXTtcblx0ICAgICAgICAgICAgZFtpXSA9IHA7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHAgPSBWW2pdW2ldO1xuXHQgICAgICAgICAgICAgICAgVltqXVtpXSA9IFZbal1ba107XG5cdCAgICAgICAgICAgICAgICBWW2pdW2tdID0gcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gb3J0aGVzKG4sIEgsIG9ydCwgVikge1xuXHRcblx0ICAgIHZhciBsb3cgPSAwO1xuXHQgICAgdmFyIGhpZ2ggPSBuIC0gMTtcblx0ICAgIHZhciBmLCBnLCBoLCBpLCBqLCBtO1xuXHQgICAgdmFyIHNjYWxlO1xuXHRcblx0ICAgIGZvciAobSA9IGxvdyArIDE7IG0gPD0gaGlnaCAtIDE7IG0rKykge1xuXHQgICAgICAgIHNjYWxlID0gMDtcblx0ICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuXHQgICAgICAgICAgICBzY2FsZSA9IHNjYWxlICsgTWF0aC5hYnMoSFtpXVttIC0gMV0pO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKHNjYWxlICE9PSAwKSB7XG5cdCAgICAgICAgICAgIGggPSAwO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSBoaWdoOyBpID49IG07IGktLSkge1xuXHQgICAgICAgICAgICAgICAgb3J0W2ldID0gSFtpXVttIC0gMV0gLyBzY2FsZTtcblx0ICAgICAgICAgICAgICAgIGggKz0gb3J0W2ldICogb3J0W2ldO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBnID0gTWF0aC5zcXJ0KGgpO1xuXHQgICAgICAgICAgICBpZiAob3J0W21dID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZyA9IC1nO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBoID0gaCAtIG9ydFttXSAqIGc7XG5cdCAgICAgICAgICAgIG9ydFttXSA9IG9ydFttXSAtIGc7XG5cdFxuXHQgICAgICAgICAgICBmb3IgKGogPSBtOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBmID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IGhpZ2g7IGkgPj0gbTsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZiArPSBvcnRbaV0gKiBIW2ldW2pdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGYgPSBmIC8gaDtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtpXVtqXSAtPSBmICogb3J0W2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGhpZ2g7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZiA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSBoaWdoOyBqID49IG07IGotLSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGYgKz0gb3J0W2pdICogSFtpXVtqXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBmID0gZiAvIGg7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSBtOyBqIDw9IGhpZ2g7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbaV1bal0gLT0gZiAqIG9ydFtqXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgb3J0W21dID0gc2NhbGUgKiBvcnRbbV07XG5cdCAgICAgICAgICAgIEhbbV1bbSAtIDFdID0gc2NhbGUgKiBnO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuXHQgICAgICAgICAgICBWW2ldW2pdID0gKGkgPT09IGogPyAxIDogMCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGZvciAobSA9IGhpZ2ggLSAxOyBtID49IGxvdyArIDE7IG0tLSkge1xuXHQgICAgICAgIGlmIChIW21dW20gLSAxXSAhPT0gMCkge1xuXHQgICAgICAgICAgICBmb3IgKGkgPSBtICsgMTsgaSA8PSBoaWdoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9ydFtpXSA9IEhbaV1bbSAtIDFdO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBmb3IgKGogPSBtOyBqIDw9IGhpZ2g7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZyA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGcgKz0gb3J0W2ldICogVltpXVtqXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBnID0gKGcgLyBvcnRbbV0pIC8gSFttXVttIC0gMV07XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIFZbaV1bal0gKz0gZyAqIG9ydFtpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gaHFyMihubiwgZSwgZCwgViwgSCkge1xuXHQgICAgdmFyIG4gPSBubiAtIDE7XG5cdCAgICB2YXIgbG93ID0gMDtcblx0ICAgIHZhciBoaWdoID0gbm4gLSAxO1xuXHQgICAgdmFyIGVwcyA9IE51bWJlci5FUFNJTE9OO1xuXHQgICAgdmFyIGV4c2hpZnQgPSAwO1xuXHQgICAgdmFyIG5vcm0gPSAwO1xuXHQgICAgdmFyIHAgPSAwO1xuXHQgICAgdmFyIHEgPSAwO1xuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgdmFyIHMgPSAwO1xuXHQgICAgdmFyIHogPSAwO1xuXHQgICAgdmFyIGl0ZXIgPSAwO1xuXHQgICAgdmFyIGksIGosIGssIGwsIG0sIHQsIHcsIHgsIHk7XG5cdCAgICB2YXIgcmEsIHNhLCB2ciwgdmk7XG5cdCAgICB2YXIgbm90bGFzdCwgY2RpdnJlcztcblx0XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbm47IGkrKykge1xuXHQgICAgICAgIGlmIChpIDwgbG93IHx8IGkgPiBoaWdoKSB7XG5cdCAgICAgICAgICAgIGRbaV0gPSBIW2ldW2ldO1xuXHQgICAgICAgICAgICBlW2ldID0gMDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGZvciAoaiA9IE1hdGgubWF4KGkgLSAxLCAwKTsgaiA8IG5uOyBqKyspIHtcblx0ICAgICAgICAgICAgbm9ybSA9IG5vcm0gKyBNYXRoLmFicyhIW2ldW2pdKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgd2hpbGUgKG4gPj0gbG93KSB7XG5cdCAgICAgICAgbCA9IG47XG5cdCAgICAgICAgd2hpbGUgKGwgPiBsb3cpIHtcblx0ICAgICAgICAgICAgcyA9IE1hdGguYWJzKEhbbCAtIDFdW2wgLSAxXSkgKyBNYXRoLmFicyhIW2xdW2xdKTtcblx0ICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHMgPSBub3JtO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChNYXRoLmFicyhIW2xdW2wgLSAxXSkgPCBlcHMgKiBzKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsLS07XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAobCA9PT0gbikge1xuXHQgICAgICAgICAgICBIW25dW25dID0gSFtuXVtuXSArIGV4c2hpZnQ7XG5cdCAgICAgICAgICAgIGRbbl0gPSBIW25dW25dO1xuXHQgICAgICAgICAgICBlW25dID0gMDtcblx0ICAgICAgICAgICAgbi0tO1xuXHQgICAgICAgICAgICBpdGVyID0gMDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGwgPT09IG4gLSAxKSB7XG5cdCAgICAgICAgICAgIHcgPSBIW25dW24gLSAxXSAqIEhbbiAtIDFdW25dO1xuXHQgICAgICAgICAgICBwID0gKEhbbiAtIDFdW24gLSAxXSAtIEhbbl1bbl0pIC8gMjtcblx0ICAgICAgICAgICAgcSA9IHAgKiBwICsgdztcblx0ICAgICAgICAgICAgeiA9IE1hdGguc3FydChNYXRoLmFicyhxKSk7XG5cdCAgICAgICAgICAgIEhbbl1bbl0gPSBIW25dW25dICsgZXhzaGlmdDtcblx0ICAgICAgICAgICAgSFtuIC0gMV1bbiAtIDFdID0gSFtuIC0gMV1bbiAtIDFdICsgZXhzaGlmdDtcblx0ICAgICAgICAgICAgeCA9IEhbbl1bbl07XG5cdFxuXHQgICAgICAgICAgICBpZiAocSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB6ID0gKHAgPj0gMCkgPyAocCArIHopIDogKHAgLSB6KTtcblx0ICAgICAgICAgICAgICAgIGRbbiAtIDFdID0geCArIHo7XG5cdCAgICAgICAgICAgICAgICBkW25dID0gZFtuIC0gMV07XG5cdCAgICAgICAgICAgICAgICBpZiAoeiAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRbbl0gPSB4IC0gdyAvIHo7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlW24gLSAxXSA9IDA7XG5cdCAgICAgICAgICAgICAgICBlW25dID0gMDtcblx0ICAgICAgICAgICAgICAgIHggPSBIW25dW24gLSAxXTtcblx0ICAgICAgICAgICAgICAgIHMgPSBNYXRoLmFicyh4KSArIE1hdGguYWJzKHopO1xuXHQgICAgICAgICAgICAgICAgcCA9IHggLyBzO1xuXHQgICAgICAgICAgICAgICAgcSA9IHogLyBzO1xuXHQgICAgICAgICAgICAgICAgciA9IE1hdGguc3FydChwICogcCArIHEgKiBxKTtcblx0ICAgICAgICAgICAgICAgIHAgPSBwIC8gcjtcblx0ICAgICAgICAgICAgICAgIHEgPSBxIC8gcjtcblx0XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSBuIC0gMTsgaiA8IG5uOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB6ID0gSFtuIC0gMV1bal07XG5cdCAgICAgICAgICAgICAgICAgICAgSFtuIC0gMV1bal0gPSBxICogeiArIHAgKiBIW25dW2pdO1xuXHQgICAgICAgICAgICAgICAgICAgIEhbbl1bal0gPSBxICogSFtuXVtqXSAtIHAgKiB6O1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgeiA9IEhbaV1bbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIEhbaV1bbiAtIDFdID0gcSAqIHogKyBwICogSFtpXVtuXTtcblx0ICAgICAgICAgICAgICAgICAgICBIW2ldW25dID0gcSAqIEhbaV1bbl0gLSBwICogejtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgeiA9IFZbaV1bbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIFZbaV1bbiAtIDFdID0gcSAqIHogKyBwICogVltpXVtuXTtcblx0ICAgICAgICAgICAgICAgICAgICBWW2ldW25dID0gcSAqIFZbaV1bbl0gLSBwICogejtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRbbiAtIDFdID0geCArIHA7XG5cdCAgICAgICAgICAgICAgICBkW25dID0geCArIHA7XG5cdCAgICAgICAgICAgICAgICBlW24gLSAxXSA9IHo7XG5cdCAgICAgICAgICAgICAgICBlW25dID0gLXo7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIG4gPSBuIC0gMjtcblx0ICAgICAgICAgICAgaXRlciA9IDA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgeCA9IEhbbl1bbl07XG5cdCAgICAgICAgICAgIHkgPSAwO1xuXHQgICAgICAgICAgICB3ID0gMDtcblx0ICAgICAgICAgICAgaWYgKGwgPCBuKSB7XG5cdCAgICAgICAgICAgICAgICB5ID0gSFtuIC0gMV1bbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgdyA9IEhbbl1bbiAtIDFdICogSFtuIC0gMV1bbl07XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGlmIChpdGVyID09PSAxMCkge1xuXHQgICAgICAgICAgICAgICAgZXhzaGlmdCArPSB4O1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbaV1baV0gLT0geDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHMgPSBNYXRoLmFicyhIW25dW24gLSAxXSkgKyBNYXRoLmFicyhIW24gLSAxXVtuIC0gMl0pO1xuXHQgICAgICAgICAgICAgICAgeCA9IHkgPSAwLjc1ICogcztcblx0ICAgICAgICAgICAgICAgIHcgPSAtMC40Mzc1ICogcyAqIHM7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIGlmIChpdGVyID09PSAzMCkge1xuXHQgICAgICAgICAgICAgICAgcyA9ICh5IC0geCkgLyAyO1xuXHQgICAgICAgICAgICAgICAgcyA9IHMgKiBzICsgdztcblx0ICAgICAgICAgICAgICAgIGlmIChzID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQocyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCB4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAtcztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcyA9IHggLSB3IC8gKCh5IC0geCkgLyAyICsgcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IG47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBIW2ldW2ldIC09IHM7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGV4c2hpZnQgKz0gcztcblx0ICAgICAgICAgICAgICAgICAgICB4ID0geSA9IHcgPSAwLjk2NDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaXRlciA9IGl0ZXIgKyAxO1xuXHRcblx0ICAgICAgICAgICAgbSA9IG4gLSAyO1xuXHQgICAgICAgICAgICB3aGlsZSAobSA+PSBsKSB7XG5cdCAgICAgICAgICAgICAgICB6ID0gSFttXVttXTtcblx0ICAgICAgICAgICAgICAgIHIgPSB4IC0gejtcblx0ICAgICAgICAgICAgICAgIHMgPSB5IC0gejtcblx0ICAgICAgICAgICAgICAgIHAgPSAociAqIHMgLSB3KSAvIEhbbSArIDFdW21dICsgSFttXVttICsgMV07XG5cdCAgICAgICAgICAgICAgICBxID0gSFttICsgMV1bbSArIDFdIC0geiAtIHIgLSBzO1xuXHQgICAgICAgICAgICAgICAgciA9IEhbbSArIDJdW20gKyAxXTtcblx0ICAgICAgICAgICAgICAgIHMgPSBNYXRoLmFicyhwKSArIE1hdGguYWJzKHEpICsgTWF0aC5hYnMocik7XG5cdCAgICAgICAgICAgICAgICBwID0gcCAvIHM7XG5cdCAgICAgICAgICAgICAgICBxID0gcSAvIHM7XG5cdCAgICAgICAgICAgICAgICByID0gciAvIHM7XG5cdCAgICAgICAgICAgICAgICBpZiAobSA9PT0gbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhbbV1bbSAtIDFdKSAqIChNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpKSA8IGVwcyAqIChNYXRoLmFicyhwKSAqIChNYXRoLmFicyhIW20gLSAxXVttIC0gMV0pICsgTWF0aC5hYnMoeikgKyBNYXRoLmFicyhIW20gKyAxXVttICsgMV0pKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG0tLTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZm9yIChpID0gbSArIDI7IGkgPD0gbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBIW2ldW2kgLSAyXSA9IDA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA+IG0gKyAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtpXVtpIC0gM10gPSAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBmb3IgKGsgPSBtOyBrIDw9IG4gLSAxOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgIG5vdGxhc3QgPSAoayAhPT0gbiAtIDEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGsgIT09IG0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBwID0gSFtrXVtrIC0gMV07XG5cdCAgICAgICAgICAgICAgICAgICAgcSA9IEhbayArIDFdW2sgLSAxXTtcblx0ICAgICAgICAgICAgICAgICAgICByID0gKG5vdGxhc3QgPyBIW2sgKyAyXVtrIC0gMV0gOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5hYnMocCkgKyBNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh4ICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwIC8geDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHEgLyB4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByID0gciAvIHg7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGlmICh4ID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgcyA9IE1hdGguc3FydChwICogcCArIHEgKiBxICsgciAqIHIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHAgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcyA9IC1zO1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGlmIChzICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IG0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgSFtrXVtrIC0gMV0gPSAtcyAqIHg7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsICE9PSBtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEhba11bayAtIDFdID0gLUhba11bayAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgcCA9IHAgKyBzO1xuXHQgICAgICAgICAgICAgICAgICAgIHggPSBwIC8gcztcblx0ICAgICAgICAgICAgICAgICAgICB5ID0gcSAvIHM7XG5cdCAgICAgICAgICAgICAgICAgICAgeiA9IHIgLyBzO1xuXHQgICAgICAgICAgICAgICAgICAgIHEgPSBxIC8gcDtcblx0ICAgICAgICAgICAgICAgICAgICByID0gciAvIHA7XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGs7IGogPCBubjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBIW2tdW2pdICsgcSAqIEhbayArIDFdW2pdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90bGFzdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAgKyByICogSFtrICsgMl1bal07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2sgKyAyXVtqXSA9IEhbayArIDJdW2pdIC0gcCAqIHo7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEhba11bal0gPSBIW2tdW2pdIC0gcCAqIHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEhbayArIDFdW2pdID0gSFtrICsgMV1bal0gLSBwICogeTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gTWF0aC5taW4obiwgayArIDMpOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHggKiBIW2ldW2tdICsgeSAqIEhbaV1bayArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90bGFzdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAgKyB6ICogSFtpXVtrICsgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2ldW2sgKyAyXSA9IEhbaV1bayArIDJdIC0gcCAqIHI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1ba10gPSBIW2ldW2tdIC0gcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtrICsgMV0gPSBIW2ldW2sgKyAxXSAtIHAgKiBxO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwID0geCAqIFZbaV1ba10gKyB5ICogVltpXVtrICsgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RsYXN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcCArIHogKiBWW2ldW2sgKyAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZbaV1bayArIDJdID0gVltpXVtrICsgMl0gLSBwICogcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVltpXVtrXSA9IFZbaV1ba10gLSBwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBWW2ldW2sgKyAxXSA9IFZbaV1bayArIDFdIC0gcCAqIHE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmIChub3JtID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHRcblx0ICAgIGZvciAobiA9IG5uIC0gMTsgbiA+PSAwOyBuLS0pIHtcblx0ICAgICAgICBwID0gZFtuXTtcblx0ICAgICAgICBxID0gZVtuXTtcblx0XG5cdCAgICAgICAgaWYgKHEgPT09IDApIHtcblx0ICAgICAgICAgICAgbCA9IG47XG5cdCAgICAgICAgICAgIEhbbl1bbl0gPSAxO1xuXHQgICAgICAgICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIHcgPSBIW2ldW2ldIC0gcDtcblx0ICAgICAgICAgICAgICAgIHIgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yIChqID0gbDsgaiA8PSBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICByID0gciArIEhbaV1bal0gKiBIW2pdW25dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgIGlmIChlW2ldIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHogPSB3O1xuXHQgICAgICAgICAgICAgICAgICAgIHMgPSByO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBsID0gaTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZVtpXSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBIW2ldW25dID0gKHcgIT09IDApID8gKC1yIC8gdykgOiAoLXIgLyAoZXBzICogbm9ybSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggPSBIW2ldW2kgKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IEhbaSArIDFdW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBxID0gKGRbaV0gLSBwKSAqIChkW2ldIC0gcCkgKyBlW2ldICogZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh4ICogcyAtIHogKiByKSAvIHE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSB0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuXSA9IChNYXRoLmFicyh4KSA+IE1hdGguYWJzKHopKSA/ICgoLXIgLSB3ICogdCkgLyB4KSA6ICgoLXMgLSB5ICogdCkgLyB6KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgICAgIHQgPSBNYXRoLmFicyhIW2ldW25dKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKGVwcyAqIHQpICogdCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbal1bbl0gPSBIW2pdW25dIC8gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAocSA8IDApIHtcblx0ICAgICAgICAgICAgbCA9IG4gLSAxO1xuXHRcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKEhbbl1bbiAtIDFdKSA+IE1hdGguYWJzKEhbbiAtIDFdW25dKSkge1xuXHQgICAgICAgICAgICAgICAgSFtuIC0gMV1bbiAtIDFdID0gcSAvIEhbbl1bbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgSFtuIC0gMV1bbl0gPSAtKEhbbl1bbl0gLSBwKSAvIEhbbl1bbiAtIDFdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoMCwgLUhbbiAtIDFdW25dLCBIW24gLSAxXVtuIC0gMV0gLSBwLCBxKTtcblx0ICAgICAgICAgICAgICAgIEhbbiAtIDFdW24gLSAxXSA9IGNkaXZyZXNbMF07XG5cdCAgICAgICAgICAgICAgICBIW24gLSAxXVtuXSA9IGNkaXZyZXNbMV07XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIEhbbl1bbiAtIDFdID0gMDtcblx0ICAgICAgICAgICAgSFtuXVtuXSA9IDE7XG5cdCAgICAgICAgICAgIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgcmEgPSAwO1xuXHQgICAgICAgICAgICAgICAgc2EgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yIChqID0gbDsgaiA8PSBuOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICByYSA9IHJhICsgSFtpXVtqXSAqIEhbal1bbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIHNhID0gc2EgKyBIW2ldW2pdICogSFtqXVtuXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgICAgICB3ID0gSFtpXVtpXSAtIHA7XG5cdFxuXHQgICAgICAgICAgICAgICAgaWYgKGVbaV0gPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgeiA9IHc7XG5cdCAgICAgICAgICAgICAgICAgICAgciA9IHJhO1xuXHQgICAgICAgICAgICAgICAgICAgIHMgPSBzYTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbCA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVbaV0gPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoLXJhLCAtc2EsIHcsIHEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBIW2ldW24gLSAxXSA9IGNkaXZyZXNbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIEhbaV1bbl0gPSBjZGl2cmVzWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggPSBIW2ldW2kgKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IEhbaSArIDFdW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2ciA9IChkW2ldIC0gcCkgKiAoZFtpXSAtIHApICsgZVtpXSAqIGVbaV0gLSBxICogcTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmkgPSAoZFtpXSAtIHApICogMiAqIHE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ciA9PT0gMCAmJiB2aSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdnIgPSBlcHMgKiBub3JtICogKE1hdGguYWJzKHcpICsgTWF0aC5hYnMocSkgKyBNYXRoLmFicyh4KSArIE1hdGguYWJzKHkpICsgTWF0aC5hYnMoeikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNkaXZyZXMgPSBjZGl2KHggKiByIC0geiAqIHJhICsgcSAqIHNhLCB4ICogcyAtIHogKiBzYSAtIHEgKiByYSwgdnIsIHZpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgSFtpXVtuIC0gMV0gPSBjZGl2cmVzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBIW2ldW25dID0gY2RpdnJlc1sxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgpID4gKE1hdGguYWJzKHopICsgTWF0aC5hYnMocSkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuIC0gMV0gPSAoLXJhIC0gdyAqIEhbaV1bbiAtIDFdICsgcSAqIEhbaV1bbl0pIC8geDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbaSArIDFdW25dID0gKC1zYSAtIHcgKiBIW2ldW25dIC0gcSAqIEhbaV1bbiAtIDFdKSAvIHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZGl2cmVzID0gY2RpdigtciAtIHkgKiBIW2ldW24gLSAxXSwgLXMgLSB5ICogSFtpXVtuXSwgeiwgcSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2kgKyAxXVtuIC0gMV0gPSBjZGl2cmVzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgSFtpICsgMV1bbl0gPSBjZGl2cmVzWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5tYXgoTWF0aC5hYnMoSFtpXVtuIC0gMV0pLCBNYXRoLmFicyhIW2ldW25dKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKChlcHMgKiB0KSAqIHQgPiAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gbjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBIW2pdW24gLSAxXSA9IEhbal1bbiAtIDFdIC8gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhbal1bbl0gPSBIW2pdW25dIC8gdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbm47IGkrKykge1xuXHQgICAgICAgIGlmIChpIDwgbG93IHx8IGkgPiBoaWdoKSB7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPCBubjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBWW2ldW2pdID0gSFtpXVtqXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKGogPSBubiAtIDE7IGogPj0gbG93OyBqLS0pIHtcblx0ICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHogPSAwO1xuXHQgICAgICAgICAgICBmb3IgKGsgPSBsb3c7IGsgPD0gTWF0aC5taW4oaiwgaGlnaCk7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgeiA9IHogKyBWW2ldW2tdICogSFtrXVtqXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBWW2ldW2pdID0gejtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNkaXYoeHIsIHhpLCB5ciwgeWkpIHtcblx0ICAgIHZhciByLCBkO1xuXHQgICAgaWYgKE1hdGguYWJzKHlyKSA+IE1hdGguYWJzKHlpKSkge1xuXHQgICAgICAgIHIgPSB5aSAvIHlyO1xuXHQgICAgICAgIGQgPSB5ciArIHIgKiB5aTtcblx0ICAgICAgICByZXR1cm4gWyh4ciArIHIgKiB4aSkgLyBkLCAoeGkgLSByICogeHIpIC8gZF07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHIgPSB5ciAvIHlpO1xuXHQgICAgICAgIGQgPSB5aSArIHIgKiB5cjtcblx0ICAgICAgICByZXR1cm4gWyhyICogeHIgKyB4aSkgLyBkLCAociAqIHhpIC0geHIpIC8gZF07XG5cdCAgICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBAY2xhc3MgQ2hvbGVza3lEZWNvbXBvc2l0aW9uXG5cdCAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sdXR6cm9lZGVyL01hcGFjay9ibG9iL21hc3Rlci9Tb3VyY2UvQ2hvbGVza3lEZWNvbXBvc2l0aW9uLmNzXG5cdCAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZVxuXHQgKi9cblx0Y2xhc3MgQ2hvbGVza3lEZWNvbXBvc2l0aW9uJCQxIHtcblx0ICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgodmFsdWUpO1xuXHQgICAgICAgIGlmICghdmFsdWUuaXNTeW1tZXRyaWMoKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBpcyBub3Qgc3ltbWV0cmljJyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB2YXIgYSA9IHZhbHVlO1xuXHQgICAgICAgIHZhciBkaW1lbnNpb24gPSBhLnJvd3M7XG5cdCAgICAgICAgdmFyIGwgPSBuZXcgTWF0cml4KGRpbWVuc2lvbiwgZGltZW5zaW9uKTtcblx0ICAgICAgICB2YXIgcG9zaXRpdmVEZWZpbml0ZSA9IHRydWU7XG5cdCAgICAgICAgdmFyIGksIGosIGs7XG5cdFxuXHQgICAgICAgIGZvciAoaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuXHQgICAgICAgICAgICB2YXIgTHJvd2ogPSBsW2pdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IDA7XG5cdCAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBqOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBMcm93ayA9IGxba107XG5cdCAgICAgICAgICAgICAgICB2YXIgcyA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgazsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcyArPSBMcm93a1tpXSAqIExyb3dqW2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgTHJvd2pba10gPSBzID0gKGEuZ2V0KGosIGspIC0gcykgLyBsW2tdW2tdO1xuXHQgICAgICAgICAgICAgICAgZCA9IGQgKyBzICogcztcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgZCA9IGEuZ2V0KGosIGopIC0gZDtcblx0XG5cdCAgICAgICAgICAgIHBvc2l0aXZlRGVmaW5pdGUgJj0gKGQgPiAwKTtcblx0ICAgICAgICAgICAgbFtqXVtqXSA9IE1hdGguc3FydChNYXRoLm1heChkLCAwKSk7XG5cdCAgICAgICAgICAgIGZvciAoayA9IGogKyAxOyBrIDwgZGltZW5zaW9uOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgIGxbal1ba10gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoIXBvc2l0aXZlRGVmaW5pdGUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IHBvc2l0aXZlIGRlZmluaXRlJyk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB0aGlzLkwgPSBsO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7TWF0cml4fSB2YWx1ZVxuXHQgICAgICogQHJldHVybiB7TWF0cml4fVxuXHQgICAgICovXG5cdCAgICBzb2x2ZSh2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KHZhbHVlKTtcblx0XG5cdCAgICAgICAgdmFyIGwgPSB0aGlzLkw7XG5cdCAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGwucm93cztcblx0XG5cdCAgICAgICAgaWYgKHZhbHVlLnJvd3MgIT09IGRpbWVuc2lvbikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaCcpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdmFyIGNvdW50ID0gdmFsdWUuY29sdW1ucztcblx0ICAgICAgICB2YXIgQiA9IHZhbHVlLmNsb25lKCk7XG5cdCAgICAgICAgdmFyIGksIGosIGs7XG5cdFxuXHQgICAgICAgIGZvciAoayA9IDA7IGsgPCBkaW1lbnNpb247IGsrKykge1xuXHQgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGs7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIEJba11bal0gLT0gQltpXVtqXSAqIGxba11baV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBCW2tdW2pdIC89IGxba11ba107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGZvciAoayA9IGRpbWVuc2lvbiAtIDE7IGsgPj0gMDsgay0tKSB7XG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgQltrXVtqXSAtPSBCW2ldW2pdICogbFtpXVtrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIEJba11bal0gLz0gbFtrXVtrXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIEI7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7TWF0cml4fVxuXHQgICAgICovXG5cdCAgICBnZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLkw7XG5cdCAgICB9XG5cdH1cblx0XG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IE1hdHJpeDtcblx0ZXhwb3J0cy5NYXRyaXggPSBNYXRyaXg7XG5cdGV4cG9ydHMuYWJzdHJhY3RNYXRyaXggPSBBYnN0cmFjdE1hdHJpeDtcblx0ZXhwb3J0cy53cmFwID0gd3JhcDtcblx0ZXhwb3J0cy5XcmFwcGVyTWF0cml4MkQgPSBXcmFwcGVyTWF0cml4MkQ7XG5cdGV4cG9ydHMuV3JhcHBlck1hdHJpeDFEID0gV3JhcHBlck1hdHJpeDFEO1xuXHRleHBvcnRzLnNvbHZlID0gc29sdmUkJDE7XG5cdGV4cG9ydHMuaW52ZXJzZSA9IGludmVyc2UkJDE7XG5cdGV4cG9ydHMuU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24gPSBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiQkMTtcblx0ZXhwb3J0cy5TVkQgPSBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiQkMTtcblx0ZXhwb3J0cy5FaWdlbnZhbHVlRGVjb21wb3NpdGlvbiA9IEVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uJCQxO1xuXHRleHBvcnRzLkVWRCA9IEVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uJCQxO1xuXHRleHBvcnRzLkNob2xlc2t5RGVjb21wb3NpdGlvbiA9IENob2xlc2t5RGVjb21wb3NpdGlvbiQkMTtcblx0ZXhwb3J0cy5DSE8gPSBDaG9sZXNreURlY29tcG9zaXRpb24kJDE7XG5cdGV4cG9ydHMuTHVEZWNvbXBvc2l0aW9uID0gTHVEZWNvbXBvc2l0aW9uJCQxO1xuXHRleHBvcnRzLkxVID0gTHVEZWNvbXBvc2l0aW9uJCQxO1xuXHRleHBvcnRzLlFyRGVjb21wb3NpdGlvbiA9IFFyRGVjb21wb3NpdGlvbiQkMTtcblx0ZXhwb3J0cy5RUiA9IFFyRGVjb21wb3NpdGlvbiQkMTtcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cdFxuXHR2YXIgbWF4ID0gX2ludGVyb3BEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjIpKTtcblx0dmFyIG1pbiA9IF9pbnRlcm9wRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSk7XG5cdFxuXHRmdW5jdGlvbiByZXNjYWxlKGlucHV0LCBvcHRpb25zID0ge30pIHtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IGJlIGFuIGFycmF5Jyk7XG5cdCAgICB9IGVsc2UgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG5cdCAgICB9XG5cdFxuXHQgICAgbGV0IG91dHB1dDtcblx0ICAgIGlmIChvcHRpb25zLm91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvdXRwdXQgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXkgaWYgc3BlY2lmaWVkJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG91dHB1dCA9IG9wdGlvbnMub3V0cHV0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKTtcblx0ICAgIH1cblx0XG5cdCAgICBjb25zdCBjdXJyZW50TWluID0gbWluKGlucHV0KTtcblx0ICAgIGNvbnN0IGN1cnJlbnRNYXggPSBtYXgoaW5wdXQpO1xuXHRcblx0ICAgIGlmIChjdXJyZW50TWluID09PSBjdXJyZW50TWF4KSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheScpO1xuXHQgICAgfVxuXHRcblx0ICAgIGNvbnN0IHtcblx0ICAgICAgICBtaW46IG1pblZhbHVlID0gb3B0aW9ucy5hdXRvTWluTWF4ID8gY3VycmVudE1pbiA6IDAsXG5cdCAgICAgICAgbWF4OiBtYXhWYWx1ZSA9IG9wdGlvbnMuYXV0b01pbk1heCA/IGN1cnJlbnRNYXggOiAxXG5cdCAgICB9ID0gb3B0aW9ucztcblx0XG5cdCAgICBpZiAobWluVmFsdWUgPj0gbWF4VmFsdWUpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWluIG9wdGlvbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggb3B0aW9uJyk7XG5cdCAgICB9XG5cdFxuXHQgICAgY29uc3QgZmFjdG9yID0gKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gKGN1cnJlbnRNYXggLSBjdXJyZW50TWluKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBvdXRwdXRbaV0gPSAoaW5wdXRbaV0gLSBjdXJyZW50TWluKSAqIGZhY3RvciArIG1pblZhbHVlO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBvdXRwdXQ7XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gcmVzY2FsZTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIG9mIHRoZSBnaXZlbiB2YWx1ZXNcblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXgoaW5wdXQpIHtcblx0ICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYW4gYXJyYXknKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuXHQgICAgfVxuXHRcblx0ICAgIHZhciBtYXggPSBpbnB1dFswXTtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoaW5wdXRbaV0gPiBtYXgpIG1heCA9IGlucHV0W2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1heDtcblx0fVxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBtYXg7XG5cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgbWluaW11bSBvZiB0aGUgZ2l2ZW4gdmFsdWVzXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXRcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gbWluKGlucHV0KSB7XG5cdCAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIGFuIGFycmF5Jyk7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBub3QgYmUgZW1wdHknKTtcblx0ICAgIH1cblx0XG5cdCAgICB2YXIgbWluID0gaW5wdXRbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGlucHV0W2ldIDwgbWluKSBtaW4gPSBpbnB1dFtpXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtaW47XG5cdH1cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gbWluO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQ29weXJpZ2h0IChjKSAyMDE3LCBIZWxpa2FyIExhYi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEF1dGhvcjogUmVuYXRvIEZhYmJyaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHQvLyBpbnNwaXJlZCBpbiBNYXRsYWIgaW1wbGVtZW50YXRpb25cblx0Ly8gYW5kIEpTIHRyYW5zY3JpcHRpb24gaW5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FsYW5tZWVzb24vc3BlY3RyYWwtZ3JhcGgtbGF5b3V0XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMpIHtcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBub2Rlcztcblx0ICAgICAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuXHQgICAgICAgIHRoaXMuX2Vwc2lsb24gPSAxZS04OyAvLyB0b2xlcmFuY2Vcblx0ICAgICAgICB0aGlzLl9NQVhfSVRURVJBVElPTlMgPSAxMDA7IC8vV2UgdXNlIHBvd2VyIGl0ZXJhdGlvbiwgdGhpcyBpcyBhbmFsb2dvdXMgdG8gd2FsbCB0aW1lIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLlxuXHQgICAgICAgIHRoaXMuX251bV9lbGVtZW50cyA9IG5vZGVzLmxlbmd0aDsgLy9udW1iZXIgb2Ygbm9kZXMgaW4gZ3JhcGhcblx0ICAgICAgICB0aGlzLl9kaW1zID0gMjtcblx0ICAgIH1cblx0XG5cdCAgICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBbe1xuXHQgICAgICAgIGtleTogJ2FwcGx5Jyxcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG5cdCAgICAgICAgICAgIHZhciBBID0gKDAsIF91dGlscy5jcmVhdGUyZEFycmF5KSh0aGlzLl9ub2Rlcy5sZW5ndGgsIHRoaXMuX25vZGVzLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSBhZGphY2VuY3kgbWF0cml4XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpaSA9IHRoaXMuX2VkZ2VzW2ldLnNvdXJjZS5pbmRleDtcblx0ICAgICAgICAgICAgICAgIHZhciBqID0gdGhpcy5fZWRnZXNbaV0udGFyZ2V0LmluZGV4O1xuXHQgICAgICAgICAgICAgICAgQVtpaV1bal0gPSAxOyAvLyBub3QgY29uc2lkZXJpbmcgZWRnZSB3ZWlnaHQgZm9yIG5vdyAodGhlIGV4YW1wbGUganNvbiBmaWxlcyBkb24ndCBoYXZlIHdlaWdodClcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgRCA9IGRlZyhBKTsgLy9kZWdyZWUgb2YgZWFjaCBub2RlIGluIGdyYXBoIChudW1iZXIgb2YgY29ubmVjdGlvbnMpLlxuXHRcblx0ICAgICAgICAgICAgdmFyIGRpbXMgPSB0aGlzLl9kaW1zICsgMTsgLy9hZGQgb25lIHRvIHRoZSBkaW1zIHRvIGFsbG93IGZvciB0aGUgZmlyc3QgZWlnZW4gdmVjdG9yXG5cdCAgICAgICAgICAgIHZhciB1ID0gbmV3IEFycmF5KGRpbXMpOyAvL2RlY2xhcmUgdGhlIGVpZ2VuIHZlY3RvciBtYXRyaXhcblx0ICAgICAgICAgICAgdVswXSA9IG5vcm1hbGl6ZShvbmVzKHRoaXMuX251bV9lbGVtZW50cykpOyAvL2NyZWF0ZSAmIG5vcm1hbGl6ZSB0aGUgZmlyc3QgZWlnZW4gdmVjdG9yXG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBkaW1zOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB1W19pXSA9IHplcm9zKHRoaXMuX251bV9lbGVtZW50cyk7XG5cdCAgICAgICAgICAgIH0gLy9jcmVhdGUgZW1wdHkgc3BhY2UgZm9yIHRoZSBvdGhlciBlaWdlbiB2ZWN0b3JzXG5cdFxuXHQgICAgICAgICAgICAvL1Bvd2VyIGl0ZXJhdGlvbiB0byBkZXRlcm1pbmUgdGhlIHJlbWFpbmluZyBlaWdlbiB2ZWN0b3JzLlxuXHQgICAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IGRpbXM7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgLy9mb3IgZWFjaCBlaWdlbiB2ZWN0b3IgYWZ0ZXIgdGhlIGZpcnN0LCBcblx0ICAgICAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSBlaWdlbiB2ZWN0b3Igd2l0aCByYW5kb20gdmFsdWVzXG5cdCAgICAgICAgICAgICAgICB2YXIgdWhrID0gbm9ybWFsaXplKHJhbmQodGhpcy5fbnVtX2VsZW1lbnRzKSk7XG5cdFxuXHQgICAgICAgICAgICAgICAgdmFyIGl0dF9jb3VudCA9IDA7IC8vd2UgYXJlIGFsbG93aW5nIGEgbWF4IG9mIDEwMCBpdGVyYXRpb25zLCB0byBhdm9pZCBoYW5naW5nIGFuZCBpbmZpbml0ZSBsb29wcy4gKHNwZWNpZmllZCBhYm92ZSBpbiBjb25zdGFudHMpXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IGZhbHNlOyAvL3N0b3BwaW5nIGNyaXRlcmlvbiBmbGFnLlxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKCFzdG9wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZG8uLi53aGlsZSB1c2luZyBmbGFncyB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCBteSBtYXRsYWIgaW1wbGVtZW50YXRpb25cblx0XG5cdCAgICAgICAgICAgICAgICAgICAgLy9ELW9ydGhvZ29uYWxpemUgYWdhaW5zdCBwcmV2aW91cyBlaWdlbnZlY3RvcnNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdWsgPSB1aGsuc2xpY2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGs7IGwrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWwgPSB1W2xdOyAvL2V4dHJhY3QgdGhlIGwtdGggZWlnZW4gdmVjdG9yXG5cdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL0NhbGN1bGF0ZSAodWsnLkQudWwpLyh1bCcuRC51bClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8gPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdm1pID0gMDsgdm1pIDwgdWsubGVuZ3RoOyB2bWkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wXyArPSB1a1t2bWldICogRFt2bWldICogdWxbdm1pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSArPSB1bFt2bWldICogRFt2bWldICogdWxbdm1pXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSB0b3BfIC8gYm90dG9tO1xuXHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy91ayA9IHVrIC0gKCh1aycgLiBEIC4gdWwpIC8gKHVsJyAuIEQgdWwpKSAuIHVsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHZzaSA9IDA7IHZzaSA8IHVrLmxlbmd0aDsgdnNpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVrW3ZzaV0gPSB1a1t2c2ldIC0gcmF0aW8gKiB1bFt2c2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgICAgICAvL211bHRpcGx5IHdpdGggLjUoSStEXi0xIEEpXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdWhrLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdWhrW19pMl0gPSAwLjUgKiAodWtbX2kyXSArIGRvdChBW19pMl0sIHVrKSAvIERbX2kyXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgICAgICAgICB1aGsgPSBub3JtYWxpemUodWhrKTtcblx0XG5cdCAgICAgICAgICAgICAgICAgICAgaXR0X2NvdW50ID0gaXR0X2NvdW50ICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICBzdG9wID0gaXR0X2NvdW50ID4gMTAwIHwgIShkb3QodWhrLCB1aykgPCAxIC0gdGhpcy5fZXBzaWxvbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB1W2tdID0gdWhrLnNsaWNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIC8vZGlzY2FyZCB0aGUgZmlyc3QgZWlnZW52ZWN0b3Igd2hpY2ggc2hvdWxkIGJlIFtvbmVzXS5cblx0ICAgICAgICAgICAgLy8gdmFyIHYgPSBuZXcgQXJyYXkodS5sZW5ndGgpO1xuXHQgICAgICAgICAgICAvLyBmb3IgKHZhciBpPTA7IGkgPCB1Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vICAgICB2W2ldID0gbmV3IEFycmF5KHVbaV0ubGVuZ3RoKTtcblx0ICAgICAgICAgICAgLy8gICAgIGZvciAodmFyIGo9MDsgaiA8IHVbaV0ubGVuZ3RoOyBqKyspIHZbaV1bal0gPSB1W2ldW2pdO1xuXHQgICAgICAgICAgICAvLyB9XG5cdCAgICAgICAgICAgIHZhciB4ID0gbm9ybWFsaXplMih1WzFdKTtcblx0ICAgICAgICAgICAgdmFyIHkgPSBub3JtYWxpemUyKHVbMl0pO1xuXHQgICAgICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnggPSB4W2ldO1xuXHQgICAgICAgICAgICAgICAgbm9kZS55ID0geVtpXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfV0pO1xuXHRcblx0ICAgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXHRcblx0ZnVuY3Rpb24gZGVnKGdyYXBoKSB7XG5cdCAgICAvL0NhbGN1bGF0ZSB0aGUgZGVncmVlIG9mIGVhY2ggbm9kZSBmcm9tIHRoZSBncmFwaCBtYXRyaXguXG5cdCAgICB2YXIgZCA9IHplcm9zKGdyYXBoLmxlbmd0aCk7XG5cdFxuXHQgICAgLy9kZWdyZWUgb2Ygbm9kZSBpIGlzIHRoZSBzdW0gb2YgdGhlIHdlaWdodHMgb2YgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byBpdC5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgbm9kZV9kZWdyZWUgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGhbaV0ubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgbm9kZV9kZWdyZWUgKz0gZ3JhcGhbaV1bal07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRbaV0gPSBub2RlX2RlZ3JlZSArIDE7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGRvdChhLCBiKSB7XG5cdCAgICAvL2lubmVyIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcblx0ICAgIHZhciBkID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGQgKz0gYVtpXSAqIGJbaV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZXVjbGlkZWFuRGlzdGFuY2UoY29vcmRpbmF0ZXMpIHtcblx0ICAgIC8vY2FsY3VsYXRlIHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzL3ZlY3RvcnMuXG5cdCAgICAvLyB1c2VkIGZvciBub3JtYWxpemF0aW9uLlxuXHQgICAgdmFyIGQgPSAwO1xuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBkICs9IE1hdGgucG93KGNvb3JkaW5hdGVzW2ldLCAyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBNYXRoLnNxcnQoZCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcnIpIHtcblx0ICAgIC8vbm9ybWFsaXplcyBhIHZlY3RvciA9IGFyci98fGFycnx8XG5cdCAgICB2YXIgZCA9IGV1Y2xpZGVhbkRpc3RhbmNlKGFycik7XG5cdCAgICB2YXIgbmFyciA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgbmFycltpXSA9IGFycltpXSAvIGQ7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIG5hcnI7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJhbmQobikge1xuXHQgICAgLy9jcmVhdGUgYSB2ZWN0b3Igb2YgbGVuZ3RoIG4gYW5kIGZpbGwgd2l0aCByYW5kb20gbnVtYmVycy5cblx0ICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIGFycltpXSA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICB9cmV0dXJuIGFycjtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYWRkKGEsIGIpIHtcblx0ICAgIHZhciBjID0gbmV3IEFycmF5KGEubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGNbaV0gPSBuZXcgQXJyYXkoYVtpXS5sZW5ndGgpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYVtpXS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICBjW2ldW2pdID0gYVtpXVtqXSArIGJbaV1bal07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGM7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHN5bW1ldHJpY1JhbmRNYXRyaXgobiwgdWxpbSkge1xuXHQgICAgdmFyIG1hdCA9IG5ldyBBcnJheShuKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgbWF0W2ldID0gbmV3IEFycmF5KG4pO1xuXHQgICAgICAgIG1hdFtpXVtpXSA9IDA7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuOyBfaTMrKykge1xuXHQgICAgICAgIGZvciAodmFyIGogPSBfaTMgKyAxOyBqIDwgbjsgaisrKSB7XG5cdCAgICAgICAgICAgIG1hdFtfaTNdW2pdID0gdWxpbSAqIE1hdGgucmFuZG9tKCk7XG5cdCAgICAgICAgICAgIG1hdFtqXVtfaTNdID0gbWF0W19pM11bal07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1hdDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gemVyb3Mobikge1xuXHQgICAgLy9jcmVhdGUgYSB2ZWN0b3IgZmlsbGVkIHdpdGggemVyb3Ncblx0ICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIGFycltpXSA9IDA7XG5cdCAgICB9cmV0dXJuIGFycjtcblx0fVxuXHRcblx0ZnVuY3Rpb24gb25lcyhuKSB7XG5cdCAgICAvL2NyZWF0ZSBhIHZlY3RvciBmaWxsZWQgd2l0aCBvbmVzXG5cdCAgICB2YXIgYXJyID0gbmV3IEFycmF5KG4pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICBhcnJbaV0gPSAxO1xuXHQgICAgfXJldHVybiBhcnI7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZTIoeCkge1xuXHQgICAgdmFyIG1heHggPSBNYXRoLm1heC5hcHBseShudWxsLCB4Lm1hcChNYXRoLmFicykpO1xuXHQgICAgdmFyIG1pbnggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIHhbaV0gPSAwLjEgKyAoeFtpXSAtIG1pbngpIC8gKChtYXh4IC0gbWlueCkgKiAxLjI1KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB4O1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQ29weXJpZ2h0IChjKSAyMDE3LCBIZWxpa2FyIExhYi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEF1dGhvcjogUmVuYXRvIEZhYmJyaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIGdldCBkZWdyZWUgb2YgYWxsIG5vZGVzXG5cdCAgICBmdW5jdGlvbiBfY2xhc3Mobm9kZXMsIGVkZ2VzKSB7XG5cdCAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cdFxuXHQgICAgICAgIHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdCAgICAgICAgdGhpcy5fZWRnZXMgPSBlZGdlcztcblx0ICAgICAgICB0aGlzLl9tYXJnaW4gPSAwLjA1OyAvLyBmcm9tIFswLDFdIGJvcmRlcnNcblx0ICAgICAgICB0aGlzLl9yYWRpdXMgPSAwLjA1OyAvLyBvZiB0aGUgZW1wdHkgY2lyY2xlIG9uIHRoZSBjZW50ZXJcblx0ICAgICAgICB0aGlzLl9ubGluZXMgPSA1O1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiAnYXBwbHknLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseSgpIHtcblx0ICAgICAgICAgICAgdmFyIG5kID0gKDAsIF91dGlscy5kZWdyZWVzKSh0aGlzLl9ub2RlcywgdGhpcy5fZWRnZXMpO1xuXHQgICAgICAgICAgICB2YXIgbm9kZXNfc2VnbWVudCA9IHRoaXMuX25vZGVzLmxlbmd0aCAvIHRoaXMuX25saW5lcztcblx0ICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSAwLjUgLSAodGhpcy5fbWFyZ2luICsgdGhpcy5fcmFkaXVzKTtcblx0ICAgICAgICAgICAgdmFyIHN0ZXAgPSBzZWdtZW50IC8gbm9kZXNfc2VnbWVudDtcblx0ICAgICAgICAgICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgLyB0aGlzLl9ubGluZXM7XG5cdCAgICAgICAgICAgIHZhciBqID0gMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlpID0gbmQubm9kZXNbaV0uaW5kZXg7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc1tpaV0ueCA9IDAuNSArICh0aGlzLl9yYWRpdXMgKyBzdGVwICogKGkgLSBqICogbm9kZXNfc2VnbWVudCkpICogTWF0aC5jb3MoYW5nbGUgKiBqICsgTWF0aC5QSSAvIDIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNbaWldLnkgPSAwLjUgKyAodGhpcy5fcmFkaXVzICsgc3RlcCAqIChpIC0gaiAqIG5vZGVzX3NlZ21lbnQpKSAqIE1hdGguc2luKGFuZ2xlICogaiArIE1hdGguUEkgLyAyKTtcblx0ICAgICAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKGkgLyBub2Rlc19zZWdtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1dKTtcblx0XG5cdCAgICByZXR1cm4gX2NsYXNzO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBfY2xhc3M7XG5cdDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgIGZ1bmN0aW9uIF9jbGFzcyhub2RlcywgZWRnZXMpIHtcblx0ICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHRcblx0ICAgICAgICAgIHRoaXMuX25vZGVzID0gbm9kZXM7XG5cdCAgICAgICAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuXHQgICAgICAgICAgdGhpcy5fbWFyZ2luID0gMC4wNTtcblx0ICAgICB9XG5cdFxuXHQgICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAgICBrZXk6ICdhcHBseScsXG5cdCAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG5cdCAgICAgICAgICAgICAgIHZhciBuZCA9ICgwLCBfdXRpbHMuZGVncmVlcykodGhpcy5fbm9kZXMsIHRoaXMuX2VkZ2VzKTtcblx0ICAgICAgICAgICAgICAgdmFyIHNxID0gTWF0aC5zcXJ0KHRoaXMuX25vZGVzLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgIHZhciByZW1pbmRlciA9IHNxIC0gTWF0aC5mbG9vcihzcSk7XG5cdCAgICAgICAgICAgICAgIGlmIChyZW1pbmRlciA+IDApIHZhciBubm9kZXMgPSBNYXRoLmZsb29yKHNxKSArIDE7ZWxzZSB2YXIgbm5vZGVzID0gc3E7XG5cdCAgICAgICAgICAgICAgIHZhciBzdGVwID0gKDEgLSB0aGlzLl9tYXJnaW4gKiAyKSAvIG5ub2Rlcztcblx0XG5cdCAgICAgICAgICAgICAgIHZhciBubGluZXMgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLyBubm9kZXM7XG5cdCAgICAgICAgICAgICAgIHZhciByZW1pbmRlcjIgPSBubGluZXMgLSBNYXRoLmZsb29yKG5saW5lcyk7XG5cdCAgICAgICAgICAgICAgIGlmIChyZW1pbmRlcjIgPiAwKSB2YXIgbmxpbmVzMiA9IE1hdGguZmxvb3IobmxpbmVzKSArIDE7ZWxzZSB2YXIgbmxpbmVzMiA9IG5saW5lcztcblx0ICAgICAgICAgICAgICAgdmFyIHN0ZXB5ID0gKDEgLSAyICogdGhpcy5fbWFyZ2luKSAvIChubGluZXMyIC0gMik7XG5cdCAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoaSAvIChubm9kZXMgKyAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaV0uaW5kZXhdLnggPSB0aGlzLl9tYXJnaW4gKyBzdGVwICogKGkgLSBqICogKG5ub2RlcyArIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc1tuZC5ub2Rlc1tpXS5pbmRleF0ueSA9IHRoaXMuX21hcmdpbiArIHN0ZXB5ICogajtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlc1tuZC5ub2Rlc1tpXS5pbmRleF0ud2VpZ2h0ID0gbmQuZGVncmVlc1tpXTtcblx0ICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgIH1dKTtcblx0XG5cdCAgICAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0dmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAvLyB0aGUgaHVicyBhcmUgb24gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHNpbnVzb2lkIHBlcmlvZFxuXHQgIC8vIHRoZSBpbnRlcm1lZGlhcnkgYXJlIG9uIHRoZSBzZWNvbmQgaGFsZlxuXHQgIC8vIGFuZCB0aGUgcGVyaXBoZXJ5IGFyZSBvbiB0aGUgdXBwZXIgc3RyYWlnaHQgbGluZVxuXHQgIC8vIGZ1cnRoZXIgdmVyc2lvbnMgc2hvdWxkIGVuYWJsZSB0aGUgY2hvaWNlIG9mIG90aGVyXG5cdCAgLy8gZnJhY3Rpb25zIG9mIGh1YnMsIGludGVybWVkaWFyeSBhbmQgcGVyaXBoZXJhbCB2ZXJ0aWNlc1xuXHQgIC8vIG9yIHRoZSBFcmTDtnMgc2VjdGlvbmluZy5cblx0ICAvLyBtYXliZSBhbHNvIGxldCB0aGUgdXNlciBzZXQgdGhlIGVuZHBvaW50cyBvZiB0aGUgcGVyaXBoZXJ5IHNlZ21lbnRcblx0ICBmdW5jdGlvbiBfY2xhc3Mobm9kZXMsIGVkZ2VzKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xuXHQgICAgdGhpcy5fZWRnZXMgPSBlZGdlcztcblx0ICAgIHRoaXMuX21hcmdpbiA9IDAuMDU7XG5cdCAgICB0aGlzLl9odWJzID0gMC4xOyAvLyAxMCVcblx0ICAgIHRoaXMuX2ludGVybWVkaWFyeSA9IDAuMjtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICBrZXk6ICdhcHBseScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoKSB7XG5cdCAgICAgIHZhciBuZCA9ICgwLCBfdXRpbHMuZGVncmVlcykodGhpcy5fbm9kZXMsIHRoaXMuX2VkZ2VzKTtcblx0ICAgICAgdmFyIG5odWJzX2ludGVybWVkaWFyeSA9IE1hdGguZmxvb3IodGhpcy5fbm9kZXMubGVuZ3RoICogKHRoaXMuX2h1YnMgKyB0aGlzLl9pbnRlcm1lZGlhcnkpKTtcblx0ICAgICAgdmFyIG5odWJzID0gTWF0aC5mbG9vcih0aGlzLl9ub2Rlcy5sZW5ndGggKiB0aGlzLl9odWJzKTtcblx0ICAgICAgdmFyIHN0ZXB4MSA9ICgxIC0gMiAqIHRoaXMuX21hcmdpbikgLyAyIC8gKG5odWJzIC0gMSk7XG5cdCAgICAgIHZhciBzdGVwcmFkID0gTWF0aC5QSSAvIChuaHVicyAtIDEpO1xuXHQgICAgICB2YXIgaSA9IDA7XG5cdCAgICAgIHdoaWxlIChpIDwgbmh1YnMpIHtcblx0ICAgICAgICB0aGlzLl9ub2Rlc1tuZC5ub2Rlc1tpXS5pbmRleF0ueCA9IHRoaXMuX21hcmdpbiArIHN0ZXB4MSAqIGk7XG5cdCAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaV0uaW5kZXhdLnkgPSB0aGlzLl9tYXJnaW4gKyAwLjQgKyAwLjQgKiBNYXRoLnNpbihpICogc3RlcHJhZCk7XG5cdCAgICAgICAgKytpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBuaW50ZXJtZWRpYXJ5ID0gbmh1YnNfaW50ZXJtZWRpYXJ5IC0gbmh1YnM7XG5cdCAgICAgIHZhciBzdGVwcmFkMiA9IE1hdGguUEkgLyBuaW50ZXJtZWRpYXJ5O1xuXHQgICAgICB2YXIgc3RlcHgyID0gKDEgLSAyICogdGhpcy5fbWFyZ2luKSAvIDIgLyBuaW50ZXJtZWRpYXJ5O1xuXHQgICAgICBpID0gMDtcblx0ICAgICAgd2hpbGUgKGkgPCBuaW50ZXJtZWRpYXJ5KSB7XG5cdCAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaSArIG5odWJzXS5pbmRleF0ueCA9IDAuNSArIHN0ZXB4MiAqIChpICsgMSk7XG5cdCAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaSArIG5odWJzXS5pbmRleF0ueSA9IHRoaXMuX21hcmdpbiArIDAuNCArIDAuNCAqIE1hdGguc2luKE1hdGguUEkgKyAoaSArIDEpICogc3RlcHJhZDIpO1xuXHQgICAgICAgICsraTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcDAgPSBbMC44NSwgMC43NV07XG5cdCAgICAgIHZhciBwMSA9IFswLjQsIDEgLSB0aGlzLl9tYXJnaW5dO1xuXHQgICAgICB2YXIgbnBlcmlwaGVyYWwgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBuaHVic19pbnRlcm1lZGlhcnk7XG5cdCAgICAgIHZhciBzdGVweHggPSAocDFbMF0gLSBwMFswXSkgLyAobnBlcmlwaGVyYWwgLSAxKTtcblx0ICAgICAgdmFyIHN0ZXB5ID0gKHAxWzFdIC0gcDBbMV0pIC8gKG5wZXJpcGhlcmFsIC0gMSk7XG5cdCAgICAgIGkgPSAwO1xuXHQgICAgICB3aGlsZSAoaSA8IG5wZXJpcGhlcmFsKSB7XG5cdCAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaSArIG5odWJzX2ludGVybWVkaWFyeV0uaW5kZXhdLnggPSBwMFswXSArIHN0ZXB4eCAqIGk7XG5cdCAgICAgICAgdGhpcy5fbm9kZXNbbmQubm9kZXNbaSArIG5odWJzX2ludGVybWVkaWFyeV0uaW5kZXhdLnkgPSBwMFsxXSArIHN0ZXB5ICogaTtcblx0ICAgICAgICArK2k7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IEFsZcWhIFNhc2thIC0gaHR0cDovL2FsZXNzYXNrYS5jei9cblx0ICovXG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIF9jbGFzcygpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgbnVsbCwgW3tcblx0ICAgIGtleTogXCJlZGdlU291cmNlXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZWRnZVNvdXJjZShlKSB7XG5cdCAgICAgIGlmIChlLnNvdXJjZS5zb3VyY2UpIHtcblx0ICAgICAgICAvL3NvdXJjZSBpcyBlZGdlXG5cdCAgICAgICAgdmFyIHMgPSB0aGlzLmVkZ2VTb3VyY2UoZS5zb3VyY2UpO1xuXHQgICAgICAgIHZhciB0ID0gdGhpcy5lZGdlVGFyZ2V0KGUuc291cmNlKTtcblx0XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIHg6IChzLnggKyB0LngpIC8gMixcblx0ICAgICAgICAgIHk6IChzLnkgKyB0LnkpIC8gMixcblx0ICAgICAgICAgIHVuaXFpZDogZS51bmlxaWQsXG5cdCAgICAgICAgICBpbmRleDogZS5pbmRleCxcblx0ICAgICAgICAgIGlzX2VkZ2U6IHRydWUsXG5cdCAgICAgICAgICBlOiBlLnNvdXJjZVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBlLnNvdXJjZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZWRnZVRhcmdldFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGVkZ2VUYXJnZXQoZSkge1xuXHQgICAgICBpZiAoZS50YXJnZXQuc291cmNlKSB7XG5cdCAgICAgICAgLy90YXJnZXQgaXMgZWRnZVxuXHQgICAgICAgIHZhciBzID0gdGhpcy5lZGdlU291cmNlKGUudGFyZ2V0KTtcblx0ICAgICAgICB2YXIgdCA9IHRoaXMuZWRnZVRhcmdldChlLnRhcmdldCk7XG5cdFxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICB4OiAocy54ICsgdC54KSAvIDIsXG5cdCAgICAgICAgICB5OiAocy55ICsgdC55KSAvIDIsXG5cdCAgICAgICAgICB1bmlxaWQ6IGUudW5pcWlkLFxuXHQgICAgICAgICAgaW5kZXg6IGUuaW5kZXgsXG5cdCAgICAgICAgICBpc19lZGdlOiB0cnVlLFxuXHQgICAgICAgICAgZTogZS50YXJnZXRcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gZS50YXJnZXQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImdldEN1cnZlU2hpZnRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJ2ZVNoaWZ0KGUsIHIpIHtcblx0ICAgICAgciA9IHIgfHwge307XG5cdCAgICAgIHIueCA9IHIueSA9IHIuY3ggPSByLmN5ID0gMDtcblx0ICAgICAgaWYgKCFlKSByZXR1cm4gcjtcblx0ICAgICAgaWYgKGUudCAmJiBlLnQgPj0gMSkge1xuXHQgICAgICAgIC8vY3VydmUgb3IgY2lyY2xlXG5cdCAgICAgICAgaWYgKGUudCA+PSAyKSB7XG5cdCAgICAgICAgICAvL2NpcmNsZVxuXHQgICAgICAgICAgdmFyIHMgPSB0aGlzLmVkZ2VTb3VyY2UoZSk7XG5cdCAgICAgICAgICB2YXIgZCA9IHMueSA8IDAuNSA/IDEgOiAtMTtcblx0XG5cdCAgICAgICAgICByLmN4ID0gZCAqIDEuMjU7XG5cdCAgICAgICAgICByLmN5ID0gMDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIHNlID0gdGhpcy5lZGdlU291cmNlKGUpO1xuXHQgICAgICAgICAgdmFyIHRlID0gdGhpcy5lZGdlVGFyZ2V0KGUpO1xuXHRcblx0ICAgICAgICAgIHIueCA9IHNlLnggLSB0ZS54O1xuXHQgICAgICAgICAgci55ID0gc2UueSAtIHRlLnk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3JidXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cdFxuXHR2YXIgX3JidXNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JidXNoKTtcblx0XG5cdHZhciBfZ2VvbXV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdFxuXHR2YXIgX2dlb211dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW9tdXRpbHMpO1xuXHRcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblx0XG5cdHZhciBfcHJpbWl0aXZlVG9vbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcblx0dmFyIF9nZW9tdG9vbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IEFsZcWhIFNhc2thIC0gaHR0cDovL2FsZXNzYXNrYS5jei9cblx0ICovXG5cdFxuXHR2YXIgY3QgPSB7fTtcblx0ZnVuY3Rpb24gZ2V0RWRnZVNoaWZ0KGNvbnRleHQsIHNjcmVlbnNpemUsIGUsIGN0KSB7XG5cdCAgX2dlb211dGlsczIuZGVmYXVsdC5nZXRDdXJ2ZVNoaWZ0KGUsIGN0KTsgLy9nZXQgc2hpZnQgYmVjYXVzZSBvZiBlZGdlLXRvLWVkZ2UgZnVuY3Rpb25hbGl0eVxuXHRcblx0XG5cdCAgLy9jb21wdXRlIGFsbCB0cmFuc2Zvcm1hdGlvbnMgbWFkZSBpbiB0aGUgdmVydGV4IHNoYWRlclxuXHQgIHZhciBjdHggPSB2b2lkIDAsXG5cdCAgICAgIGN0eSA9IHZvaWQgMCxcblx0ICAgICAgY2l0eCA9IHZvaWQgMCxcblx0ICAgICAgY2l0eSA9IHZvaWQgMDtcblx0XG5cdCAgY3R4ID0gLWN0Lnk7XG5cdCAgY3R5ID0gY3QueCAqIGNvbnRleHQuYXNwZWN0Mjtcblx0XG5cdCAgdmFyIGxlbjIgPSBjdHggKiBjb250ZXh0LndpZHRoICogY3R4ICogY29udGV4dC53aWR0aCArIGN0eSAqIGNvbnRleHQuaGVpZ2h0ICogY3R5ICogY29udGV4dC5oZWlnaHQ7XG5cdFxuXHQgIGlmICgoMCwgX2dlb210b29scy5lcSkobGVuMiwgMCkpIHtcblx0ICAgIGN0eCA9IDA7XG5cdCAgICBjdHkgPSAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5zcXJ0KGxlbjIpO1xuXHQgICAgY3R4ICo9IGNvbnRleHQuY3VydmVFeGMgKiAwLjI1ICogc2NyZWVuc2l6ZSAvIGxlbjtcblx0ICAgIGN0eSAqPSBjb250ZXh0LmN1cnZlRXhjICogMC4yNSAqIHNjcmVlbnNpemUgLyBsZW47XG5cdCAgfVxuXHRcblx0ICB2YXIgc2l6ZXggPSAyLjUgKiBjb250ZXh0Lm5vZGVTaXplICogc2NyZWVuc2l6ZSAvIGNvbnRleHQud2lkdGg7XG5cdCAgdmFyIHNpemV5ID0gMi41ICogY29udGV4dC5ub2RlU2l6ZSAqIHNjcmVlbnNpemUgLyBjb250ZXh0LmhlaWdodDtcblx0ICBjaXR4ID0gLWN0LmN5ICogMC41ICogc2l6ZXg7XG5cdCAgY2l0eSA9IGN0LmN4ICogMC41ICogc2l6ZXk7XG5cdFxuXHQgIGN0LnggPSBjdHggKyBjaXR4O1xuXHQgIGN0LnkgPSBjdHkgKyBjaXR5O1xuXHR9XG5cdFxuXHR2YXIgTm9kZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBOb2RlKG4pIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblx0XG5cdCAgICB0aGlzLmUgPSBuO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKE5vZGUsIFt7XG5cdCAgICBrZXk6ICdnZXRCQm94Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCQm94KCkge1xuXHQgICAgICByZXR1cm4gW3RoaXMuZS54IC0gX2dlb210b29scy5FUFMsIHRoaXMuZS55IC0gX2dlb210b29scy5FUFMsIHRoaXMuZS54ICsgX2dlb210b29scy5FUFMsIHRoaXMuZS55ICsgX2dlb210b29scy5FUFNdO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2ludGVyc2VjdHNSZWN0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzUmVjdCh4MSwgeTEsIHgyLCB5Mikge1xuXHQgICAgICByZXR1cm4gKDAsIF9nZW9tdG9vbHMucG9pbnRJblJlY3QpKHRoaXMuZS54LCB0aGlzLmUueSwgeDEsIHkxLCB4MiwgeTIpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2Rpc3QyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0Mih4LCB5LCBjb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiAoMCwgX2dlb210b29scy5kaXN0YW5jZTIpKHgsIHksIHRoaXMuZS54LCB0aGlzLmUueSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaXNOb2RlJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBOb2RlO1xuXHR9KCk7XG5cdFxuXHR2YXIgTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gTGFiZWwobiwgdGV4dHBvcywgc3R5bGUsIGZvbnRTaXplLCBpc1NERiwgZ2V0TGFiZWxTaXplKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWwpO1xuXHRcblx0ICAgIHRoaXMuZSA9IG47XG5cdCAgICB0aGlzLnBvcyA9IHRleHRwb3M7XG5cdCAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG5cdCAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemU7XG5cdCAgICB0aGlzLmlzU0RGID0gaXNTREY7XG5cdCAgICB0aGlzLmdldExhYmVsU2l6ZSA9IGdldExhYmVsU2l6ZTtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhMYWJlbCwgW3tcblx0ICAgIGtleTogJ2dldFRleHRQb3MnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRQb3MoY29udGV4dCwgc2l6ZSkge1xuXHQgICAgICB2YXIgeCA9IHRoaXMuZS54O1xuXHQgICAgICB2YXIgeSA9IHRoaXMuZS55O1xuXHRcblx0ICAgICAgdmFyIHgxID0gdm9pZCAwLFxuXHQgICAgICAgICAgeTEgPSB2b2lkIDAsXG5cdCAgICAgICAgICB4MiA9IHZvaWQgMCxcblx0ICAgICAgICAgIHkyID0gdm9pZCAwO1xuXHQgICAgICB4MSA9IHgyID0geDtcblx0ICAgICAgeTEgPSB5MiA9IHk7XG5cdFxuXHQgICAgICB2YXIgd2FudGVkU2l6ZSA9IHRoaXMuaXNTREYgPyB0aGlzLmdldExhYmVsU2l6ZShjb250ZXh0LCB0aGlzLnN0eWxlLmxhYmVsIHx8IHt9KSA6IHRoaXMuZm9udFNpemU7XG5cdFxuXHQgICAgICB2YXIgZm9udFNjYWxlID0gd2FudGVkU2l6ZSAvIHRoaXMuZm9udFNpemU7XG5cdCAgICAgIGlmICh3YW50ZWRTaXplID09PSAwKSB7XG5cdCAgICAgICAgZm9udFNjYWxlID0gMDtcblx0ICAgICAgfTtcblx0XG5cdCAgICAgIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChlZGdlLCB4KSB7XG5cdCAgICAgICAgcmV0dXJuIHggPCBlZGdlID8gMCA6IDE7XG5cdCAgICAgIH07XG5cdFxuXHQgICAgICB2YXIgb2Zmc2V0ID0gMC41ICogY29udGV4dC5ub2RlU2l6ZTtcblx0ICAgICAgdmFyIE1BWCA9IDEwLjtcblx0ICAgICAgdmFyIE1JTiA9IC0xMC47XG5cdCAgICAgIHZhciBiYm94ID0gW01BWCwgTUFYLCBNSU4sIE1JTl07XG5cdFxuXHQgICAgICB0aGlzLnBvcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgdmFyIG9mZnNldHkgPSAoMi4wICogc3RlcCh5LCAwLjUpIC0gMS4wKSAqIG9mZnNldDtcblx0ICAgICAgICB4MSA9IHggKyBzaXplICogKGMuZHggKiBmb250U2NhbGUpIC8gY29udGV4dC53aWR0aCAvIDI7XG5cdCAgICAgICAgeTEgPSB5ICsgc2l6ZSAqIChjLmR5ICogZm9udFNjYWxlICsgb2Zmc2V0eSkgLyBjb250ZXh0LmhlaWdodCAvIDI7XG5cdCAgICAgICAgeDIgPSB4ICsgc2l6ZSAqICgoYy5keCArIGMud2lkdGgpICogZm9udFNjYWxlKSAvIGNvbnRleHQud2lkdGggLyAyO1xuXHQgICAgICAgIHkyID0geSArIHNpemUgKiAoKGMuZHkgKyBjLmhlaWdodCkgKiBmb250U2NhbGUgKyBvZmZzZXR5KSAvIGNvbnRleHQuaGVpZ2h0IC8gMjtcblx0XG5cdCAgICAgICAgYmJveFswXSA9IE1hdGgubWluKHgxLCBiYm94WzBdKTtcblx0ICAgICAgICBiYm94WzFdID0gTWF0aC5taW4oeTEsIGJib3hbMV0pO1xuXHQgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heCh4MiwgYmJveFsyXSk7XG5cdCAgICAgICAgYmJveFszXSA9IE1hdGgubWF4KHkyLCBiYm94WzNdKTtcblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICByZXR1cm4gYmJveDtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdnZXRCQm94Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCQm94KGNvbnRleHQpIHtcblx0ICAgICAgdmFyIGJiID0gdGhpcy5nZXRUZXh0UG9zKGNvbnRleHQsIDEpO1xuXHQgICAgICBiYlswXSA9IE1hdGgubWluKGJiWzBdLCB0aGlzLmUueCk7XG5cdCAgICAgIGJiWzFdID0gTWF0aC5taW4oYmJbMV0sIHRoaXMuZS55KTtcblx0ICAgICAgYmJbMl0gPSBNYXRoLm1heChiYlsyXSwgdGhpcy5lLngpO1xuXHQgICAgICBiYlszXSA9IE1hdGgubWF4KGJiWzNdLCB0aGlzLmUueSk7XG5cdCAgICAgIHJldHVybiBiYjtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpbnRlcnNlY3RzUmVjdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c1JlY3QoeDEsIHkxLCB4MiwgeTIsIGNvbnRleHQsIHNpemUpIHtcblx0ICAgICAgdmFyIHQgPSB0aGlzLmdldFRleHRQb3MoY29udGV4dCwgc2l6ZSk7XG5cdCAgICAgIHJldHVybiAoMCwgX2dlb210b29scy5yZWN0SW50ZXJzZWN0c1JlY3QpKHgxLCB5MSwgeDIsIHkyLCB0WzBdLCB0WzFdLCB0WzJdLCB0WzNdKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkaXN0MicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdDIoeCwgeSwgY29udGV4dCwgc2l6ZSkge1xuXHQgICAgICB2YXIgdCA9IHRoaXMuZ2V0VGV4dFBvcyhjb250ZXh0LCBzaXplKTtcblx0XG5cdCAgICAgIGlmICgoMCwgX2dlb210b29scy5wb2ludEluUmVjdCkoeCwgeSwgdFswXSwgdFsxXSwgdFsyXSwgdFszXSkpIHJldHVybiAwO1xuXHRcblx0ICAgICAgLy9taW5pbXVtIGZyb20gZGlzdGFuY2UgZnJvbSBjb3JuZXJzIG9yIGRpc3RhbmNlIGZyb20gYm9yZGVyc1xuXHQgICAgICByZXR1cm4gTWF0aC5taW4oKDAsIF9nZW9tdG9vbHMuZGlzdGFuY2UyKSh0WzBdLCB0WzFdKSwgKDAsIF9nZW9tdG9vbHMuZGlzdGFuY2UyKSh0WzJdLCB0WzNdKSwgKDAsIF9nZW9tdG9vbHMuZGlzdGFuY2UyKSh0WzBdLCB0WzNdKSwgKDAsIF9nZW9tdG9vbHMuZGlzdGFuY2UyKSh0WzJdLCB0WzFdKSwgKDAsIF9nZW9tdG9vbHMucERpc3RhbmNlMikoeCwgeSwgdFswXSwgdFsxXSwgdFsyXSwgdFsxXSksICgwLCBfZ2VvbXRvb2xzLnBEaXN0YW5jZTIpKHgsIHksIHRbMF0sIHRbM10sIHRbMl0sIHRbM10pLCAoMCwgX2dlb210b29scy5wRGlzdGFuY2UyKSh4LCB5LCB0WzBdLCB0WzFdLCB0WzBdLCB0WzNdKSwgKDAsIF9nZW9tdG9vbHMucERpc3RhbmNlMikoeCwgeSwgdFsyXSwgdFsxXSwgdFsyXSwgdFszXSkpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2lzTGFiZWwnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIExhYmVsO1xuXHR9KCk7XG5cdFxuXHR2YXIgTGluZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBMaW5lKGwpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lKTtcblx0XG5cdCAgICB0aGlzLmUgPSBsO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKExpbmUsIFt7XG5cdCAgICBrZXk6ICdnZXRQb2ludHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50cyhjb250ZXh0LCBzaXplKSB7XG5cdCAgICAgIHZhciB4MSA9IHZvaWQgMCxcblx0ICAgICAgICAgIHkxID0gdm9pZCAwLFxuXHQgICAgICAgICAgeDIgPSB2b2lkIDAsXG5cdCAgICAgICAgICB5MiA9IHZvaWQgMDtcblx0XG5cdCAgICAgIHZhciBzID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlU291cmNlKHRoaXMuZSk7XG5cdCAgICAgIHZhciB0ID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlVGFyZ2V0KHRoaXMuZSk7XG5cdFxuXHQgICAgICB4MSA9IHMueDtcblx0ICAgICAgeTEgPSBzLnk7XG5cdCAgICAgIHgyID0gdC54O1xuXHQgICAgICB5MiA9IHQueTtcblx0XG5cdCAgICAgIGdldEVkZ2VTaGlmdChjb250ZXh0LCBzaXplLCBzLmUsIGN0KTtcblx0ICAgICAgeDEgKz0gY3QueDtcblx0ICAgICAgeTEgKz0gY3QueTtcblx0ICAgICAgZ2V0RWRnZVNoaWZ0KGNvbnRleHQsIHNpemUsIHQuZSwgY3QpO1xuXHQgICAgICB4MiArPSBjdC54O1xuXHQgICAgICB5MiArPSBjdC55O1xuXHRcblx0ICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZ2V0QkJveCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveChjb250ZXh0LCBzaXplKSB7XG5cdCAgICAgIHZhciBwID0gdGhpcy5nZXRQb2ludHMoY29udGV4dCwgc2l6ZSk7XG5cdFxuXHQgICAgICByZXR1cm4gW01hdGgubWluKHBbMF0sIHBbMl0pLCBNYXRoLm1pbihwWzFdLCBwWzNdKSwgTWF0aC5tYXgocFswXSwgcFsyXSksIE1hdGgubWF4KHBbMV0sIHBbM10pXTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpbnRlcnNlY3RzUmVjdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c1JlY3QoeDEsIHkxLCB4MiwgeTIsIGNvbnRleHQsIHNpemUpIHtcblx0ICAgICAgdmFyIHAgPSB0aGlzLmdldFBvaW50cyhjb250ZXh0LCBzaXplKTtcblx0XG5cdCAgICAgIHJldHVybiAoMCwgX2dlb210b29scy5saW5lSW50ZXJzZWN0c1JlY3QpKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10sIHgxLCB5MSwgeDIsIHkyKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkaXN0MicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdDIoeCwgeSwgY29udGV4dCwgc2l6ZSkge1xuXHQgICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnRzKGNvbnRleHQsIHNpemUpO1xuXHRcblx0ICAgICAgcmV0dXJuICgwLCBfZ2VvbXRvb2xzLnBEaXN0YW5jZTIpKHgsIHksIHBbMF0sIHBbMV0sIHBbMl0sIHBbM10pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2lzRWRnZScsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gTGluZTtcblx0fSgpO1xuXHRcblx0dmFyIENpcmNsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBDaXJjbGUoYykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG5cdFxuXHQgICAgdGhpcy5lID0gYztcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhDaXJjbGUsIFt7XG5cdCAgICBrZXk6ICdnZXRCZXppZXJQb2ludHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJlemllclBvaW50cyhjb250ZXh0LCBzY3JlZW5zaXplKSB7XG5cdCAgICAgIHZhciB4MSA9IHZvaWQgMCxcblx0ICAgICAgICAgIHkxID0gdm9pZCAwLFxuXHQgICAgICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcyA9IF9nZW9tdXRpbHMyLmRlZmF1bHQuZWRnZVNvdXJjZSh0aGlzLmUpO1xuXHQgICAgICB4MSA9IHMueDtcblx0ICAgICAgeTEgPSBzLnk7XG5cdFxuXHQgICAgICB2YXIgc2l6ZSA9IDIuNSAqIGNvbnRleHQubm9kZVNpemUgKiBzY3JlZW5zaXplO1xuXHQgICAgICB2YXIgeHNpemUgPSBzaXplIC8gY29udGV4dC53aWR0aCAvIDI7XG5cdCAgICAgIHZhciB5c2l6ZSA9IHNpemUgLyBjb250ZXh0LmhlaWdodCAvIDI7XG5cdFxuXHQgICAgICB2YXIgZCA9IHMueSA8IDAuNSA/IDEgOiAtMTtcblx0XG5cdCAgICAgIGdldEVkZ2VTaGlmdChjb250ZXh0LCBzY3JlZW5zaXplLCBzLmUsIGN0KTtcblx0ICAgICAgeDEgKz0gY3QueDtcblx0ICAgICAgeTEgKz0gY3QueTtcblx0XG5cdCAgICAgIHJldHVybiBbeDEsIHkxLCB4MSArIHhzaXplICogMSwgeTEgKyB5c2l6ZSAqIGQsIHgxLCB5MSArIHlzaXplICogMS4yNSAqIGQsIHgxIC0geHNpemUgKiAxLCB5MSArIHlzaXplICogZF07XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZ2V0QkJveCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveChjb250ZXh0LCBzaXplKSB7XG5cdCAgICAgIHZhciB2ID0gdGhpcy5nZXRCZXppZXJQb2ludHMoY29udGV4dCwgc2l6ZSk7XG5cdFxuXHQgICAgICByZXR1cm4gKDAsIF9nZW9tdG9vbHMuZ2V0QkJGcm9tUG9pbnRzKSh2KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpbnRlcnNlY3RzUmVjdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c1JlY3QoeDEsIHkxLCB4MiwgeTIsIGNvbnRleHQsIHNpemUsIG5vcm1hbGl6ZSkge1xuXHQgICAgICB2YXIgdiA9IHRoaXMuZ2V0QmV6aWVyUG9pbnRzKGNvbnRleHQsIHNpemUpO1xuXHQgICAgICByZXR1cm4gKDAsIF9nZW9tdG9vbHMuYmV6aWVySW50ZXJzZWN0c1JlY3QpKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0sIHgxLCB5MSwgeDIsIHkyKSB8fCAoMCwgX2dlb210b29scy5iZXppZXJJbnRlcnNlY3RzUmVjdCkodlsyXSwgdlszXSwgdls0XSwgdls1XSwgdls2XSwgdls3XSwgeDEsIHkxLCB4MiwgeTIpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2Rpc3QyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0Mih4LCB5LCBjb250ZXh0LCBzaXplKSB7XG5cdCAgICAgIHZhciB2ID0gdGhpcy5nZXRCZXppZXJQb2ludHMoY29udGV4dCwgc2l6ZSk7XG5cdFxuXHQgICAgICAvL2NpcmNsZSBpcyBqdXN0IDIgYmV6aWVyIGN1cnZlcyA6KVxuXHQgICAgICB2YXIgZDEgPSAoMCwgX2dlb210b29scy5kaXN0YW5jZTJUb0JlemllcikoeCwgeSwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG5cdCAgICAgIHZhciBkMiA9ICgwLCBfZ2VvbXRvb2xzLmRpc3RhbmNlMlRvQmV6aWVyKSh4LCB5LCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdLCB2WzZdLCB2WzddKTtcblx0XG5cdCAgICAgIHJldHVybiBNYXRoLm1pbihkMSwgZDIpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2lzRWRnZScsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gQ2lyY2xlO1xuXHR9KCk7XG5cdFxuXHR2YXIgQ3VydmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gQ3VydmUoYykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnZlKTtcblx0XG5cdCAgICB0aGlzLmUgPSBjO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKEN1cnZlLCBbe1xuXHQgICAga2V5OiAnZ2V0QmV6aWVyUG9pbnRzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCZXppZXJQb2ludHMoY29udGV4dCwgc2l6ZSwgbm9ybWFsaXplKSB7XG5cdCAgICAgIHZhciB4MSA9IHZvaWQgMCxcblx0ICAgICAgICAgIHgyID0gdm9pZCAwLFxuXHQgICAgICAgICAgeTEgPSB2b2lkIDAsXG5cdCAgICAgICAgICB5MiA9IHZvaWQgMDtcblx0ICAgICAgdmFyIHMgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VTb3VyY2UodGhpcy5lKTtcblx0ICAgICAgdmFyIHQgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VUYXJnZXQodGhpcy5lKTtcblx0XG5cdCAgICAgIHgxID0gcy54O1xuXHQgICAgICB5MSA9IHMueTtcblx0ICAgICAgeDIgPSB0Lng7XG5cdCAgICAgIHkyID0gdC55O1xuXHRcblx0ICAgICAgdmFyIGQgPSBub3JtYWxpemUocywgdCk7XG5cdFxuXHQgICAgICB2YXIgbjIgPSBkLnk7XG5cdCAgICAgIHZhciBuMyA9IGNvbnRleHQuYXNwZWN0MiAqIC1kLng7XG5cdFxuXHQgICAgICB2YXIgeCA9IGNvbnRleHQud2lkdGggKiBuMjtcblx0ICAgICAgdmFyIHkgPSBjb250ZXh0LmhlaWdodCAqIG4zO1xuXHQgICAgICB2YXIgbCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KSAqIDI7XG5cdFxuXHQgICAgICBuMiAqPSBjb250ZXh0LmN1cnZlRXhjICogc2l6ZSAvIGw7XG5cdCAgICAgIG4zICo9IGNvbnRleHQuY3VydmVFeGMgKiBzaXplIC8gbDtcblx0XG5cdCAgICAgIGdldEVkZ2VTaGlmdChjb250ZXh0LCBzaXplLCBzLmUsIGN0KTtcblx0ICAgICAgeDEgKz0gY3QueDtcblx0ICAgICAgeTEgKz0gY3QueTtcblx0ICAgICAgZ2V0RWRnZVNoaWZ0KGNvbnRleHQsIHNpemUsIHQuZSwgY3QpO1xuXHQgICAgICB4MiArPSBjdC54O1xuXHQgICAgICB5MiArPSBjdC55O1xuXHRcblx0ICAgICAgdmFyIHJldCA9IFt4MSwgeTEsICh4MSArIHgyKSAvIDIgKyBuMiwgKHkxICsgeTIpIC8gMiArIG4zLCB4MiwgeTJdO1xuXHQgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2ludGVyc2VjdHNSZWN0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzUmVjdCh4MSwgeTEsIHgyLCB5MiwgY29udGV4dCwgc2l6ZSwgbm9ybWFsaXplKSB7XG5cdCAgICAgIHZhciB2ID0gdGhpcy5nZXRCZXppZXJQb2ludHMoY29udGV4dCwgc2l6ZSwgbm9ybWFsaXplKTtcblx0ICAgICAgcmV0dXJuICgwLCBfZ2VvbXRvb2xzLmJlemllckludGVyc2VjdHNSZWN0KSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdLCB4MSwgeTEsIHgyLCB5Mik7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZ2V0QkJveCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveChjb250ZXh0LCBzaXplLCBub3JtYWxpemUpIHtcblx0ICAgICAgdmFyIHYgPSB0aGlzLmdldEJlemllclBvaW50cyhjb250ZXh0LCBzaXplLCBub3JtYWxpemUpO1xuXHQgICAgICByZXR1cm4gKDAsIF9nZW9tdG9vbHMuZ2V0QkJGcm9tUG9pbnRzKSh2KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkaXN0MicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdDIoeCwgeSwgY29udGV4dCwgc2l6ZSwgbm9ybWFsaXplKSB7XG5cdCAgICAgIHZhciB2ID0gdGhpcy5nZXRCZXppZXJQb2ludHMoY29udGV4dCwgc2l6ZSwgbm9ybWFsaXplKTtcblx0ICAgICAgcmV0dXJuICgwLCBfZ2VvbXRvb2xzLmRpc3RhbmNlMlRvQmV6aWVyKSh4LCB5LCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpc0VkZ2UnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIEN1cnZlO1xuXHR9KCk7XG5cdFxuXHRmdW5jdGlvbiBzb3J0QnlEaXN0YW5jZXMoZTEsIGUyKSB7XG5cdCAgcmV0dXJuIGUxLmRpc3QyIC0gZTIuZGlzdDI7XG5cdH1cblx0XG5cdHZhciB0Q29uc3QgPSB7IG5vZGVzOiBOb2RlLCBsaW5lczogTGluZSwgY2lyY2xlczogQ2lyY2xlLCBjdXJ2ZXM6IEN1cnZlLCBsYWJlbHM6IExhYmVsIH07XG5cdFxuXHR2YXIgc3BhdGlhbEluZGV4ID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIHNwYXRpYWxJbmRleChjLCB0ZXh0cywgb3B0aW9ucywgbm9kZXMsIG5vZGVzUGFydHMsIGxpbmVzLCBsaW5lc1BhcnRzLCBjdXJ2ZXMsIGN1cnZlc1BhcnRzLCBjaXJjbGVzLCBjaXJjbGVzUGFydHMsIG5vcm1hbGl6ZSwgbm9kZVN0eWxlLCBnZXRMYWJlbFNpemUsIGdldExhYmVsSGlkZVNjcmVlbikge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIHNwYXRpYWxJbmRleCk7XG5cdFxuXHQgICAgLy9pbml0IGFsbCBlbGVtZW50cyBpbnRvIHJidXNoIHRyZWUgd2l0aCBzaXplIDEgKG91dGVyIGJvdW5kIC0gdGhlIHdvcnN0IGNhc2UpXG5cdCAgICB2YXIgc2l6ZSA9IDE7dmFyIG9sZHNpemUgPSBjLnNpemUgfHwgMTtjLnNpemUgPSAxLjtcblx0XG5cdCAgICB0aGlzLnRleHRzID0gdGV4dHM7XG5cdCAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblx0ICAgIHZhciB0ID0gdGhpcy50eXBlcyA9IHsgbm9kZXM6IFtdLCBsaW5lczogW10sIGNpcmNsZXM6IFtdLCBjdXJ2ZXM6IFtdLCBsYWJlbHM6IFtdIH07XG5cdCAgICB2YXIgaSA9IDAsXG5cdCAgICAgICAgZCA9IFtdO1xuXHRcblx0ICAgIHZhciBhZGRFbnRpdHkgPSBmdW5jdGlvbiBhZGRFbnRpdHkoZSwgZCwgaSkge1xuXHQgICAgICBkW2ldID0gZS5nZXRCQm94KGMsIHNpemUsIG5vcm1hbGl6ZSk7XG5cdCAgICAgIGRbaV0ucHVzaChlKTtcblx0ICAgICAgcmV0dXJuIGU7XG5cdCAgICB9O1xuXHRcblx0ICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgdC5ub2Rlcy5wdXNoKGFkZEVudGl0eShuZXcgTm9kZShuKSwgZCwgaSsrKSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG5cdCAgICAgIHQubGluZXMucHVzaChhZGRFbnRpdHkobmV3IExpbmUobCksIGQsIGkrKykpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgY2lyY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgIHQuY2lyY2xlcy5wdXNoKGFkZEVudGl0eShuZXcgQ2lyY2xlKGMpLCBkLCBpKyspKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIGN1cnZlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgIHQuY3VydmVzLnB1c2goYWRkRW50aXR5KG5ldyBDdXJ2ZShjKSwgZCwgaSsrKSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICB2YXIgc2QgPSB7fTtcblx0ICAgIHZhciBzZGkgPSB7fTtcblx0XG5cdCAgICAvL2xhYmVscyBwb3NpdGlvbiBjb3VsZCBkaWZmZXIgYnkgc3R5bGUgPj4gbXVzdCBwYXJ0aXRpb24gYnkgaXRcblx0XG5cdCAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChzdHlsZSkge1xuXHQgICAgICB2YXIgbm9kZXMgPSBub2Rlc1BhcnRzW3N0eWxlXTtcblx0XG5cdCAgICAgIHZhciBucyA9ICgwLCBfcHJpbWl0aXZlVG9vbHMuZ2V0UGFydGl0aW9uU3R5bGUpKG9wdGlvbnMuc3R5bGVzW3N0eWxlXSwgbm9kZVN0eWxlLCBcImxhYmVsXCIpO1xuXHQgICAgICB2YXIgdGV4dEVuZ2luZSA9IHRleHRzLmdldEVuZ2luZShucy5mb250KTtcblx0ICAgICAgdGV4dEVuZ2luZS5zZXRGb250KG5zLmZvbnQpO1xuXHQgICAgICB2YXIgZm9udFNpemUgPSB0ZXh0RW5naW5lLmZvbnRTaXplO1xuXHQgICAgICB2YXIgaXNTREYgPSB0ZXh0RW5naW5lLmlzU0RGO1xuXHRcblx0ICAgICAgdmFyIHNkX24gPSBzZFtzdHlsZV0gfHwgKHNkW3N0eWxlXSA9IFtdKTtcblx0ICAgICAgdmFyIHNkaV9uID0gc2RpW3N0eWxlXSB8fCAoc2RpW3N0eWxlXSA9IDApO1xuXHRcblx0ICAgICAgLy9iaWdnZXN0IHNpemUgaW4gd2hpY2ggdGhlIHRleHQgaXMgc2hvd25cblx0ICAgICAgYy5zaXplID0gZ2V0TGFiZWxIaWRlU2NyZWVuKGMsIG5zLmxhYmVsIHx8IHt9KTtcblx0ICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXHQgICAgICAgIHZhciB0ZXh0cG9zID0gdGV4dEVuZ2luZS5nZXQobi5sYWJlbCwgbi54LCBuLnkpO1xuXHQgICAgICAgIHQubGFiZWxzLnB1c2goYWRkRW50aXR5KG5ldyBMYWJlbChuLCB0ZXh0cG9zLCBucywgZm9udFNpemUsIGlzU0RGLCBnZXRMYWJlbFNpemUpLCBzZF9uLCBzZGlfbisrKSk7XG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgc2RpW3N0eWxlXSA9IHNkaV9uO1xuXHQgICAgfTtcblx0XG5cdCAgICBmb3IgKHZhciBzdHlsZSBpbiBub2Rlc1BhcnRzKSB7XG5cdCAgICAgIF9sb29wKHN0eWxlKTtcblx0ICAgIH1cblx0XG5cdCAgICB0aGlzLnJidXNodHJlZV9zID0ge307XG5cdCAgICBmb3IgKHZhciBzdHlsZSBpbiBzZCkge1xuXHQgICAgICB2YXIgcmIgPSB0aGlzLnJidXNodHJlZV9zW3N0eWxlXSA9ICgwLCBfcmJ1c2gyLmRlZmF1bHQpKCk7XG5cdCAgICAgIHJiLmxvYWQoc2Rbc3R5bGVdKTtcblx0ICAgIH1cblx0XG5cdCAgICAvL3RyZWUgaW5pdGlhbGl6YXRpb25cblx0ICAgIHRoaXMucmJ1c2h0cmVlID0gKDAsIF9yYnVzaDIuZGVmYXVsdCkoKTtcblx0ICAgIHRoaXMucmJ1c2h0cmVlLmxvYWQoZCk7XG5cdFxuXHQgICAgLy9yZXN0b3JlIHRoZSBzaXplIG9mIHNjYWxlIChsb29zZW4gb3V0ZXIgdGhlIHVwcGVyIGJvdW5kKVxuXHQgICAgYy5zaXplID0gb2xkc2l6ZTtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhzcGF0aWFsSW5kZXgsIFt7XG5cdCAgICBrZXk6ICdfdHJ5QWRkRWwnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlBZGRFbChyZXQsIGUsIGRpc3QyLCBub2RlcywgZWRnZXMsIGxhYmVscykge1xuXHQgICAgICBpZiAobm9kZXMgJiYgZS5pc05vZGUpIHtcblx0ICAgICAgICByZXQubm9kZXMucHVzaCh7IG5vZGU6IGUuZSwgZGlzdDogTWF0aC5zcXJ0KGRpc3QyKSwgZGlzdDI6IGRpc3QyIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChlZGdlcyAmJiBlLmlzRWRnZSkge1xuXHQgICAgICAgIHJldC5lZGdlcy5wdXNoKHsgZWRnZTogZS5lLCBkaXN0OiBNYXRoLnNxcnQoZGlzdDIpLCBkaXN0MjogZGlzdDIgfSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGxhYmVscyAmJiBlLmlzTGFiZWwpIHtcblx0ICAgICAgICByZXQubGFiZWxzLnB1c2goeyBsYWJlbDogZS5lLCBkaXN0OiBNYXRoLnNxcnQoZGlzdDIpLCBkaXN0MjogZGlzdDIgfSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdmaW5kQXJlYScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFyZWEoY29udGV4dCwgeDEsIHkxLCB4MiwgeTIsIHNpemUsIG5vZGVzLCBlZGdlcywgbGFiZWxzKSB7XG5cdCAgICAgIGlmICh4MSA+IHgyKSB7XG5cdCAgICAgICAgdmFyIHAgPSB4MTtcblx0ICAgICAgICB4MSA9IHgyO1xuXHQgICAgICAgIHgyID0gcDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoeTEgPiB5Mikge1xuXHQgICAgICAgIHZhciBfcCA9IHkxO1xuXHQgICAgICAgIHkxID0geTI7XG5cdCAgICAgICAgeTIgPSBfcDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIHJldCA9IHt9O1xuXHQgICAgICBpZiAoZWRnZXMpIHJldC5lZGdlcyA9IFtdO1xuXHQgICAgICBpZiAobm9kZXMpIHJldC5ub2RlcyA9IFtdO1xuXHQgICAgICBpZiAobGFiZWxzKSByZXQubGFiZWxzID0gW107XG5cdFxuXHQgICAgICB2YXIgeCA9ICh4MSArIHgyKSAvIDI7XG5cdCAgICAgIHZhciB5ID0gKHkxICsgeTIpIC8gMjtcblx0XG5cdCAgICAgIHZhciBkYXRhID0gdGhpcy5yYnVzaHRyZWUuc2VhcmNoKFt4MSAtIF9nZW9tdG9vbHMuRVBTLCB5MSAtIF9nZW9tdG9vbHMuRVBTLCB4MiArIF9nZW9tdG9vbHMuRVBTLCB5MiArIF9nZW9tdG9vbHMuRVBTXSk7XG5cdCAgICAgIGlmIChsYWJlbHMpIHtcblx0ICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMucmJ1c2h0cmVlX3MpIHtcblx0ICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdCh0aGlzLnJidXNodHJlZV9zW3NdLnNlYXJjaChbeDEgLSBfZ2VvbXRvb2xzLkVQUywgeTEgLSBfZ2VvbXRvb2xzLkVQUywgeDIgKyBfZ2VvbXRvb2xzLkVQUywgeTIgKyBfZ2VvbXRvb2xzLkVQU10pKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBlID0gZGF0YVtpXVs0XTtcblx0ICAgICAgICB2YXIgZGlzdDIgPSBlLmRpc3QyKHgsIHksIGNvbnRleHQsIHNpemUsIHRoaXMubm9ybWFsaXplLCB0aGlzLnRleHRzKTtcblx0ICAgICAgICBpZiAoIWUuaW50ZXJzZWN0c1JlY3QoeDEsIHkxLCB4MiwgeTIsIGNvbnRleHQsIHNpemUsIHRoaXMubm9ybWFsaXplLCB0aGlzLnRleHRzKSkgY29udGludWU7XG5cdFxuXHQgICAgICAgIHRoaXMuX3RyeUFkZEVsKHJldCwgZSwgZGlzdDIsIG5vZGVzLCBlZGdlcywgbGFiZWxzKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgZm9yICh2YXIgayBpbiByZXQpIHtcblx0ICAgICAgICByZXRba10uc29ydChzb3J0QnlEaXN0YW5jZXMpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2ZpbmQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQoY29udGV4dCwgeCwgeSwgcmFkaXVzLCBzaXplLCBub2RlcywgZWRnZXMsIGxhYmVscykge1xuXHQgICAgICB2YXIgcmV0ID0ge307XG5cdCAgICAgIGlmIChlZGdlcykgcmV0LmVkZ2VzID0gW107XG5cdCAgICAgIGlmIChub2RlcykgcmV0Lm5vZGVzID0gW107XG5cdCAgICAgIGlmIChsYWJlbHMpIHJldC5sYWJlbHMgPSBbXTtcblx0XG5cdCAgICAgIHZhciB4cmFkaXVzID0gcmFkaXVzO1xuXHQgICAgICB2YXIgeXJhZGl1cyA9IHJhZGl1cztcblx0XG5cdCAgICAgIHZhciByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuXHRcblx0ICAgICAgdmFyIGRhdGEgPSB0aGlzLnJidXNodHJlZS5zZWFyY2goW3ggLSB4cmFkaXVzLCB5IC0geXJhZGl1cywgeCArIHhyYWRpdXMsIHkgKyB5cmFkaXVzXSk7XG5cdCAgICAgIGlmIChsYWJlbHMpIHtcblx0ICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMucmJ1c2h0cmVlX3MpIHtcblx0ICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdCh0aGlzLnJidXNodHJlZV9zW3NdLnNlYXJjaChbeCAtIHhyYWRpdXMsIHkgLSB5cmFkaXVzLCB4ICsgeHJhZGl1cywgeSArIHlyYWRpdXNdKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZSA9IGRhdGFbaV1bNF07XG5cdCAgICAgICAgdmFyIGRpc3QyID0gZS5kaXN0Mih4LCB5LCBjb250ZXh0LCBzaXplLCB0aGlzLm5vcm1hbGl6ZSwgdGhpcy50ZXh0cyk7XG5cdCAgICAgICAgaWYgKGRpc3QyID4gcmFkaXVzMikgY29udGludWU7XG5cdFxuXHQgICAgICAgIHRoaXMuX3RyeUFkZEVsKHJldCwgZSwgZGlzdDIsIG5vZGVzLCBlZGdlcywgbGFiZWxzKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgZm9yICh2YXIgayBpbiByZXQpIHtcblx0ICAgICAgICByZXRba10uc29ydChzb3J0QnlEaXN0YW5jZXMpO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3VwZGF0ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGNvbnRleHQsIHQsIGksIHYpIHtcblx0ICAgICAgLy9pbml0IGFsbCBlbGVtZW50cyBpbnRvIHJidXNoIHRyZWUgd2l0aCBzaXplIDEgKHRoZSBiaWdnZXN0IHBvc3NpYmxlIC0gdGhlIHdvcnN0IGNhc2UpXG5cdCAgICAgIHZhciBzaXplID0gMTtcblx0XG5cdCAgICAgIHRoaXMucmJ1c2h0cmVlLnJlbW92ZSh0aGlzLnR5cGVzW3RdW2ldKTtcblx0XG5cdCAgICAgIHZhciBlID0gbmV3IHRDb25zdFt0XSh2KTtcblx0ICAgICAgdmFyIGFyciA9IGUuZ2V0QkJveChjb250ZXh0LCBzaXplLCB0aGlzLm5vcm1hbGl6ZSwgdGhpcy50ZXh0cyk7XG5cdCAgICAgIGFyci5wdXNoKGUpO1xuXHRcblx0ICAgICAgdGhpcy5yYnVzaHRyZWUuaW5zZXJ0KHRoaXMudHlwZXNbdF1baV0gPSBhcnIpO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIHNwYXRpYWxJbmRleDtcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gc3BhdGlhbEluZGV4O1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0Lypcblx0IChjKSAyMDE1LCBWbGFkaW1pciBBZ2Fmb25raW5cblx0IFJCdXNoLCBhIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgaGlnaC1wZXJmb3JtYW5jZSAyRCBzcGF0aWFsIGluZGV4aW5nIG9mIHBvaW50cyBhbmQgcmVjdGFuZ2xlcy5cblx0IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG5cdCovXG5cdFxuXHRmdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcblx0ICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblx0XG5cdCAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuXHQgICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG5cdCAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcblx0XG5cdCAgICBpZiAoZm9ybWF0KSB7XG5cdCAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xuXHQgICAgfVxuXHRcblx0ICAgIHRoaXMuY2xlYXIoKTtcblx0fVxuXHRcblx0cmJ1c2gucHJvdG90eXBlID0ge1xuXHRcblx0ICAgIGFsbDogZnVuY3Rpb24gYWxsKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG5cdCAgICB9LFxuXHRcblx0ICAgIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKGJib3gpIHtcblx0XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG5cdCAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuXHQgICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblx0XG5cdCAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUuYmJveCkpIHJldHVybiByZXN1bHQ7XG5cdFxuXHQgICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG5cdCAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgIGxlbixcblx0ICAgICAgICAgICAgY2hpbGQsXG5cdCAgICAgICAgICAgIGNoaWxkQkJveDtcblx0XG5cdCAgICAgICAgd2hpbGUgKG5vZGUpIHtcblx0ICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcblx0ICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblx0ICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94O1xuXHRcblx0ICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7ZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO2Vsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9LFxuXHRcblx0ICAgIGNvbGxpZGVzOiBmdW5jdGlvbiBjb2xsaWRlcyhiYm94KSB7XG5cdFxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuXHQgICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblx0XG5cdCAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUuYmJveCkpIHJldHVybiBmYWxzZTtcblx0XG5cdCAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgbGVuLFxuXHQgICAgICAgICAgICBjaGlsZCxcblx0ICAgICAgICAgICAgY2hpbGRCQm94O1xuXHRcblx0ICAgICAgICB3aGlsZSAobm9kZSkge1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFxuXHQgICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXHQgICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3g7XG5cdFxuXHQgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0sXG5cdFxuXHQgICAgbG9hZDogZnVuY3Rpb24gbG9hZChkYXRhKSB7XG5cdCAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXHRcblx0ICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzdHJhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblx0XG5cdCAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuXHQgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcblx0ICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuXHQgICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcblx0ICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuXHQgICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH0sXG5cdFxuXHQgICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoaXRlbSkge1xuXHQgICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblx0XG5cdCAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG5cdCAgICAgICAgdGhpcy5kYXRhID0ge1xuXHQgICAgICAgICAgICBjaGlsZHJlbjogW10sXG5cdCAgICAgICAgICAgIGhlaWdodDogMSxcblx0ICAgICAgICAgICAgYmJveDogZW1wdHkoKSxcblx0ICAgICAgICAgICAgbGVhZjogdHJ1ZVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9LFxuXHRcblx0ICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGl0ZW0pIHtcblx0ICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiB0aGlzO1xuXHRcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcblx0ICAgICAgICAgICAgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pLFxuXHQgICAgICAgICAgICBwYXRoID0gW10sXG5cdCAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgcGFyZW50LFxuXHQgICAgICAgICAgICBpbmRleCxcblx0ICAgICAgICAgICAgZ29pbmdVcDtcblx0XG5cdCAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG5cdCAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblx0XG5cdCAgICAgICAgICAgIGlmICghbm9kZSkge1xuXHQgICAgICAgICAgICAgICAgLy8gZ28gdXBcblx0ICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXHQgICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgaWYgKG5vZGUubGVhZikge1xuXHQgICAgICAgICAgICAgICAgLy8gY2hlY2sgY3VycmVudCBub2RlXG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IG5vZGUuY2hpbGRyZW4uaW5kZXhPZihpdGVtKTtcblx0XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLmJib3gsIGJib3gpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBnbyBkb3duXG5cdCAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cdCAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGdvIHJpZ2h0XG5cdCAgICAgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXHQgICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfSxcblx0XG5cdCAgICB0b0JCb3g6IGZ1bmN0aW9uIHRvQkJveChpdGVtKSB7XG5cdCAgICAgICAgcmV0dXJuIGl0ZW07XG5cdCAgICB9LFxuXHRcblx0ICAgIGNvbXBhcmVNaW5YOiBmdW5jdGlvbiBjb21wYXJlTWluWChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuXHQgICAgfSxcblx0ICAgIGNvbXBhcmVNaW5ZOiBmdW5jdGlvbiBjb21wYXJlTWluWShhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIGFbMV0gLSBiWzFdO1xuXHQgICAgfSxcblx0XG5cdCAgICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuXHQgICAgfSxcblx0XG5cdCAgICBmcm9tSlNPTjogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuXHQgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9LFxuXHRcblx0ICAgIF9hbGw6IGZ1bmN0aW9uIF9hbGwobm9kZSwgcmVzdWx0KSB7XG5cdCAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcblx0ICAgICAgICB3aGlsZSAobm9kZSkge1xuXHQgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO2Vsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXHRcblx0ICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9LFxuXHRcblx0ICAgIF9idWlsZDogZnVuY3Rpb24gX2J1aWxkKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cdFxuXHQgICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcblx0ICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG5cdCAgICAgICAgICAgIG5vZGU7XG5cdFxuXHQgICAgICAgIGlmIChOIDw9IE0pIHtcblx0ICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuXHQgICAgICAgICAgICBub2RlID0ge1xuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSksXG5cdCAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG5cdCAgICAgICAgICAgICAgICBiYm94OiBudWxsLFxuXHQgICAgICAgICAgICAgICAgbGVhZjogdHJ1ZVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cdCAgICAgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgaWYgKCFoZWlnaHQpIHtcblx0ICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuXHQgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cdFxuXHQgICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG5cdCAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIG5vZGUgPSB7XG5cdCAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcblx0ICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG5cdCAgICAgICAgICAgIGJib3g6IG51bGwsXG5cdCAgICAgICAgICAgIGxlYWY6IGZhbHNlXG5cdCAgICAgICAgfTtcblx0XG5cdCAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cdFxuXHQgICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG5cdCAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgaixcblx0ICAgICAgICAgICAgcmlnaHQyLFxuXHQgICAgICAgICAgICByaWdodDM7XG5cdFxuXHQgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXHRcblx0ICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cdFxuXHQgICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cdFxuXHQgICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cdFxuXHQgICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXHRcblx0ICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cdFxuXHQgICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG5cdCAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cdFxuXHQgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgfSxcblx0XG5cdCAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gX2Nob29zZVN1YnRyZWUoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblx0XG5cdCAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblx0XG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXHRcblx0ICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblx0XG5cdCAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXHRcblx0ICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXHQgICAgICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGNoaWxkLmJib3gpO1xuXHQgICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQuYmJveCkgLSBhcmVhO1xuXHRcblx0ICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZSB8fCBub2RlLmNoaWxkcmVuWzBdO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICB9LFxuXHRcblx0ICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIF9pbnNlcnQoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXHRcblx0ICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG5cdCAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtLmJib3ggOiB0b0JCb3goaXRlbSksXG5cdCAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblx0XG5cdCAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblx0XG5cdCAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcblx0ICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG5cdCAgICAgICAgZXh0ZW5kKG5vZGUuYmJveCwgYmJveCk7XG5cdFxuXHQgICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuXHQgICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG5cdCAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG5cdCAgICAgICAgICAgICAgICBsZXZlbC0tO1xuXHQgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuXHQgICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG5cdCAgICB9LFxuXHRcblx0ICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuXHQgICAgX3NwbGl0OiBmdW5jdGlvbiBfc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblx0XG5cdCAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcblx0ICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuXHQgICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblx0XG5cdCAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXHRcblx0ICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cdFxuXHQgICAgICAgIHZhciBuZXdOb2RlID0ge1xuXHQgICAgICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSxcblx0ICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCxcblx0ICAgICAgICAgICAgYmJveDogbnVsbCxcblx0ICAgICAgICAgICAgbGVhZjogZmFsc2Vcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICBpZiAobm9kZS5sZWFmKSBuZXdOb2RlLmxlYWYgPSB0cnVlO1xuXHRcblx0ICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cdCAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXHRcblx0ICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO2Vsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuXHQgICAgfSxcblx0XG5cdCAgICBfc3BsaXRSb290OiBmdW5jdGlvbiBfc3BsaXRSb290KG5vZGUsIG5ld05vZGUpIHtcblx0ICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcblx0ICAgICAgICB0aGlzLmRhdGEgPSB7XG5cdCAgICAgICAgICAgIGNoaWxkcmVuOiBbbm9kZSwgbmV3Tm9kZV0sXG5cdCAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgKyAxLFxuXHQgICAgICAgICAgICBiYm94OiBudWxsLFxuXHQgICAgICAgICAgICBsZWFmOiBmYWxzZVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG5cdCAgICB9LFxuXHRcblx0ICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiBfY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKSB7XG5cdFxuXHQgICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXHRcblx0ICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXHRcblx0ICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcblx0ICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG5cdCAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXHRcblx0ICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcblx0ICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblx0XG5cdCAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcblx0ICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG5cdCAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcblx0ICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblx0XG5cdCAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuXHQgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICB9LFxuXHRcblx0ICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcblx0ICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIF9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSkge1xuXHRcblx0ICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxuXHQgICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG5cdCAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcblx0ICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXHRcblx0ICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuXHQgICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcblx0ICAgIH0sXG5cdFxuXHQgICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcblx0ICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiBfYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cdFxuXHQgICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblx0XG5cdCAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuXHQgICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG5cdCAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxuXHQgICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgY2hpbGQ7XG5cdFxuXHQgICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblx0ICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG5cdCAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcblx0ICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXHQgICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG5cdCAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICByZXR1cm4gbWFyZ2luO1xuXHQgICAgfSxcblx0XG5cdCAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiBfYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIHBhdGgsIGxldmVsKSB7XG5cdCAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICBleHRlbmQocGF0aFtpXS5iYm94LCBiYm94KTtcblx0ICAgICAgICB9XG5cdCAgICB9LFxuXHRcblx0ICAgIF9jb25kZW5zZTogZnVuY3Rpb24gX2NvbmRlbnNlKHBhdGgpIHtcblx0ICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcblx0ICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXHQgICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdFxuXHQgICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIF9pbml0Rm9ybWF0KGZvcm1hdCkge1xuXHQgICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblx0XG5cdCAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxuXHQgICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuXHQgICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cdFxuXHQgICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblx0XG5cdCAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuXHQgICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblx0XG5cdCAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLCAncmV0dXJuIFthJyArIGZvcm1hdC5qb2luKCcsIGEnKSArICddOycpO1xuXHQgICAgfVxuXHR9O1xuXHRcblx0Ly8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuXHRmdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcblx0ICAgIG5vZGUuYmJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gpO1xuXHR9XG5cdFxuXHQvLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuXHRmdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gpIHtcblx0ICAgIHZhciBiYm94ID0gZW1wdHkoKTtcblx0XG5cdCAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcblx0ICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cdCAgICAgICAgZXh0ZW5kKGJib3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gYmJveDtcblx0fVxuXHRcblx0ZnVuY3Rpb24gZW1wdHkoKSB7XG5cdCAgICByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuXHQgICAgYVswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuXHQgICAgYVsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuXHQgICAgYVsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuXHQgICAgYVszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuXHQgICAgcmV0dXJuIGE7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7XG5cdCAgICByZXR1cm4gYS5iYm94WzBdIC0gYi5iYm94WzBdO1xuXHR9XG5cdGZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7XG5cdCAgICByZXR1cm4gYS5iYm94WzFdIC0gYi5iYm94WzFdO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBiYm94QXJlYShhKSB7XG5cdCAgICByZXR1cm4gKGFbMl0gLSBhWzBdKSAqIChhWzNdIC0gYVsxXSk7XG5cdH1cblx0ZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7XG5cdCAgICByZXR1cm4gYVsyXSAtIGFbMF0gKyAoYVszXSAtIGFbMV0pO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuXHQgICAgcmV0dXJuIChNYXRoLm1heChiWzJdLCBhWzJdKSAtIE1hdGgubWluKGJbMF0sIGFbMF0pKSAqIChNYXRoLm1heChiWzNdLCBhWzNdKSAtIE1hdGgubWluKGJbMV0sIGFbMV0pKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG5cdCAgICB2YXIgbWluWCA9IE1hdGgubWF4KGFbMF0sIGJbMF0pLFxuXHQgICAgICAgIG1pblkgPSBNYXRoLm1heChhWzFdLCBiWzFdKSxcblx0ICAgICAgICBtYXhYID0gTWF0aC5taW4oYVsyXSwgYlsyXSksXG5cdCAgICAgICAgbWF4WSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuXHRcblx0ICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKiBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcblx0ICAgIHJldHVybiBhWzBdIDw9IGJbMF0gJiYgYVsxXSA8PSBiWzFdICYmIGJbMl0gPD0gYVsyXSAmJiBiWzNdIDw9IGFbM107XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuXHQgICAgcmV0dXJuIGJbMF0gPD0gYVsyXSAmJiBiWzFdIDw9IGFbM10gJiYgYlsyXSA+PSBhWzBdICYmIGJbM10gPj0gYVsxXTtcblx0fVxuXHRcblx0Ly8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG5cdC8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXHRcblx0ZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuXHQgICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcblx0ICAgICAgICBtaWQ7XG5cdFxuXHQgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuXHQgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXHRcblx0ICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXHRcblx0ICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcblx0ICAgICAgICBzZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbWlkLCBjb21wYXJlKTtcblx0XG5cdCAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuXHQgICAgfVxuXHR9XG5cdFxuXHQvLyBGbG95ZC1SaXZlc3Qgc2VsZWN0aW9uIGFsZ29yaXRobTpcblx0Ly8gc29ydCBhbiBhcnJheSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IChpbmNsdXNpdmUpIHNvIHRoYXQgdGhlIHNtYWxsZXN0IGsgZWxlbWVudHMgY29tZSBmaXJzdCAodW5vcmRlcmVkKVxuXHRmdW5jdGlvbiBzZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgaywgY29tcGFyZSkge1xuXHQgICAgdmFyIG4sIGksIHosIHMsIHNkLCBuZXdMZWZ0LCBuZXdSaWdodCwgdCwgajtcblx0XG5cdCAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG5cdCAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuXHQgICAgICAgICAgICBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcblx0ICAgICAgICAgICAgaSA9IGsgLSBsZWZ0ICsgMTtcblx0ICAgICAgICAgICAgeiA9IE1hdGgubG9nKG4pO1xuXHQgICAgICAgICAgICBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcblx0ICAgICAgICAgICAgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAoaSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG5cdCAgICAgICAgICAgIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBpICogcyAvIG4gKyBzZCkpO1xuXHQgICAgICAgICAgICBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIGkpICogcyAvIG4gKyBzZCkpO1xuXHQgICAgICAgICAgICBzZWxlY3QoYXJyLCBuZXdMZWZ0LCBuZXdSaWdodCwgaywgY29tcGFyZSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB0ID0gYXJyW2tdO1xuXHQgICAgICAgIGkgPSBsZWZ0O1xuXHQgICAgICAgIGogPSByaWdodDtcblx0XG5cdCAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuXHQgICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblx0XG5cdCAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG5cdCAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcblx0ICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICBqLS07XG5cdCAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICBpKys7XG5cdCAgICAgICAgICAgIH13aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgai0tO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7ZWxzZSB7XG5cdCAgICAgICAgICAgIGorKztcblx0ICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcblx0ICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuXHQgICAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuXHQgICAgdmFyIHRtcCA9IGFycltpXTtcblx0ICAgIGFycltpXSA9IGFycltqXTtcblx0ICAgIGFycltqXSA9IHRtcDtcblx0fVxuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gcmJ1c2g7XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5uZXEgPSBleHBvcnRzLmVxID0gZXhwb3J0cy5nZXRCQkZyb21Qb2ludHMgPSBleHBvcnRzLnBEaXN0YW5jZTIgPSBleHBvcnRzLmRpc3RhbmNlMiA9IGV4cG9ydHMuZGlzdGFuY2UyVG9CZXppZXIgPSBleHBvcnRzLnBvaW50SW5SZWN0ID0gZXhwb3J0cy5yZWN0SW50ZXJzZWN0c1JlY3QgPSBleHBvcnRzLmxpbmVJbnRlcnNlY3RzUmVjdCA9IGV4cG9ydHMuYmV6aWVySW50ZXJzZWN0c0xpbmUgPSBleHBvcnRzLmJlemllckludGVyc2VjdHNSZWN0ID0gZXhwb3J0cy5FUFMgPSB1bmRlZmluZWQ7XG5cdFxuXHR2YXIgX3JidXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cdFxuXHR2YXIgX3JidXNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JidXNoKTtcblx0XG5cdHZhciBfZ2VvbXV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdFxuXHR2YXIgX2dlb211dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZW9tdXRpbHMpO1xuXHRcblx0dmFyIF9wcmltaXRpdmVUb29scyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IEFsZcWhIFNhc2thIC0gaHR0cDovL2FsZXNzYXNrYS5jei9cblx0ICovXG5cdFxuXHR2YXIgRVBTID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5cdFxuXHQvL3NvbHZpbmcgY3ViZSBhbmFseXRpY2FseSBmb3IgYmV6aWVyIGN1cnZlc1xuXHRmdW5jdGlvbiBjdWJlcm9vdCh4KSB7XG5cdCAgdmFyIHkgPSBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuXHQgIHJldHVybiB4IDwgMCA/IC15IDogeTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gc29sdmVDdWJpYyhhLCBiLCBjLCBkKSB7XG5cdCAgaWYgKE1hdGguYWJzKGEpIDwgMWUtOCkge1xuXHQgICAgLy8gUXVhZHJhdGljIGNhc2UsIGF4XjIrYngrYz0wXG5cdCAgICBhID0gYjtiID0gYztjID0gZDtcblx0ICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTgpIHtcblx0ICAgICAgLy8gTGluZWFyIGNhc2UsIGF4K2I9MFxuXHQgICAgICBhID0gYjtiID0gYztcblx0ICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtOCkgLy8gRGVnZW5lcmF0ZSBjYXNlXG5cdCAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICByZXR1cm4gWy1iIC8gYV07XG5cdCAgICB9XG5cdFxuXHQgICAgdmFyIEQgPSBiICogYiAtIDQgKiBhICogYztcblx0ICAgIGlmIChNYXRoLmFicyhEKSA8IDFlLTgpIHJldHVybiBbLWIgLyAoMiAqIGEpXTtlbHNlIGlmIChEID4gMCkgcmV0dXJuIFsoLWIgKyBNYXRoLnNxcnQoRCkpIC8gKDIgKiBhKSwgKC1iIC0gTWF0aC5zcXJ0KEQpKSAvICgyICogYSldO1xuXHQgICAgcmV0dXJuIFtdO1xuXHQgIH1cblx0XG5cdCAgLy8gQ29udmVydCB0byBkZXByZXNzZWQgY3ViaWMgdF4zK3B0K3EgPSAwIChzdWJzdCB4ID0gdCAtIGIvM2EpXG5cdCAgdmFyIHAgPSAoMyAqIGEgKiBjIC0gYiAqIGIpIC8gKDMgKiBhICogYSk7XG5cdCAgdmFyIHEgPSAoMiAqIGIgKiBiICogYiAtIDkgKiBhICogYiAqIGMgKyAyNyAqIGEgKiBhICogZCkgLyAoMjcgKiBhICogYSAqIGEpO1xuXHQgIHZhciByb290cyA9IHZvaWQgMDtcblx0XG5cdCAgaWYgKE1hdGguYWJzKHApIDwgMWUtOCkge1xuXHQgICAgLy8gcCA9IDAgLT4gdF4zID0gLXEgLT4gdCA9IC1xXjEvM1xuXHQgICAgcm9vdHMgPSBbY3ViZXJvb3QoLXEpXTtcblx0ICB9IGVsc2UgaWYgKE1hdGguYWJzKHEpIDwgMWUtOCkge1xuXHQgICAgLy8gcSA9IDAgLT4gdF4zICsgcHQgPSAwIC0+IHQodF4yK3ApPTBcblx0ICAgIHJvb3RzID0gWzBdLmNvbmNhdChwIDwgMCA/IFtNYXRoLnNxcnQoLXApLCAtTWF0aC5zcXJ0KC1wKV0gOiBbXSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBfRCA9IHEgKiBxIC8gNCArIHAgKiBwICogcCAvIDI3O1xuXHQgICAgaWYgKE1hdGguYWJzKF9EKSA8IDFlLTgpIHtcblx0ICAgICAgLy8gRCA9IDAgLT4gdHdvIHJvb3RzXG5cdCAgICAgIHJvb3RzID0gWy0xLjUgKiBxIC8gcCwgMyAqIHEgLyBwXTtcblx0ICAgIH0gZWxzZSBpZiAoX0QgPiAwKSB7XG5cdCAgICAgIC8vIE9ubHkgb25lIHJlYWwgcm9vdFxuXHQgICAgICB2YXIgdSA9IGN1YmVyb290KC1xIC8gMiAtIE1hdGguc3FydChfRCkpO1xuXHQgICAgICByb290cyA9IFt1IC0gcCAvICgzICogdSldO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gRCA8IDAsIHRocmVlIHJvb3RzLCBidXQgbmVlZHMgdG8gdXNlIGNvbXBsZXggbnVtYmVycy90cmlnb25vbWV0cmljIHNvbHV0aW9uXG5cdCAgICAgIHZhciBfdSA9IDIgKiBNYXRoLnNxcnQoLXAgLyAzKTtcblx0ICAgICAgdmFyIHQgPSBNYXRoLmFjb3MoMyAqIHEgLyBwIC8gX3UpIC8gMzsgLy8gRCA8IDAgaW1wbGllcyBwIDwgMCBhbmQgYWNvcyBhcmd1bWVudCBpbiBbLTEuLjFdXG5cdCAgICAgIHZhciBrID0gMiAqIE1hdGguUEkgLyAzO1xuXHQgICAgICByb290cyA9IFtfdSAqIE1hdGguY29zKHQpLCBfdSAqIE1hdGguY29zKHQgLSBrKSwgX3UgKiBNYXRoLmNvcyh0IC0gMiAqIGspXTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8vIENvbnZlcnQgYmFjayBmcm9tIGRlcHJlc3NlZCBjdWJpY1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJvb3RzW2ldIC09IGIgLyAoMyAqIGEpO1xuXHQgIH1yZXR1cm4gcm9vdHM7XG5cdH1cblx0XG5cdC8vZnVuY3Rpb24gZGlzdGFuY2VUb0Jlemllcih4LHksYXgsYXksYngsYnksY3gsY3kpe1xuXHRmdW5jdGlvbiBkaXN0YW5jZTJUb0Jlemllcih4LCB5LCBhLCBkLCBiLCBlLCBjLCBmKSB7XG5cdCAgLy9iYXNlZCBvbiBjb21wdXRlIGRlcml2YXRpb24gb2Y6IGQvZHQgKChYIC0gKGEqKDEtdCkqKDEtdCkrMipiKnQqKDEtdCkrYyp0KnQpKV4yICsgKFkgLSAoZCooMS10KSooMS10KSsyKmUqdCooMS10KStmKnQqdCkpXjIpXG5cdFxuXHQgIHZhciBBID0gNCAqIGEgKiBhIC0gMTYgKiBhICogYiArIDggKiBhICogYyArIDE2ICogYiAqIGIgLSAxNiAqIGIgKiBjICsgNCAqIGMgKiBjICsgNCAqIGQgKiBkIC0gMTYgKiBkICogZSArIDggKiBkICogZiArIDE2ICogZSAqIGUgLSAxNiAqIGUgKiBmICsgNCAqIGYgKiBmO1xuXHQgIHZhciBCID0gLTEyICogYSAqIGEgKyAzNiAqIGEgKiBiIC0gMTIgKiBhICogYyAtIDI0ICogYiAqIGIgKyAxMiAqIGIgKiBjIC0gMTIgKiBkICogZCArIDM2ICogZCAqIGUgLSAxMiAqIGQgKiBmIC0gMjQgKiBlICogZSArIDEyICogZSAqIGY7XG5cdCAgdmFyIEMgPSAxMiAqIGEgKiBhIC0gMjQgKiBhICogYiArIDQgKiBhICogYyAtIDQgKiBhICogeCArIDggKiBiICogYiArIDggKiBiICogeCAtIDQgKiBjICogeCArIDEyICogZCAqIGQgLSAyNCAqIGQgKiBlICsgNCAqIGQgKiBmIC0gNCAqIGQgKiB5ICsgOCAqIGUgKiBlICsgOCAqIGUgKiB5IC0gNCAqIGYgKiB5O1xuXHQgIHZhciBEID0gLTQgKiBhICogYSArIDQgKiBhICogYiArIDQgKiBhICogeCAtIDQgKiBiICogeCAtIDQgKiBkICogZCArIDQgKiBkICogZSArIDQgKiBkICogeSAtIDQgKiBlICogeTtcblx0XG5cdCAgdmFyIGVxcmVzdWx0ID0gc29sdmVDdWJpYyhBLCBCLCBDLCBEKTtcblx0XG5cdCAgLy9sb29wIHRocm91Z2ggYWxsIHBvc3NpYmxlIHNvbGl0aW9ucyB0byBmaW5kIG91dCB3aGljaCBwb2ludCBpcyB0aGUgbmVhcmVzdFxuXHQgIHZhciBtaW5kaXN0ID0gSW5maW5pdHk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcXJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHQgPSBlcXJlc3VsdFtpXTtcblx0XG5cdCAgICBpZiAodCA8IDAgfHwgdCA+IDEpIGNvbnRpbnVlO1xuXHRcblx0ICAgIC8vcG9pbnQgYXQgYmV6aWVyIGN1cnZlXG5cdCAgICB2YXIgcHggPSBhICogKDEgLSB0KSAqICgxIC0gdCkgKyAyICogYiAqIHQgKiAoMSAtIHQpICsgYyAqIHQgKiB0O1xuXHQgICAgdmFyIHB5ID0gZCAqICgxIC0gdCkgKiAoMSAtIHQpICsgMiAqIGUgKiB0ICogKDEgLSB0KSArIGYgKiB0ICogdDtcblx0XG5cdCAgICB2YXIgZGlzdCA9IGRpc3RhbmNlMih4LCB5LCBweCwgcHkpO1xuXHQgICAgaWYgKGRpc3QgPCBtaW5kaXN0KSBtaW5kaXN0ID0gZGlzdDtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBtaW5kaXN0O1xuXHR9XG5cdFxuXHQvKlxuXHQgKiBAcGFyYW0gdiAtIGFycmF5IG9mIHdpdGggcG9pbnRzIFt4MSx5MSx4Mix5MiAuLi4uIF1cblx0ICogQHJldHVybiBhcnJheSByZXByZXNlbnRpbmcgYm91bmRpbmcgYm94IFt4MSx5MSx4Mix5Ml1cblx0ICovXG5cdGZ1bmN0aW9uIGdldEJCRnJvbVBvaW50cyh2KSB7XG5cdCAgdmFyIHhtaW4gPSBJbmZpbml0eTtcblx0ICB2YXIgeG1heCA9IC14bWluO1xuXHQgIHZhciB5bWluID0gSW5maW5pdHk7XG5cdCAgdmFyIHltYXggPSAteW1pbjtcblx0XG5cdCAgLy94IG9mIHBvaW50cyAtIGV2ZW4gaW5kZXhlcyBpbiBhcnJheSBcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHZhciB2YWwgPSB2W2ldO1xuXHQgICAgaWYgKHZhbCA8IHhtaW4pIHhtaW4gPSB2YWw7XG5cdCAgICBpZiAodmFsID4geG1heCkgeG1heCA9IHZhbDtcblx0ICB9XG5cdFxuXHQgIC8veSBvZiBwb2ludHMgLSBvZGQgaW5kZXhlcyBpbiBhcnJheSBcblx0ICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgdi5sZW5ndGg7IF9pICs9IDIpIHtcblx0ICAgIHZhciBfdmFsID0gdltfaV07XG5cdCAgICBpZiAoX3ZhbCA8IHltaW4pIHltaW4gPSBfdmFsO1xuXHQgICAgaWYgKF92YWwgPiB5bWF4KSB5bWF4ID0gX3ZhbDtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBbeG1pbiwgeW1pbiwgeG1heCwgeW1heF07XG5cdH1cblx0XG5cdC8vZGlzdGFuY2UgZnJvbSBwb2ludCB0byBwb2ludFxuXHRmdW5jdGlvbiBkaXN0YW5jZTIoeDEsIHkxLCB4MiwgeTIpIHtcblx0ICB2YXIgZHggPSB4MSAtIHgyO1xuXHQgIHZhciBkeSA9IHkxIC0geTI7XG5cdCAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXHR9XG5cdFxuXHQvL2Rpc3RhbmNlIGZyb20gcG9pbnQgdG8gbGluZVxuXHRmdW5jdGlvbiBwRGlzdGFuY2UyKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG5cdCAgdmFyIEEgPSB4IC0geDE7XG5cdCAgdmFyIEIgPSB5IC0geTE7XG5cdCAgdmFyIEMgPSB4MiAtIHgxO1xuXHQgIHZhciBEID0geTIgLSB5MTtcblx0XG5cdCAgdmFyIGRvdCA9IEEgKiBDICsgQiAqIEQ7XG5cdCAgdmFyIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQ7XG5cdCAgdmFyIHBhcmFtID0gLTE7XG5cdCAgaWYgKGxlbl9zcSAhPSAwKSAvL2luIGNhc2Ugb2YgMCBsZW5ndGggbGluZVxuXHQgICAgcGFyYW0gPSBkb3QgLyBsZW5fc3E7XG5cdFxuXHQgIHZhciB4eCA9IHZvaWQgMCxcblx0ICAgICAgeXkgPSB2b2lkIDA7XG5cdFxuXHQgIGlmIChwYXJhbSA8IDApIHtcblx0ICAgIHh4ID0geDE7XG5cdCAgICB5eSA9IHkxO1xuXHQgIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG5cdCAgICB4eCA9IHgyO1xuXHQgICAgeXkgPSB5Mjtcblx0ICB9IGVsc2Uge1xuXHQgICAgeHggPSB4MSArIHBhcmFtICogQztcblx0ICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZGlzdGFuY2UyKHgsIHksIHh4LCB5eSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzTGluZShsMXAxeCwgbDFwMXksIGwxcDJ4LCBsMXAyeSwgbDJwMXgsIGwycDF5LCBsMnAyeCwgbDJwMnkpIHtcblx0ICB2YXIgcSA9IChsMXAxeSAtIGwycDF5KSAqIChsMnAyeCAtIGwycDF4KSAtIChsMXAxeCAtIGwycDF4KSAqIChsMnAyeSAtIGwycDF5KTtcblx0ICB2YXIgZCA9IChsMXAyeCAtIGwxcDF4KSAqIChsMnAyeSAtIGwycDF5KSAtIChsMXAyeSAtIGwxcDF5KSAqIChsMnAyeCAtIGwycDF4KTtcblx0XG5cdCAgaWYgKGQgPT0gMCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgdmFyIHIgPSBxIC8gZDtcblx0XG5cdCAgcSA9IChsMXAxeSAtIGwycDF5KSAqIChsMXAyeCAtIGwxcDF4KSAtIChsMXAxeCAtIGwycDF4KSAqIChsMXAyeSAtIGwxcDF5KTtcblx0ICB2YXIgcyA9IHEgLyBkO1xuXHRcblx0ICBpZiAociA8IDAgfHwgciA+IDEgfHwgcyA8IDAgfHwgcyA+IDEpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBwb2ludEluUmVjdChweCwgcHksIHgxLCB5MSwgeDIsIHkyKSB7XG5cdCAgcmV0dXJuIHB4ID49IHgxIC0gRVBTICYmIHB4IDw9IHgyICsgRVBTICYmIHB5ID49IHkxIC0gRVBTICYmIHB5IDw9IHkyICsgRVBTO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiByZWN0SW50ZXJzZWN0c1JlY3QocDF4LCBwMXksIHAyeCwgcDJ5LCByMXgsIHIxeSwgcjJ4LCByMnkpIHtcblx0ICByZXR1cm4gcDF4IDw9IHIyeCAmJiBwMXkgPD0gcjJ5ICYmIHAyeCA+PSByMXggJiYgcDJ5ID49IHIxeTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gbGluZUludGVyc2VjdHNSZWN0KHAxeCwgcDF5LCBwMngsIHAyeSwgcjF4LCByMXksIHIyeCwgcjJ5KSB7XG5cdCAgaWYgKHBvaW50SW5SZWN0KHAxeCwgcDF5LCByMXgsIHIxeSwgcjJ4LCByMnkpIHx8IHBvaW50SW5SZWN0KHAyeCwgcDJ5LCByMXgsIHIxeSwgcjJ4LCByMnkpKSByZXR1cm4gdHJ1ZTtcblx0XG5cdCAgcmV0dXJuIGxpbmVJbnRlcnNlY3RzTGluZShwMXgsIHAxeSwgcDJ4LCBwMnksIHIxeCwgcjF5LCByMngsIHIxeSkgfHwgbGluZUludGVyc2VjdHNMaW5lKHAxeCwgcDF5LCBwMngsIHAyeSwgcjJ4LCByMXksIHIyeCwgcjJ5KSB8fCBsaW5lSW50ZXJzZWN0c0xpbmUocDF4LCBwMXksIHAyeCwgcDJ5LCByMngsIHIyeSwgcjF4LCByMnkpIHx8IGxpbmVJbnRlcnNlY3RzTGluZShwMXgsIHAxeSwgcDJ4LCBwMnksIHIxeCwgcjJ5LCByMXgsIHIxeSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGVxKGEsIGIpIHtcblx0ICByZXR1cm4gYSA+PSBiIC0gRVBTICYmIGEgPD0gYiArIEVQUztcblx0fVxuXHRcblx0ZnVuY3Rpb24gbmVxKGEsIGIpIHtcblx0ICByZXR1cm4gIWVxKGEsIGIpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjaGVja0JlemllclRrb2VmKGEsIGQsIGIsIGUsIGMsIGYsIHQsIHEsIHMsIHIsIHYpIHtcblx0ICBpZiAodCA8IDAgfHwgdCA+IDEpIHJldHVybiBmYWxzZTtcblx0XG5cdCAgaWYgKG5lcSh2IC0gcywgMCkpIHtcblx0ICAgIHZhciB4ID0gKGQgKiAoMSAtIHQpICogKDEgLSB0KSArIDIgKiBlICogdCAqICgxIC0gdCkgKyBmICogdCAqIHQpIC8gKHYgLSBzKTtcblx0ICAgIGlmICh4IDwgMCB8fCB4ID4gMSkgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGJlemllckludGVyc2VjdHNMaW5lKGEsIGQsIGIsIGUsIGMsIGYsIHEsIHMsIHIsIHYpIHtcblx0ICAvL2Jhc2VkIG9uIHdvbGZyYW0gYWxwaGE6ID4+IHNvbHZlICgoZCooMS14KSooMS14KSsyKmUqeCooMS14KStmKngqeCkgPSBzICsgKCgtYSooeC0xKSooeC0xKSArIHgqKDIqYiooeC0xKS1jKngpK3EpLyhxLXIpKSoodiAtIHMpKSBmb3IgeCA8PFxuXHRcblx0ICB2YXIgdCA9IHZvaWQgMDtcblx0XG5cdCAgdmFyIHRkZW4gPSAtYSAqIHMgKyBhICogdiArIDIgKiBiICogcyAtIDIgKiBiICogdiAtIGMgKiBzICsgYyAqIHYgKyBkICogcSAtIGQgKiByIC0gMiAqIGUgKiBxICsgMiAqIGUgKiByICsgZiAqIHEgLSBmICogcjtcblx0ICBpZiAobmVxKHRkZW4sIDApKSB7XG5cdCAgICBpZiAobmVxKHEgLSByLCAwKSkge1xuXHQgICAgICB2YXIgc3ExID0gMiAqIGEgKiBzIC0gMiAqIGEgKiB2IC0gMiAqIGIgKiBzICsgMiAqIGIgKiB2IC0gMiAqIGQgKiByICsgMiAqIGUgKiBxIC0gMiAqIGUgKiByO1xuXHQgICAgICB2YXIgc3EgPSBzcTEgKiBzcTEgLSA0ICogKC1hICogcyArIGEgKiB2ICsgZCAqIHEgLSBkICogciAtIHEgKiB2ICsgciAqIHMpICogKC1hICogcyArIGEgKiB2ICsgMiAqIGIgKiBzIC0gMiAqIGIgKiB2IC0gYyAqIHMgKyBjICogdiArIGQgKiBxIC0gZCAqIHIgLSAyICogZSAqIHEgKyAyICogZSAqIHIgKyBmICogcSAtIGYgKiByKTtcblx0ICAgICAgaWYgKHNxID49IDApIHtcblx0ICAgICAgICB2YXIgdDEgPSBhICogcyAtIGEgKiB2IC0gYiAqIHMgKyBiICogdiAtIGQgKiBxICsgZCAqIHIgKyBlICogcSAtIGUgKiByO1xuXHRcblx0ICAgICAgICB0ID0gKHQxIC0gMC41ICogTWF0aC5zcXJ0KHNxKSkgLyB0ZGVuO1xuXHQgICAgICAgIGlmIChjaGVja0JlemllclRrb2VmKGEsIGQsIGIsIGUsIGMsIGYsIHEsIHMsIHIsIHYsIHQpKSByZXR1cm4gdHJ1ZTtcblx0XG5cdCAgICAgICAgdCA9ICh0MSArIDAuNSAqIE1hdGguc3FydChzcSkpIC8gdGRlbjtcblx0ICAgICAgICBpZiAoY2hlY2tCZXppZXJUa29lZihhLCBkLCBiLCBlLCBjLCBmLCBxLCBzLCByLCB2LCB0KSkgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIHRkZW4gPSAtYiAqIHMgKyBiICogdiArIGMgKiBzIC0gYyAqIHYgKyBlICogcSAtIGUgKiByIC0gZiAqIHEgKyBmICogcjtcblx0ICBpZiAoZXEoZCwgMiAqIGUgLSBmKSAmJiBlcShhLCAyICogYiAtIGMpICYmIG5lcSh0ZGVuLCAwKSAmJiBuZXEocSAqIHMgLSBxICogdiAtIHIgKiBzICsgciAqIHYsIDApKSB7XG5cdCAgICB0ID0gLTIgKiBiICogcyArIDIgKiBiICogdiArIGMgKiBzIC0gYyAqIHYgKyAyICogZSAqIHEgLSAyICogZSAqIHIgLSBmICogcSArIGYgKiByIC0gcSAqIHYgKyByICogcztcblx0ICAgIHQgPSB0IC8gKDIgKiB0ZGVuKTtcblx0ICAgIGlmIChjaGVja0JlemllclRrb2VmKGEsIGQsIGIsIGUsIGMsIGYsIHEsIHMsIHIsIHYsIHQpKSByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdFxuXHQgIGlmIChlcShzLCB2KSAmJiBlcShkLCAyICogZSAtIGYpICYmIG5lcShlIC0gZiwgMCkgJiYgbmVxKHEgLSByLCAwKSkge1xuXHQgICAgdCA9ICgyICogZSAtIGYgLSB2KSAvICgyICogKGUgLSBmKSk7XG5cdCAgICBpZiAoY2hlY2tCZXppZXJUa29lZihhLCBkLCBiLCBlLCBjLCBmLCBxLCBzLCByLCB2LCB0KSkgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHRcblx0ICB2YXIgYWVxID0gKDIgKiBiICogcyAtIDIgKiBiICogdiAtIGMgKiBzICsgYyAqIHYgKyBkICogcSAtIGQgKiByIC0gMiAqIGUgKiBxICsgMiAqIGUgKiByICsgZiAqIHEgLSBmICogcikgLyAocyAtIHYpO1xuXHQgIHZhciB2YWwgPSBiICogZCAqIHMgLSBiICogZCAqIHYgLSAyICogYiAqIGUgKiBzICsgMiAqIGIgKiBlICogdiArIGIgKiBmICogcyAtIGIgKiBmICogdiAtIGMgKiBkICogcyArIGMgKiBkICogdiArIDIgKiBjICogZSAqIHMgLSAyICogYyAqIGUgKiB2IC0gYyAqIGYgKiBzICsgYyAqIGYgKiB2IC0gZCAqIGUgKiBxICsgZCAqIGUgKiByICsgZCAqIGYgKiBxIC0gZCAqIGYgKiByICsgMiAqIGUgKiBlICogcSAtIDIgKiBlICogZSAqIHIgLSAzICogZSAqIGYgKiBxICsgMyAqIGUgKiBmICogciArIGYgKiBmICogcSAtIGYgKiBmICogcjtcblx0ICBpZiAoZXEoYSwgYWVxKSAmJiBuZXEodmFsLCAwKSAmJiBuZXEocSAtIHIsIDApKSB7XG5cdCAgICB0ID0gKDIgKiBiICogcyAtIDIgKiBiICogdiAtIGMgKiBzICsgYyAqIHYgLSAyICogZSAqIHEgKyAyICogZSAqIHIgKyBmICogcSAtIGYgKiByICsgcSAqIHYgLSByICogcykgLyAoMiAqIChiICogcyAtIGIgKiB2IC0gYyAqIHMgKyBjICogdiAtIGUgKiBxICsgZSAqIHIgKyBmICogcSAtIGYgKiByKSk7XG5cdCAgICBpZiAoY2hlY2tCZXppZXJUa29lZihhLCBkLCBiLCBlLCBjLCBmLCBxLCBzLCByLCB2LCB0KSkgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGJlemllckludGVyc2VjdHNSZWN0KGEsIGQsIGIsIGUsIGMsIGYsIHIxeCwgcjF5LCByMngsIHIyeSkge1xuXHQgIGlmIChwb2ludEluUmVjdChhLCBkLCByMXgsIHIxeSwgcjJ4LCByMnkpIHx8IHBvaW50SW5SZWN0KGMsIGYsIHIxeCwgcjF5LCByMngsIHIyeSkpIHJldHVybiB0cnVlO1xuXHRcblx0ICB2YXIgY2VudGVyeCA9IChyMXggKyByMngpIC8gMjtcblx0ICB2YXIgY2VudGVyeSA9IChyMXkgKyByMnkpIC8gMjtcblx0XG5cdCAgdmFyIGRpZmZ4ID0gcjF4IC0gcjJ4O1xuXHQgIHZhciBkaWZmeSA9IHIxeSAtIHIyeTtcblx0XG5cdCAgLy9wZXJmb3JtYW5jZSBvcHRpbWFsaXphdGlvbiBiYXNlZCBvbiBkaXN0YW5jZVxuXHQgIHZhciBkaWZmMnh5ID0gZGlmZnggKiBkaWZmeCArIGRpZmZ5ICogZGlmZnk7XG5cdCAgdmFyIGRpc3QyID0gZGlzdGFuY2UyVG9CZXppZXIoY2VudGVyeCwgY2VudGVyeSwgYSwgZCwgYiwgZSwgYywgZik7XG5cdCAgaWYgKGRpc3QyICogNCA+IGRpZmYyeHkpIHJldHVybiBmYWxzZTtcblx0ICBpZiAoZGlzdDIgKiA0IDw9IE1hdGgubWluKGRpZmZ4ICogZGlmZngsIGRpZmZ5ICogZGlmZnkpKSByZXR1cm4gdHJ1ZTtcblx0XG5cdCAgcmV0dXJuIGJlemllckludGVyc2VjdHNMaW5lKGEsIGQsIGIsIGUsIGMsIGYsIHIxeSwgcjJ4LCByMXksIHIxeSkgfHwgYmV6aWVySW50ZXJzZWN0c0xpbmUoYSwgZCwgYiwgZSwgYywgZiwgcjJ4LCByMXksIHIyeCwgcjJ5KSB8fCBiZXppZXJJbnRlcnNlY3RzTGluZShhLCBkLCBiLCBlLCBjLCBmLCByMngsIHIyeSwgcjF4LCByMnkpIHx8IGJlemllckludGVyc2VjdHNMaW5lKGEsIGQsIGIsIGUsIGMsIGYsIHIxeCwgcjJ5LCByMXgsIHIxeSk7XG5cdH1cblx0XG5cdGV4cG9ydHMuRVBTID0gRVBTO1xuXHRleHBvcnRzLmJlemllckludGVyc2VjdHNSZWN0ID0gYmV6aWVySW50ZXJzZWN0c1JlY3Q7XG5cdGV4cG9ydHMuYmV6aWVySW50ZXJzZWN0c0xpbmUgPSBiZXppZXJJbnRlcnNlY3RzTGluZTtcblx0ZXhwb3J0cy5saW5lSW50ZXJzZWN0c1JlY3QgPSBsaW5lSW50ZXJzZWN0c1JlY3Q7XG5cdGV4cG9ydHMucmVjdEludGVyc2VjdHNSZWN0ID0gcmVjdEludGVyc2VjdHNSZWN0O1xuXHRleHBvcnRzLnBvaW50SW5SZWN0ID0gcG9pbnRJblJlY3Q7XG5cdGV4cG9ydHMuZGlzdGFuY2UyVG9CZXppZXIgPSBkaXN0YW5jZTJUb0Jlemllcjtcblx0ZXhwb3J0cy5kaXN0YW5jZTIgPSBkaXN0YW5jZTI7XG5cdGV4cG9ydHMucERpc3RhbmNlMiA9IHBEaXN0YW5jZTI7XG5cdGV4cG9ydHMuZ2V0QkJGcm9tUG9pbnRzID0gZ2V0QkJGcm9tUG9pbnRzO1xuXHRleHBvcnRzLmVxID0gZXE7XG5cdGV4cG9ydHMubmVxID0gbmVxO1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXHRcblx0dmFyIF9nbCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2dsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3JzOiBEYXZpZCBUaWNoeSwgQWxlxaEgU2Fza2Fcblx0ICovXG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gX2NsYXNzKGV2ZW50cywgb25Mb2FkKSB7XG5cdCAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cdFxuXHQgICAgICAgIHRoaXMuX2xvYWQgPSBbZXZlbnRzLmRlYm91bmNlKG9uTG9hZCwgNSldO1xuXHQgICAgICAgIHRoaXMuX3RleHR1cmVzID0ge307XG5cdCAgICAgICAgdGhpcy5fcGVuZGluZyA9IHt9O1xuXHQgICAgICAgIHRoaXMuX24gPSAwO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiAnZ2V0Jyxcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGdsLCBpbWcsIGFjdGlvbiwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl9wZW5kaW5nW2ltZ107XG5cdCAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fdGV4dHVyZXNbaW1nXTtcblx0XG5cdCAgICAgICAgICAgIGlmIChwKSB7XG5cdCAgICAgICAgICAgICAgICBwLnB1c2goYWN0aW9uKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0KSB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb24gJiYgYWN0aW9uKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwID0gdGhpcy5fcGVuZGluZ1tpbWddID0gW2FjdGlvbl07XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9uKys7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlc1tpbWddID0gdCA9IF9nbDIuZGVmYXVsdC5jcmVhdGVUZXh0dXJlKGdsLCBpbWcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgJiYgYSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fcGVuZGluZ1tpbWddO1xuXHQgICAgICAgICAgICAgICAgICAgIC0tX3RoaXMuX24gfHwgX3RoaXMuX2xvYWQuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ29uTG9hZCcsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uTG9hZChhY3Rpb24pIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYWxsTG9hZGVkKCkpIGFjdGlvbigpO2Vsc2UgdGhpcy5fbG9hZC5wdXNoKGFjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ2FsbExvYWRlZCcsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsbExvYWRlZCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF91dGlsczIuZGVmYXVsdC5lbXB0eU9iamVjdCh0aGlzLl9wZW5kaW5nKTtcblx0ICAgICAgICB9XG5cdCAgICB9XSk7XG5cblx0ICAgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBfY2xhc3M7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHMpO1xuXHRcblx0dmFyIF9nbCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHR2YXIgX2dsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3JzOiBEYXZpZCBUaWNoeSwgQWxlxaEgU2Fza2Fcblx0ICovXG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIF9jbGFzcyhldmVudHMsIG9uTG9hZCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cdFxuXHQgICAgdGhpcy5fbG9hZCA9IFtldmVudHMuZGVib3VuY2Uob25Mb2FkIHx8IGZ1bmN0aW9uICgpIHt9LCA1KV07XG5cdCAgICB0aGlzLl9maWxlcyA9IHt9O1xuXHQgICAgdGhpcy5fcGVuZGluZyA9IHt9O1xuXHQgICAgdGhpcy5fbiA9IDA7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBbe1xuXHQgICAga2V5OiAnX3RyYW5zZm9ybUZpbGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1GaWxlKGRhdGEsIGRhdGFUeXBlKSB7XG5cdCAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ2pzb24nKSByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcblx0ICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZ2V0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQodXJsKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9maWxlc1t1cmxdO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qXG5cdCAgICAgKiBAcGFyYW0gdHlwZSB7XG5cdCAgICAgKiAgIHVybDogJ3VybCBvZiBmaWxlJyxcblx0ICAgICAqICAgc3VjY2VzczogY2FsbGJhY2tcblx0ICAgICAqICAgZGF0YVR5cGUgXCJ0ZXh0XCIgfHwgXCJqc29uXCJcblx0ICAgICAqIH1cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdsb2FkJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgYWN0aW9uLCBkYXRhVHlwZSkge1xuXHQgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgICAgdmFyIHAgPSB0aGlzLl9wZW5kaW5nW3VybF07XG5cdCAgICAgIHZhciBmID0gdGhpcy5fZmlsZXNbdXJsXTtcblx0XG5cdCAgICAgIGlmIChwKSB7XG5cdCAgICAgICAgcC5wdXNoKGFjdGlvbik7XG5cdCAgICAgIH0gZWxzZSBpZiAoZikge1xuXHQgICAgICAgIGFjdGlvbiAmJiBhY3Rpb24oKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBwID0gdGhpcy5fcGVuZGluZ1t1cmxdID0gW2FjdGlvbl07XG5cdCAgICAgICAgdGhpcy5fbisrO1xuXHRcblx0ICAgICAgICBfdXRpbHMyLmRlZmF1bHQuYWpheCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICBfdGhpcy5fZmlsZXNbdXJsXSA9IF90aGlzLl90cmFuc2Zvcm1GaWxlKGRhdGEsIGRhdGFUeXBlKTtcblx0ICAgICAgICAgIHAuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuXHQgICAgICAgICAgICByZXR1cm4gYSAmJiBhKF90aGlzLl9maWxlc1t1cmxdKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgZGVsZXRlIF90aGlzLl9wZW5kaW5nW3VybF07XG5cdCAgICAgICAgICAtLV90aGlzLl9uIHx8IF90aGlzLl9sb2FkLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGwoKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sIGRhdGFUeXBlID09ICdhcnJheWJ1ZmZlcicgPyBkYXRhVHlwZSA6IHVuZGVmaW5lZCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGY7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnb25Mb2FkJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxvYWQoYWN0aW9uKSB7XG5cdCAgICAgIGlmICh0aGlzLmFsbExvYWRlZCgpKSBhY3Rpb24oKTtlbHNlIHRoaXMuX2xvYWQucHVzaChhY3Rpb24pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2FsbExvYWRlZCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYWxsTG9hZGVkKCkge1xuXHQgICAgICByZXR1cm4gX3V0aWxzMi5kZWZhdWx0LmVtcHR5T2JqZWN0KHRoaXMuX3BlbmRpbmcpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBfY2xhc3M7XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7IC8qKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIENvcHlyaWdodCAoYykgMjAxNiwgSGVsaWthciBMYWIuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR1BMdjMgTGljZW5zZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBBdXRob3JzOiBEYXZpZCBUaWNoeSwgQWxlxaEgU2Fza2Fcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHRcblx0dmFyIF9kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cdFxuXHR2YXIgX2RlZmF1bHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdCk7XG5cdFxuXHR2YXIgX3NkZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuXHRcblx0dmFyIF9zZGYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2RmKTtcblx0XG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcblx0dmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBfY2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gX2NsYXNzKGdsLCBmaWxlcywgdGV4dHVyZXMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHRcblx0ICAgIHRoaXMuX2dsID0gZ2w7XG5cdFxuXHQgICAgdGhpcy5fbW9kdWxlcyA9IHtcblx0ICAgICAgJ2RlZmF1bHQnOiBuZXcgX2RlZmF1bHQyLmRlZmF1bHQoZ2wsIGZpbGVzLCB0ZXh0dXJlcyksXG5cdCAgICAgICdzZGYnOiBuZXcgX3NkZjIuZGVmYXVsdChnbCwgZmlsZXMsIHRleHR1cmVzKVxuXHQgICAgfTtcblx0ICB9XG5cdFxuXHQgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICBrZXk6ICdjbGVhcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG5cdCAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fbW9kdWxlcykge1xuXHQgICAgICAgIHRoaXMuX21vZHVsZXNba10uY2xlYXIoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2lzU0RGJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NERihmb250KSB7XG5cdCAgICAgIGlmIChfdXRpbHMyLmRlZmF1bHQuaXNPYmplY3QoZm9udCkpIHtcblx0ICAgICAgICBpZiAoZm9udC50eXBlID09PSAnc2RmJyAmJiBmb250LnBiZikge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdnZXRFbmdpbmUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVuZ2luZShmb250KSB7XG5cdCAgICAgIGlmICh0aGlzLmlzU0RGKGZvbnQpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX21vZHVsZXMuc2RmO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9tb2R1bGVzLmRlZmF1bHQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnYmluZCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYmluZCgpIHtcblx0ICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9tb2R1bGVzKSB7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxlc1trXS5iaW5kKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZW1vdmUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0ICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9tb2R1bGVzKSB7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxlc1trXS5yZW1vdmUgJiYgdGhpcy5fbW9kdWxlc1trXS5yZW1vdmUoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHQvKipcblx0ICogIENvcHlyaWdodCAoYykgMjAxNiwgSGVsaWthciBMYWIuXG5cdCAqICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXHQgKlxuXHQgKiAgVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgR1BMdjMgTGljZW5zZS5cblx0ICogIEF1dGhvcnM6IERhdmlkIFRpY2h5LCBBbGXFoSBTYXNrYVxuXHQgKi9cblx0XG5cdHZhciBfY2xhc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gX2NsYXNzKGdsLCBmaWxlcywgdGV4dHVyZXMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHRcblx0ICAgIHRoaXMuX2dsID0gZ2w7XG5cdCAgICB0aGlzLl9zaXplID0gMTAyNDtcblx0XG5cdCAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHQgICAgdGhpcy5fY2FudmFzLndpZHRoID0gdGhpcy5fY2FudmFzLmhlaWdodCA9IHRoaXMuX3NpemU7XG5cdCAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fc2l6ZSArICdweCc7XG5cdCAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgdGhpcy5fZWwgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG5cdFxuXHQgICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHQgICAgdGhpcy5fY29udGV4dC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG5cdCAgICB0aGlzLl9jb250ZXh0LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHQgICAgdGhpcy5fY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcblx0ICAgIHRoaXMuX3JlbmRlcmVkID0gdGhpcy5fdGV4dHMgPSB0aGlzLl94ID0gdGhpcy5feSA9IHRoaXMuX2hlaWdodCA9IHVuZGVmaW5lZDtcblx0XG5cdCAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cdCAgfVxuXHRcblx0ICBfY3JlYXRlQ2xhc3MoX2NsYXNzLCBbe1xuXHQgICAga2V5OiBcImNsZWFyXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG5cdCAgICAgIHRoaXMuX3JlbmRlcmVkID0ge307XG5cdCAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX3NpemUsIHRoaXMuX3NpemUpO1xuXHQgICAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl94ID0gdGhpcy5feSA9IDA7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInNldEZvbnRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb250KGZvbnQpIHtcblx0ICAgICAgdmFyIGZvbnRzdHIgPSBmb250ID8gZm9udC5zaXplICsgXCJweCBcIiArIGZvbnQudHlwZSA6IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgIHRoaXMuX3JlbmRlcmVkW2ZvbnRzdHJdID0gdGhpcy5fdGV4dHMgPSB0aGlzLl9yZW5kZXJlZFtmb250c3RyXSB8fCB7fTtcblx0ICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gZm9udHN0cjtcblx0ICAgICAgdGhpcy5feCA9IDA7XG5cdCAgICAgIHRoaXMuX3kgKz0gdGhpcy5faGVpZ2h0O1xuXHQgICAgICB0aGlzLl9oZWlnaHQgPSBmb250ID8gZm9udC5zaXplICsgMSA6IE5hTjtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZ2V0VGV4dHVyZVwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHR1cmUoc3R5bGUsIG9uTG9hZCkge1xuXHQgICAgICBvbkxvYWQoKTtcblx0ICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiX2dldFRleHRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VGV4dCh0ZXh0KSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0c1t0ZXh0XTtcblx0ICAgICAgaWYgKCFyZXN1bHQpIHtcblx0ICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuXHQgICAgICAgIGlmICh0aGlzLl94ICsgd2lkdGggPiB0aGlzLl9zaXplKSB7XG5cdCAgICAgICAgICB0aGlzLl94ID0gMDtcblx0ICAgICAgICAgIHRoaXMuX3kgKz0gdGhpcy5faGVpZ2h0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHQsIHRoaXMuX3gsIHRoaXMuX3kpO1xuXHQgICAgICAgIHRoaXMuX3RleHRzW3RleHRdID0gcmVzdWx0ID0ge1xuXHQgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuXHQgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG5cdCAgICAgICAgICBsZWZ0OiB0aGlzLl94IC8gdGhpcy5fc2l6ZSxcblx0ICAgICAgICAgIHJpZ2h0OiAodGhpcy5feCArIHdpZHRoKSAvIHRoaXMuX3NpemUsXG5cdCAgICAgICAgICB0b3A6IHRoaXMuX3kgLyB0aGlzLl9zaXplLFxuXHQgICAgICAgICAgYm90dG9tOiAodGhpcy5feSArIHRoaXMuX2hlaWdodCkgLyB0aGlzLl9zaXplXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLl94ICs9IHdpZHRoO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImdldFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldCh0ZXh0LCB4LCB5KSB7XG5cdCAgICAgIHZhciBjID0gdGhpcy5fZ2V0VGV4dCh0ZXh0KTtcblx0XG5cdCAgICAgIHZhciBkeCA9IHggPD0gMC41ID8gMCA6IC1jLndpZHRoO1xuXHQgICAgICB2YXIgZHkgPSB5IDw9IDAuNSA/IDAgOiAtYy5oZWlnaHQ7XG5cdFxuXHQgICAgICByZXR1cm4gW3tcblx0ICAgICAgICB3aWR0aDogYy53aWR0aCxcblx0ICAgICAgICBoZWlnaHQ6IGMuaGVpZ2h0LFxuXHQgICAgICAgIGxlZnQ6IGMubGVmdCxcblx0ICAgICAgICByaWdodDogYy5yaWdodCxcblx0ICAgICAgICB0b3A6IGMudG9wLFxuXHQgICAgICAgIGJvdHRvbTogYy5ib3R0b20sXG5cdCAgICAgICAgZHg6IGR4LFxuXHQgICAgICAgIGR5OiBkeVxuXHQgICAgICB9XTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwic3RlcHNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzdGVwcyh0ZXh0KSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJiaW5kXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYmluZCgpIHtcblx0ICAgICAgdGhpcy5fZ2wuYmluZFRleHR1cmUodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblx0ICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHQgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fZ2wuTkVBUkVTVCk7XG5cdCAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9nbC5ORUFSRVNUKTtcblx0ICAgICAgdGhpcy5fZ2wudGV4SW1hZ2UyRCh0aGlzLl9nbC5URVhUVVJFXzJELCAwLCB0aGlzLl9nbC5SR0JBLCB0aGlzLl9nbC5SR0JBLCB0aGlzLl9nbC5VTlNJR05FRF9CWVRFLCB0aGlzLl9jYW52YXMpO1xuXHQgICAgICB0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELCBudWxsKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwicmVtb3ZlXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHQgICAgICB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWwpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJmb250U2l6ZVwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQgLSAxO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0XG5cdCAgcmV0dXJuIF9jbGFzcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gX2NsYXNzO1xuXHQ7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3BiZiA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXHRcblx0dmFyIF9wYmYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGJmKTtcblx0XG5cdHZhciBfYXRsYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblx0XG5cdHZhciBfYXRsYXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXRsYXMpO1xuXHRcblx0dmFyIF9nbHlwaHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblx0XG5cdHZhciBfZ2x5cGhzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dseXBocyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdC8qKlxuXHQgKiAgQ29weXJpZ2h0IChjKSAyMDE2LCBIZWxpa2FyIExhYi5cblx0ICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqXG5cdCAqICBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBHUEx2MyBMaWNlbnNlLlxuXHQgKiAgQXV0aG9yczogQWxlxaEgU2Fza2Fcblx0ICovXG5cdFxuXHQvLyBBIHNpbXBsaWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdseXBoIGNvbnRhaW5pbmcgb25seSB0aGUgcHJvcGVydGllcyBuZWVkZWQgZm9yIHNoYXBpbmcuXG5cdHZhciBTaW1wbGVHbHlwaCA9IGZ1bmN0aW9uIFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpIHtcblx0ICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlR2x5cGgpO1xuXHRcblx0ICB2YXIgcGFkZGluZyA9IDE7XG5cdCAgdGhpcy5hZHZhbmNlID0gZ2x5cGguYWR2YW5jZTtcblx0ICB0aGlzLmxlZnQgPSBnbHlwaC5sZWZ0IC0gYnVmZmVyIC0gcGFkZGluZztcblx0ICB0aGlzLnRvcCA9IGdseXBoLnRvcCArIGJ1ZmZlciArIHBhZGRpbmc7XG5cdCAgdGhpcy5yZWN0ID0gcmVjdDtcblx0fTtcblx0XG5cdHZhciBTSVpFX0dST1dUSF9SQVRFID0gNDtcblx0dmFyIERFRkFVTFRfU0laRSA9IDUxMjtcblx0Ly8gbXVzdCBiZSBcIkRFRkFVTFRfU0laRSAqIFNJWkVfR1JPV1RIX1JBVEUgXiBuXCIgZm9yIHNvbWUgaW50ZWdlciBuXG5cdHZhciBNQVhfU0laRSA9IDIwNDg7XG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIF9jbGFzcyhnbCwgZmlsZXMsIHRleHR1cmVzKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHRcblx0ICAgIHRoaXMud2lkdGggPSBERUZBVUxUX1NJWkU7XG5cdCAgICB0aGlzLmhlaWdodCA9IERFRkFVTFRfU0laRTtcblx0XG5cdCAgICB0aGlzLmNsZWFyKCk7XG5cdFxuXHQgICAgdGhpcy5fZmlsZXMgPSBmaWxlcztcblx0XG5cdCAgICB0aGlzLl9yZW5kZXJlZCA9IHt9O1xuXHQgICAgdGhpcy5fdGV4dHM7XG5cdCAgICB0aGlzLl9nbCA9IGdsO1xuXHRcblx0ICAgIHRoaXMuYXRsYXMgPSBuZXcgX2F0bGFzMi5kZWZhdWx0KHRoaXMuX2dsLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzLl9jYWNoZWRHbHlwaHMgPSB7fTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fdGV4dHVyZXMgPSB7fTtcblx0ICAgIHRoaXMuX2dseXBocyA9IHt9O1xuXHQgICAgdGhpcy5fcmVjdHMgPSB7fTtcblx0ICAgIHRoaXMuX2NhY2hlZEdseXBocyA9IHt9O1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcblx0ICAgIGtleTogJ2NsZWFyJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHt9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnc2V0Rm9udCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Rm9udChzdHlsZSkge1xuXHQgICAgICB0aGlzLmN1ckZvbnQgPSBzdHlsZS5wYmY7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZ2V0VGV4dHVyZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dHVyZShzdHlsZSwgb25Mb2FkKSB7XG5cdCAgICAgIHZhciBfdGhpczIgPSB0aGlzLFxuXHQgICAgICAgICAgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblx0XG5cdCAgICAgIHZhciBteU9uTG9hZCA9IGZ1bmN0aW9uIChvbkwpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdmFyIGRhdGEgPSBfdGhpczIuX2ZpbGVzLmxvYWQoc3R5bGUucGJmLCBvbkxvYWQsICdhcnJheWJ1ZmZlcicpO1xuXHRcblx0ICAgICAgICAgIC8vaW5pdCBmaXJzdCBtb3N0LXVzZWQgQVNDSUkgY2hhcnNcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcblx0ICAgICAgICAgICAgX3RoaXMyLl9nZXRDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuXHQgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgIG9uTCAmJiBvbkwuYXBwbHkoX3RoaXMyLCBfYXJndW1lbnRzKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9KG9uTG9hZCk7XG5cdFxuXHQgICAgICB2YXIgZm9udCA9IHN0eWxlLnBiZjtcblx0ICAgICAgaWYgKCF0aGlzLl9nbHlwaHNbZm9udF0pIHtcblx0ICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZpbGVzLmxvYWQoc3R5bGUucGJmLCBteU9uTG9hZCwgJ2FycmF5YnVmZmVyJyk7XG5cdCAgICAgICAgdGhpcy5fY3VyZ2x5cGhzID0gdGhpcy5fZ2x5cGhzW2ZvbnRdID0gZGF0YSAmJiBuZXcgX2dseXBoczIuZGVmYXVsdChuZXcgX3BiZjIuZGVmYXVsdChkYXRhKSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbXlPbkxvYWQoKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIHRoaXMuYXRsYXMudGV4dHVyZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0Q2hhcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENoYXIodGV4dCwgbWFya0RpcnR5KSB7XG5cdCAgICAgIHZhciBmb250ID0gdGhpcy5jdXJGb250O1xuXHQgICAgICB2YXIgZ2x5cGhJRCA9IHRleHQuY2hhckNvZGVBdCgwKTtcblx0XG5cdCAgICAgIHZhciBidWZmZXIgPSAzO1xuXHQgICAgICB2YXIgcmFuZ2UgPSBNYXRoLmZsb29yKGdseXBoSUQgLyAyNTYpO1xuXHRcblx0ICAgICAgaWYgKHRoaXMuX2dseXBoc1tmb250XSkge1xuXHQgICAgICAgIHZhciBnID0gdGhpcy5fZ2x5cGhzW2ZvbnRdO1xuXHQgICAgICAgIGlmIChnKSB7XG5cdCAgICAgICAgICB2YXIgc3RhY2sgPSBnLnN0YWNrc1tyYW5nZV07XG5cdCAgICAgICAgICBpZiAoc3RhY2spIHtcblx0ICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2suZ2x5cGhzW2dseXBoSURdO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX3JlY3RzW2ZvbnRdKSB0aGlzLl9yZWN0c1tmb250XSA9IHt9O1xuXHRcblx0ICAgICAgICAgICAgdGhpcy5fcmVjdHNbZm9udF1bdGV4dF0gPSB0aGlzLmF0bGFzLmFkZEdseXBoKGdseXBoSUQsIHRoaXMuY3VyRm9udCwgZ2x5cGgsIGJ1ZmZlciwgbWFya0RpcnR5KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciByID0gdm9pZCAwLFxuXHQgICAgICAgICAgcmVjdCA9IHZvaWQgMDtcblx0ICAgICAgaWYgKChyID0gdGhpcy5fcmVjdHNbZm9udF0pICYmIChyZWN0ID0gclt0ZXh0XSkpIHtcblx0ICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZWRHbHlwaHNbZm9udF0gfHwgKHRoaXMuX2NhY2hlZEdseXBoc1tmb250XSA9IHt9KTtcblx0ICAgICAgICByZXR1cm4gY2FjaGVbZ2x5cGhJRF0gfHwgKGNhY2hlW2dseXBoSURdID0gbmV3IFNpbXBsZUdseXBoKHRoaXMuX2dseXBoc1tmb250XS5zdGFja3NbcmFuZ2VdLmdseXBoc1tnbHlwaElEXSwgcmVjdCwgYnVmZmVyKSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiB7fTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdnZXQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldCh0ZXh0LCB4LCB5LCBtYXJrRGlydHkpIHtcblx0ICAgICAgdmFyIHdpZHRoID0gMDtcblx0ICAgICAgdmFyIGhlaWdodCA9IDA7XG5cdFxuXHQgICAgICB2YXIgaG9yaUJlYXJpbmdYID0gMztcblx0ICAgICAgdmFyIGhvcmlCZWFyaW5nWSA9IDI7XG5cdFxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgY2hhciA9IHRoaXMuX2dldENoYXIodGV4dFtpXSwgbWFya0RpcnR5KTtcblx0ICAgICAgICB2YXIgcmVjdCA9IGNoYXIucmVjdCB8fCB7fTtcblx0ICAgICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHJlY3QuaCAtIGNoYXIudG9wKTtcblx0ICAgICAgICB3aWR0aCArPSBjaGFyLmFkdmFuY2UgKyBob3JpQmVhcmluZ1g7XG5cdCAgICAgICAgLy8gICAgICB3aWR0aCAgICAgICAgICAgICAgICs9IHJlY3QudyArIGhvcmlCZWFyaW5nWDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIGR4ID0geCA8PSAwLjUgPyAwIDogLXdpZHRoO1xuXHQgICAgICB2YXIgZHkgPSB5IDw9IDAuNSA/IDAgOiAtaGVpZ2h0O1xuXHRcblx0ICAgICAgdmFyIHJldCA9IFtdO1xuXHQgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGV4dC5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICB2YXIgX2NoYXIgPSB0aGlzLl9nZXRDaGFyKHRleHRbX2ldLCBtYXJrRGlydHkpO1xuXHQgICAgICAgIHZhciBfcmVjdCA9IF9jaGFyLnJlY3QgfHwge307XG5cdFxuXHQgICAgICAgIHZhciBob3JpQWR2YW5jZSA9IHZvaWQgMDtcblx0XG5cdCAgICAgICAgZHggKz0gaG9yaUJlYXJpbmdYO1xuXHRcblx0ICAgICAgICByZXQucHVzaCh7XG5cdCAgICAgICAgICB3aWR0aDogX3JlY3Qudyxcblx0ICAgICAgICAgIGhlaWdodDogX3JlY3QuaCxcblx0ICAgICAgICAgIGxlZnQ6IF9yZWN0LnggLyB0aGlzLmF0bGFzLndpZHRoLFxuXHQgICAgICAgICAgcmlnaHQ6IChfcmVjdC54ICsgX3JlY3QudykgLyB0aGlzLmF0bGFzLndpZHRoLFxuXHQgICAgICAgICAgYm90dG9tOiAoX3JlY3QueSArIF9yZWN0LmgpIC8gdGhpcy5hdGxhcy5oZWlnaHQsXG5cdCAgICAgICAgICB0b3A6IF9yZWN0LnkgLyB0aGlzLmF0bGFzLmhlaWdodCxcblx0ICAgICAgICAgIGR4OiBkeCxcblx0ICAgICAgICAgIGR5OiBkeSArIF9jaGFyLnRvcCArIChoZWlnaHQgLSBfcmVjdC5oKVxuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBkeCArPSBfY2hhci5hZHZhbmNlO1xuXHQgICAgICAgIC8vICAgICAgZHggKz0gcmVjdC53O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnc3RlcHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXBzKHRleHQpIHtcblx0ICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2JpbmQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmQoKSB7XG5cdCAgICAgIHRoaXMuYXRsYXMudXBkYXRlVGV4dHVyZSh0aGlzLl9nbCk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnaXNTREYnLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2ZvbnRTaXplJyxcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gMjQ7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gX2NsYXNzO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBfY2xhc3M7XG5cdDtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gUGJmO1xuXHRcblx0dmFyIGllZWU3NTQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0XG5cdGZ1bmN0aW9uIFBiZihidWYpIHtcblx0ICAgIHRoaXMuYnVmID0gQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyhidWYpID8gYnVmIDogbmV3IFVpbnQ4QXJyYXkoYnVmIHx8IDApO1xuXHQgICAgdGhpcy5wb3MgPSAwO1xuXHQgICAgdGhpcy50eXBlID0gMDtcblx0ICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoO1xuXHR9XG5cdFxuXHRQYmYuVmFyaW50ICA9IDA7IC8vIHZhcmludDogaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cblx0UGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblx0UGJmLkJ5dGVzICAgPSAyOyAvLyBsZW5ndGgtZGVsaW1pdGVkOiBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuXHRQYmYuRml4ZWQzMiA9IDU7IC8vIDMyLWJpdDogZmxvYXQsIGZpeGVkMzIsIHNmaXhlZDMyXG5cdFxuXHR2YXIgU0hJRlRfTEVGVF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSxcblx0ICAgIFNISUZUX1JJR0hUXzMyID0gMSAvIFNISUZUX0xFRlRfMzI7XG5cdFxuXHRQYmYucHJvdG90eXBlID0ge1xuXHRcblx0ICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHRoaXMuYnVmID0gbnVsbDtcblx0ICAgIH0sXG5cdFxuXHQgICAgLy8gPT09IFJFQURJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0XG5cdCAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG5cdCAgICAgICAgZW5kID0gZW5kIHx8IHRoaXMubGVuZ3RoO1xuXHRcblx0ICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludCgpLFxuXHQgICAgICAgICAgICAgICAgdGFnID0gdmFsID4+IDMsXG5cdCAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXHRcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gdmFsICYgMHg3O1xuXHQgICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXHRcblx0ICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBzdGFydFBvcykgdGhpcy5za2lwKHZhbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9LFxuXHRcblx0ICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWVsZHMocmVhZEZpZWxkLCByZXN1bHQsIHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MpO1xuXHQgICAgfSxcblx0XG5cdCAgICByZWFkRml4ZWQzMjogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHJlYWRVSW50MzIodGhpcy5idWYsIHRoaXMucG9zKTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA0O1xuXHQgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICB9LFxuXHRcblx0ICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHJlYWRJbnQzMih0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuXHQgICAgICAgIHRoaXMucG9zICs9IDQ7XG5cdCAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgIH0sXG5cdFxuXHQgICAgLy8gNjQtYml0IGludCBoYW5kbGluZyBpcyBiYXNlZCBvbiBnaXRodWIuY29tL2Rwdy9ub2RlLWJ1ZmZlci1tb3JlLWludHMgKE1JVC1saWNlbnNlZClcblx0XG5cdCAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHJlYWRVSW50MzIodGhpcy5idWYsIHRoaXMucG9zKSArIHJlYWRVSW50MzIodGhpcy5idWYsIHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuXHQgICAgICAgIHRoaXMucG9zICs9IDg7XG5cdCAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgIH0sXG5cdFxuXHQgICAgcmVhZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgdmFsID0gcmVhZFVJbnQzMih0aGlzLmJ1ZiwgdGhpcy5wb3MpICsgcmVhZEludDMyKHRoaXMuYnVmLCB0aGlzLnBvcyArIDQpICogU0hJRlRfTEVGVF8zMjtcblx0ICAgICAgICB0aGlzLnBvcyArPSA4O1xuXHQgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICB9LFxuXHRcblx0ICAgIHJlYWRGbG9hdDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IGllZWU3NTQucmVhZCh0aGlzLmJ1ZiwgdGhpcy5wb3MsIHRydWUsIDIzLCA0KTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA0O1xuXHQgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICB9LFxuXHRcblx0ICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciB2YWwgPSBpZWVlNzU0LnJlYWQodGhpcy5idWYsIHRoaXMucG9zLCB0cnVlLCA1MiwgOCk7XG5cdCAgICAgICAgdGhpcy5wb3MgKz0gODtcblx0ICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgfSxcblx0XG5cdCAgICByZWFkVmFyaW50OiBmdW5jdGlvbihpc1NpZ25lZCkge1xuXHQgICAgICAgIHZhciBidWYgPSB0aGlzLmJ1Zixcblx0ICAgICAgICAgICAgdmFsLCBiO1xuXHRcblx0ICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgID0gIGIgJiAweDdmOyAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXHQgICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCB8PSAoYiAmIDB4N2YpIDw8IDc7ICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG5cdCAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsIHw9IChiICYgMHg3ZikgPDwgMTQ7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblx0ICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCAyMTsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXHQgICAgICAgIGIgPSBidWZbdGhpcy5wb3NdOyAgIHZhbCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xuXHRcblx0ICAgICAgICByZXR1cm4gcmVhZFZhcmludFJlbWFpbmRlcih2YWwsIGlzU2lnbmVkLCB0aGlzKTtcblx0ICAgIH0sXG5cdFxuXHQgICAgcmVhZFZhcmludDY0OiBmdW5jdGlvbigpIHsgLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB2Mi4wLjFcblx0ICAgICAgICByZXR1cm4gdGhpcy5yZWFkVmFyaW50KHRydWUpO1xuXHQgICAgfSxcblx0XG5cdCAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpO1xuXHQgICAgICAgIHJldHVybiBudW0gJSAyID09PSAxID8gKG51bSArIDEpIC8gLTIgOiBudW0gLyAyOyAvLyB6aWd6YWcgZW5jb2Rpbmdcblx0ICAgIH0sXG5cdFxuXHQgICAgcmVhZEJvb2xlYW46IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcblx0ICAgIH0sXG5cdFxuXHQgICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG5cdCAgICAgICAgICAgIHN0ciA9IHJlYWRVdGY4KHRoaXMuYnVmLCB0aGlzLnBvcywgZW5kKTtcblx0ICAgICAgICB0aGlzLnBvcyA9IGVuZDtcblx0ICAgICAgICByZXR1cm4gc3RyO1xuXHQgICAgfSxcblx0XG5cdCAgICByZWFkQnl0ZXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuXHQgICAgICAgICAgICBidWZmZXIgPSB0aGlzLmJ1Zi5zdWJhcnJheSh0aGlzLnBvcywgZW5kKTtcblx0ICAgICAgICB0aGlzLnBvcyA9IGVuZDtcblx0ICAgICAgICByZXR1cm4gYnVmZmVyO1xuXHQgICAgfSxcblx0XG5cdCAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblx0XG5cdCAgICByZWFkUGFja2VkVmFyaW50OiBmdW5jdGlvbihhcnIsIGlzU2lnbmVkKSB7XG5cdCAgICAgICAgdmFyIGVuZCA9IHJlYWRQYWNrZWRFbmQodGhpcyk7XG5cdCAgICAgICAgYXJyID0gYXJyIHx8IFtdO1xuXHQgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KGlzU2lnbmVkKSk7XG5cdCAgICAgICAgcmV0dXJuIGFycjtcblx0ICAgIH0sXG5cdCAgICByZWFkUGFja2VkU1ZhcmludDogZnVuY3Rpb24oYXJyKSB7XG5cdCAgICAgICAgdmFyIGVuZCA9IHJlYWRQYWNrZWRFbmQodGhpcyk7XG5cdCAgICAgICAgYXJyID0gYXJyIHx8IFtdO1xuXHQgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcblx0ICAgICAgICByZXR1cm4gYXJyO1xuXHQgICAgfSxcblx0ICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbihhcnIpIHtcblx0ICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTtcblx0ICAgICAgICBhcnIgPSBhcnIgfHwgW107XG5cdCAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRCb29sZWFuKCkpO1xuXHQgICAgICAgIHJldHVybiBhcnI7XG5cdCAgICB9LFxuXHQgICAgcmVhZFBhY2tlZEZsb2F0OiBmdW5jdGlvbihhcnIpIHtcblx0ICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTtcblx0ICAgICAgICBhcnIgPSBhcnIgfHwgW107XG5cdCAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTtcblx0ICAgICAgICByZXR1cm4gYXJyO1xuXHQgICAgfSxcblx0ICAgIHJlYWRQYWNrZWREb3VibGU6IGZ1bmN0aW9uKGFycikge1xuXHQgICAgICAgIHZhciBlbmQgPSByZWFkUGFja2VkRW5kKHRoaXMpO1xuXHQgICAgICAgIGFyciA9IGFyciB8fCBbXTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcblx0ICAgICAgICByZXR1cm4gYXJyO1xuXHQgICAgfSxcblx0ICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbihhcnIpIHtcblx0ICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTtcblx0ICAgICAgICBhcnIgPSBhcnIgfHwgW107XG5cdCAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDMyKCkpO1xuXHQgICAgICAgIHJldHVybiBhcnI7XG5cdCAgICB9LFxuXHQgICAgcmVhZFBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbihhcnIpIHtcblx0ICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTtcblx0ICAgICAgICBhcnIgPSBhcnIgfHwgW107XG5cdCAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTtcblx0ICAgICAgICByZXR1cm4gYXJyO1xuXHQgICAgfSxcblx0ICAgIHJlYWRQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbihhcnIpIHtcblx0ICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTtcblx0ICAgICAgICBhcnIgPSBhcnIgfHwgW107XG5cdCAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuXHQgICAgICAgIHJldHVybiBhcnI7XG5cdCAgICB9LFxuXHQgICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbihhcnIpIHtcblx0ICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTtcblx0ICAgICAgICBhcnIgPSBhcnIgfHwgW107XG5cdCAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTtcblx0ICAgICAgICByZXR1cm4gYXJyO1xuXHQgICAgfSxcblx0XG5cdCAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICB2YXIgdHlwZSA9IHZhbCAmIDB4Nztcblx0ICAgICAgICBpZiAodHlwZSA9PT0gUGJmLlZhcmludCkgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdID4gMHg3Zikge31cblx0ICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcblx0ICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuRml4ZWQzMikgdGhpcy5wb3MgKz0gNDtcblx0ICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuRml4ZWQ2NCkgdGhpcy5wb3MgKz0gODtcblx0ICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG5cdCAgICB9LFxuXHRcblx0ICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFxuXHQgICAgd3JpdGVUYWc6IGZ1bmN0aW9uKHRhZywgdHlwZSkge1xuXHQgICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuXHQgICAgfSxcblx0XG5cdCAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMTY7XG5cdFxuXHQgICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cdFxuXHQgICAgICAgIGlmIChsZW5ndGggIT09IHRoaXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgICAgICAgICBidWYuc2V0KHRoaXMuYnVmKTtcblx0ICAgICAgICAgICAgdGhpcy5idWYgPSBidWY7XG5cdCAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cdFxuXHQgICAgZmluaXNoOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMucG9zO1xuXHQgICAgICAgIHRoaXMucG9zID0gMDtcblx0ICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoMCwgdGhpcy5sZW5ndGgpO1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZUZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgIHRoaXMucmVhbGxvYyg0KTtcblx0ICAgICAgICB3cml0ZUludDMyKHRoaXMuYnVmLCB2YWwsIHRoaXMucG9zKTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA0O1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG5cdCAgICAgICAgd3JpdGVJbnQzMih0aGlzLmJ1ZiwgdmFsLCB0aGlzLnBvcyk7XG5cdCAgICAgICAgdGhpcy5wb3MgKz0gNDtcblx0ICAgIH0sXG5cdFxuXHQgICAgd3JpdGVGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG5cdCAgICAgICAgd3JpdGVJbnQzMih0aGlzLmJ1ZiwgdmFsICYgLTEsIHRoaXMucG9zKTtcblx0ICAgICAgICB3cml0ZUludDMyKHRoaXMuYnVmLCBNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA4O1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZVNGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG5cdCAgICAgICAgd3JpdGVJbnQzMih0aGlzLmJ1ZiwgdmFsICYgLTEsIHRoaXMucG9zKTtcblx0ICAgICAgICB3cml0ZUludDMyKHRoaXMuYnVmLCBNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA4O1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZVZhcmludDogZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgdmFsID0gK3ZhbCB8fCAwO1xuXHRcblx0ICAgICAgICBpZiAodmFsID4gMHhmZmZmZmZmIHx8IHZhbCA8IDApIHtcblx0ICAgICAgICAgICAgd3JpdGVCaWdWYXJpbnQodmFsLCB0aGlzKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuXHRcblx0ICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICAgICAgICAgICB2YWwgJiAweDdmICB8ICh2YWwgPiAweDdmID8gMHg4MCA6IDApOyBpZiAodmFsIDw9IDB4N2YpIHJldHVybjtcblx0ICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+Pj0gNykgJiAweDdmKSB8ICh2YWwgPiAweDdmID8gMHg4MCA6IDApOyBpZiAodmFsIDw9IDB4N2YpIHJldHVybjtcblx0ICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+Pj0gNykgJiAweDdmKSB8ICh2YWwgPiAweDdmID8gMHg4MCA6IDApOyBpZiAodmFsIDw9IDB4N2YpIHJldHVybjtcblx0ICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICAgKHZhbCA+Pj4gNykgJiAweDdmO1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZVNWYXJpbnQ6IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsIDwgMCA/IC12YWwgKiAyIC0gMSA6IHZhbCAqIDIpO1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZUJvb2xlYW46IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcblx0ICAgIH0sXG5cdFxuXHQgICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuXHQgICAgICAgIHRoaXMucmVhbGxvYyhzdHIubGVuZ3RoICogNCk7XG5cdFxuXHQgICAgICAgIHRoaXMucG9zKys7IC8vIHJlc2VydmUgMSBieXRlIGZvciBzaG9ydCBzdHJpbmcgbGVuZ3RoXG5cdFxuXHQgICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuXHQgICAgICAgIC8vIHdyaXRlIHRoZSBzdHJpbmcgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG5cdCAgICAgICAgdGhpcy5wb3MgPSB3cml0ZVV0ZjgodGhpcy5idWYsIHN0ciwgdGhpcy5wb3MpO1xuXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLnBvcyAtIHN0YXJ0UG9zO1xuXHRcblx0ICAgICAgICBpZiAobGVuID49IDB4ODApIG1ha2VSb29tRm9yRXh0cmFMZW5ndGgoc3RhcnRQb3MsIGxlbiwgdGhpcyk7XG5cdFxuXHQgICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG5cdCAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyAtIDE7XG5cdCAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuXHQgICAgICAgIHRoaXMucG9zICs9IGxlbjtcblx0ICAgIH0sXG5cdFxuXHQgICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuXHQgICAgICAgIGllZWU3NTQud3JpdGUodGhpcy5idWYsIHZhbCwgdGhpcy5wb3MsIHRydWUsIDIzLCA0KTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA0O1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuXHQgICAgICAgIGllZWU3NTQud3JpdGUodGhpcy5idWYsIHZhbCwgdGhpcy5wb3MsIHRydWUsIDUyLCA4KTtcblx0ICAgICAgICB0aGlzLnBvcyArPSA4O1xuXHQgICAgfSxcblx0XG5cdCAgICB3cml0ZUJ5dGVzOiBmdW5jdGlvbihidWZmZXIpIHtcblx0ICAgICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcblx0ICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG5cdCAgICAgICAgdGhpcy5yZWFsbG9jKGxlbik7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpcy5idWZbdGhpcy5wb3MrK10gPSBidWZmZXJbaV07XG5cdCAgICB9LFxuXHRcblx0ICAgIHdyaXRlUmF3TWVzc2FnZTogZnVuY3Rpb24oZm4sIG9iaikge1xuXHQgICAgICAgIHRoaXMucG9zKys7IC8vIHJlc2VydmUgMSBieXRlIGZvciBzaG9ydCBtZXNzYWdlIGxlbmd0aFxuXHRcblx0ICAgICAgICAvLyB3cml0ZSB0aGUgbWVzc2FnZSBkaXJlY3RseSB0byB0aGUgYnVmZmVyIGFuZCBzZWUgaG93IG11Y2ggd2FzIHdyaXR0ZW5cblx0ICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvcztcblx0ICAgICAgICBmbihvYmosIHRoaXMpO1xuXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLnBvcyAtIHN0YXJ0UG9zO1xuXHRcblx0ICAgICAgICBpZiAobGVuID49IDB4ODApIG1ha2VSb29tRm9yRXh0cmFMZW5ndGgoc3RhcnRQb3MsIGxlbiwgdGhpcyk7XG5cdFxuXHQgICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG5cdCAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyAtIDE7XG5cdCAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuXHQgICAgICAgIHRoaXMucG9zICs9IGxlbjtcblx0ICAgIH0sXG5cdFxuXHQgICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcblx0ICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcblx0ICAgICAgICB0aGlzLndyaXRlUmF3TWVzc2FnZShmbiwgb2JqKTtcblx0ICAgIH0sXG5cdFxuXHQgICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuXHQgICAgd3JpdGVQYWNrZWRTVmFyaW50OiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNWYXJpbnQsIGFycik7ICB9LFxuXHQgICAgd3JpdGVQYWNrZWRCb29sZWFuOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEJvb2xlYW4sIGFycik7ICB9LFxuXHQgICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuXHQgICAgd3JpdGVQYWNrZWREb3VibGU6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZERvdWJsZSwgYXJyKTsgICB9LFxuXHQgICAgd3JpdGVQYWNrZWRGaXhlZDMyOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkMzIsIGFycik7ICB9LFxuXHQgICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuXHQgICAgd3JpdGVQYWNrZWRGaXhlZDY0OiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkNjQsIGFycik7ICB9LFxuXHQgICAgd3JpdGVQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDY0LCBhcnIpOyB9LFxuXHRcblx0ICAgIHdyaXRlQnl0ZXNGaWVsZDogZnVuY3Rpb24odGFnLCBidWZmZXIpIHtcblx0ICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcblx0ICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcblx0ICAgIH0sXG5cdCAgICB3cml0ZUZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcblx0ICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuXHQgICAgICAgIHRoaXMud3JpdGVGaXhlZDMyKHZhbCk7XG5cdCAgICB9LFxuXHQgICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuXHQgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG5cdCAgICAgICAgdGhpcy53cml0ZVNGaXhlZDMyKHZhbCk7XG5cdCAgICB9LFxuXHQgICAgd3JpdGVGaXhlZDY0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG5cdCAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcblx0ICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuXHQgICAgfSxcblx0ICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcblx0ICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuXHQgICAgICAgIHRoaXMud3JpdGVTRml4ZWQ2NCh2YWwpO1xuXHQgICAgfSxcblx0ICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG5cdCAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5WYXJpbnQpO1xuXHQgICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsKTtcblx0ICAgIH0sXG5cdCAgICB3cml0ZVNWYXJpbnRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcblx0ICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG5cdCAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcblx0ICAgIH0sXG5cdCAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbih0YWcsIHN0cikge1xuXHQgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuXHQgICAgICAgIHRoaXMud3JpdGVTdHJpbmcoc3RyKTtcblx0ICAgIH0sXG5cdCAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG5cdCAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcblx0ICAgICAgICB0aGlzLndyaXRlRmxvYXQodmFsKTtcblx0ICAgIH0sXG5cdCAgICB3cml0ZURvdWJsZUZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuXHQgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG5cdCAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuXHQgICAgfSxcblx0ICAgIHdyaXRlQm9vbGVhbkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuXHQgICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG5cdCAgICB9XG5cdH07XG5cdFxuXHRmdW5jdGlvbiByZWFkVmFyaW50UmVtYWluZGVyKGwsIHMsIHApIHtcblx0ICAgIHZhciBidWYgPSBwLmJ1Zixcblx0ICAgICAgICBoLCBiO1xuXHRcblx0ICAgIGIgPSBidWZbcC5wb3MrK107IGggID0gKGIgJiAweDcwKSA+PiA0OyAgaWYgKGIgPCAweDgwKSByZXR1cm4gdG9OdW0obCwgaCwgcyk7XG5cdCAgICBiID0gYnVmW3AucG9zKytdOyBoIHw9IChiICYgMHg3ZikgPDwgMzsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHRvTnVtKGwsIGgsIHMpO1xuXHQgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4N2YpIDw8IDEwOyBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTtcblx0ICAgIGIgPSBidWZbcC5wb3MrK107IGggfD0gKGIgJiAweDdmKSA8PCAxNzsgaWYgKGIgPCAweDgwKSByZXR1cm4gdG9OdW0obCwgaCwgcyk7XG5cdCAgICBiID0gYnVmW3AucG9zKytdOyBoIHw9IChiICYgMHg3ZikgPDwgMjQ7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHRvTnVtKGwsIGgsIHMpO1xuXHQgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4MDEpIDw8IDMxOyBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTtcblx0XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlYWRQYWNrZWRFbmQocGJmKSB7XG5cdCAgICByZXR1cm4gcGJmLnR5cGUgPT09IFBiZi5CeXRlcyA/XG5cdCAgICAgICAgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MgOiBwYmYucG9zICsgMTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gdG9OdW0obG93LCBoaWdoLCBpc1NpZ25lZCkge1xuXHQgICAgaWYgKGlzU2lnbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIGhpZ2ggKiAweDEwMDAwMDAwMCArIChsb3cgPj4+IDApO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiAoKGhpZ2ggPj4+IDApICogMHgxMDAwMDAwMDApICsgKGxvdyA+Pj4gMCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHdyaXRlQmlnVmFyaW50KHZhbCwgcGJmKSB7XG5cdCAgICB2YXIgbG93LCBoaWdoO1xuXHRcblx0ICAgIGlmICh2YWwgPj0gMCkge1xuXHQgICAgICAgIGxvdyAgPSAodmFsICUgMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICBoaWdoID0gKHZhbCAvIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGxvdyAgPSB+KC12YWwgJSAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgaGlnaCA9IH4oLXZhbCAvIDB4MTAwMDAwMDAwKTtcblx0XG5cdCAgICAgICAgaWYgKGxvdyBeIDB4ZmZmZmZmZmYpIHtcblx0ICAgICAgICAgICAgbG93ID0gKGxvdyArIDEpIHwgMDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBsb3cgPSAwO1xuXHQgICAgICAgICAgICBoaWdoID0gKGhpZ2ggKyAxKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmICh2YWwgPj0gMHgxMDAwMDAwMDAwMDAwMDAwMCB8fCB2YWwgPCAtMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFyaW50IGRvZXNuXFwndCBmaXQgaW50byAxMCBieXRlcycpO1xuXHQgICAgfVxuXHRcblx0ICAgIHBiZi5yZWFsbG9jKDEwKTtcblx0XG5cdCAgICB3cml0ZUJpZ1ZhcmludExvdyhsb3csIGhpZ2gsIHBiZik7XG5cdCAgICB3cml0ZUJpZ1ZhcmludEhpZ2goaGlnaCwgcGJmKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gd3JpdGVCaWdWYXJpbnRMb3cobG93LCBoaWdoLCBwYmYpIHtcblx0ICAgIHBiZi5idWZbcGJmLnBvcysrXSA9IGxvdyAmIDB4N2YgfCAweDgwOyBsb3cgPj4+PSA3O1xuXHQgICAgcGJmLmJ1ZltwYmYucG9zKytdID0gbG93ICYgMHg3ZiB8IDB4ODA7IGxvdyA+Pj49IDc7XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gPSBsb3cgJiAweDdmIHwgMHg4MDsgbG93ID4+Pj0gNztcblx0ICAgIHBiZi5idWZbcGJmLnBvcysrXSA9IGxvdyAmIDB4N2YgfCAweDgwOyBsb3cgPj4+PSA3O1xuXHQgICAgcGJmLmJ1ZltwYmYucG9zXSAgID0gbG93ICYgMHg3Zjtcblx0fVxuXHRcblx0ZnVuY3Rpb24gd3JpdGVCaWdWYXJpbnRIaWdoKGhpZ2gsIHBiZikge1xuXHQgICAgdmFyIGxzYiA9IChoaWdoICYgMHgwNykgPDwgNDtcblx0XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gfD0gbHNiICAgICAgICAgfCAoKGhpZ2ggPj4+PSAzKSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gID0gaGlnaCAmIDB4N2YgfCAoKGhpZ2ggPj4+PSA3KSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gID0gaGlnaCAmIDB4N2YgfCAoKGhpZ2ggPj4+PSA3KSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gID0gaGlnaCAmIDB4N2YgfCAoKGhpZ2ggPj4+PSA3KSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gID0gaGlnaCAmIDB4N2YgfCAoKGhpZ2ggPj4+PSA3KSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47XG5cdCAgICBwYmYuYnVmW3BiZi5wb3MrK10gID0gaGlnaCAmIDB4N2Y7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG1ha2VSb29tRm9yRXh0cmFMZW5ndGgoc3RhcnRQb3MsIGxlbiwgcGJmKSB7XG5cdCAgICB2YXIgZXh0cmFMZW4gPVxuXHQgICAgICAgIGxlbiA8PSAweDNmZmYgPyAxIDpcblx0ICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAyIDpcblx0ICAgICAgICBsZW4gPD0gMHhmZmZmZmZmID8gMyA6IE1hdGguY2VpbChNYXRoLmxvZyhsZW4pIC8gKE1hdGguTE4yICogNykpO1xuXHRcblx0ICAgIC8vIGlmIDEgYnl0ZSBpc24ndCBlbm91Z2ggZm9yIGVuY29kaW5nIG1lc3NhZ2UgbGVuZ3RoLCBzaGlmdCB0aGUgZGF0YSB0byB0aGUgcmlnaHRcblx0ICAgIHBiZi5yZWFsbG9jKGV4dHJhTGVuKTtcblx0ICAgIGZvciAodmFyIGkgPSBwYmYucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSBwYmYuYnVmW2kgKyBleHRyYUxlbl0gPSBwYmYuYnVmW2ldO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludChhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVWYXJpbnQoYXJyW2ldKTsgICB9XG5cdGZ1bmN0aW9uIHdyaXRlUGFja2VkU1ZhcmludChhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNWYXJpbnQoYXJyW2ldKTsgIH1cblx0ZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuXHRmdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZShhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVEb3VibGUoYXJyW2ldKTsgICB9XG5cdGZ1bmN0aW9uIHdyaXRlUGFja2VkQm9vbGVhbihhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUJvb2xlYW4oYXJyW2ldKTsgIH1cblx0ZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuXHRmdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQzMihhcnJbaV0pOyB9XG5cdGZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQ2NChhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZpeGVkNjQoYXJyW2ldKTsgIH1cblx0ZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuXHRcblx0Ly8gQnVmZmVyIGNvZGUgYmVsb3cgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlciwgTUlULWxpY2Vuc2VkXG5cdFxuXHRmdW5jdGlvbiByZWFkVUludDMyKGJ1ZiwgcG9zKSB7XG5cdCAgICByZXR1cm4gKChidWZbcG9zXSkgfFxuXHQgICAgICAgIChidWZbcG9zICsgMV0gPDwgOCkgfFxuXHQgICAgICAgIChidWZbcG9zICsgMl0gPDwgMTYpKSArXG5cdCAgICAgICAgKGJ1Zltwb3MgKyAzXSAqIDB4MTAwMDAwMCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmLCB2YWwsIHBvcykge1xuXHQgICAgYnVmW3Bvc10gPSB2YWw7XG5cdCAgICBidWZbcG9zICsgMV0gPSAodmFsID4+PiA4KTtcblx0ICAgIGJ1Zltwb3MgKyAyXSA9ICh2YWwgPj4+IDE2KTtcblx0ICAgIGJ1Zltwb3MgKyAzXSA9ICh2YWwgPj4+IDI0KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcmVhZEludDMyKGJ1ZiwgcG9zKSB7XG5cdCAgICByZXR1cm4gKChidWZbcG9zXSkgfFxuXHQgICAgICAgIChidWZbcG9zICsgMV0gPDwgOCkgfFxuXHQgICAgICAgIChidWZbcG9zICsgMl0gPDwgMTYpKSArXG5cdCAgICAgICAgKGJ1Zltwb3MgKyAzXSA8PCAyNCk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlYWRVdGY4KGJ1ZiwgcG9zLCBlbmQpIHtcblx0ICAgIHZhciBzdHIgPSAnJztcblx0ICAgIHZhciBpID0gcG9zO1xuXHRcblx0ICAgIHdoaWxlIChpIDwgZW5kKSB7XG5cdCAgICAgICAgdmFyIGIwID0gYnVmW2ldO1xuXHQgICAgICAgIHZhciBjID0gbnVsbDsgLy8gY29kZXBvaW50XG5cdCAgICAgICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPVxuXHQgICAgICAgICAgICBiMCA+IDB4RUYgPyA0IDpcblx0ICAgICAgICAgICAgYjAgPiAweERGID8gMyA6XG5cdCAgICAgICAgICAgIGIwID4gMHhCRiA/IDIgOiAxO1xuXHRcblx0ICAgICAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPiBlbmQpIGJyZWFrO1xuXHRcblx0ICAgICAgICB2YXIgYjEsIGIyLCBiMztcblx0XG5cdCAgICAgICAgaWYgKGJ5dGVzUGVyU2VxdWVuY2UgPT09IDEpIHtcblx0ICAgICAgICAgICAgaWYgKGIwIDwgMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgYyA9IGIwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChieXRlc1BlclNlcXVlbmNlID09PSAyKSB7XG5cdCAgICAgICAgICAgIGIxID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgICAgaWYgKChiMSAmIDB4QzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIwICYgMHgxRikgPDwgMHg2IHwgKGIxICYgMHgzRik7XG5cdCAgICAgICAgICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKGJ5dGVzUGVyU2VxdWVuY2UgPT09IDMpIHtcblx0ICAgICAgICAgICAgYjEgPSBidWZbaSArIDFdO1xuXHQgICAgICAgICAgICBiMiA9IGJ1ZltpICsgMl07XG5cdCAgICAgICAgICAgIGlmICgoYjEgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgYyA9IChiMCAmIDB4RikgPDwgMHhDIHwgKGIxICYgMHgzRikgPDwgMHg2IHwgKGIyICYgMHgzRik7XG5cdCAgICAgICAgICAgICAgICBpZiAoYyA8PSAweDdGRiB8fCAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKGJ5dGVzUGVyU2VxdWVuY2UgPT09IDQpIHtcblx0ICAgICAgICAgICAgYjEgPSBidWZbaSArIDFdO1xuXHQgICAgICAgICAgICBiMiA9IGJ1ZltpICsgMl07XG5cdCAgICAgICAgICAgIGIzID0gYnVmW2kgKyAzXTtcblx0ICAgICAgICAgICAgaWYgKChiMSAmIDB4QzApID09PSAweDgwICYmIChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIwICYgMHhGKSA8PCAweDEyIHwgKGIxICYgMHgzRikgPDwgMHhDIHwgKGIyICYgMHgzRikgPDwgMHg2IHwgKGIzICYgMHgzRik7XG5cdCAgICAgICAgICAgICAgICBpZiAoYyA8PSAweEZGRkYgfHwgYyA+PSAweDExMDAwMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGMgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoYyA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjID0gMHhGRkZEO1xuXHQgICAgICAgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcblx0XG5cdCAgICAgICAgfSBlbHNlIGlmIChjID4gMHhGRkZGKSB7XG5cdCAgICAgICAgICAgIGMgLT0gMHgxMDAwMDtcblx0ICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdCAgICAgICAgICAgIGMgPSAweERDMDAgfCBjICYgMHgzRkY7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcblx0ICAgICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIHN0cjtcblx0fVxuXHRcblx0ZnVuY3Rpb24gd3JpdGVVdGY4KGJ1Ziwgc3RyLCBwb3MpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBjLCBsZWFkOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50XG5cdFxuXHQgICAgICAgIGlmIChjID4gMHhEN0ZGICYmIGMgPCAweEUwMDApIHtcblx0ICAgICAgICAgICAgaWYgKGxlYWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4RUY7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkY7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkQ7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGMgPSBsZWFkIC0gMHhEODAwIDw8IDEwIHwgYyAtIDB4REMwMCB8IDB4MTAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYyA+IDB4REJGRiB8fCAoaSArIDEgPT09IHN0ci5sZW5ndGgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4RUY7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkY7XG5cdCAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGxlYWQgPSBjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKGxlYWQpIHtcblx0ICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4RUY7XG5cdCAgICAgICAgICAgIGJ1Zltwb3MrK10gPSAweEJGO1xuXHQgICAgICAgICAgICBidWZbcG9zKytdID0gMHhCRDtcblx0ICAgICAgICAgICAgbGVhZCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICBpZiAoYyA8IDB4ODApIHtcblx0ICAgICAgICAgICAgYnVmW3BvcysrXSA9IGM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuXHQgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IGMgPj4gMHg2IHwgMHhDMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjIDwgMHgxMDAwMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjID4+IDB4QyB8IDB4RTA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjID4+IDB4MTIgfCAweEYwO1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjID4+IDB4QyAmIDB4M0YgfCAweDgwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IGMgPj4gMHg2ICYgMHgzRiB8IDB4ODA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYnVmW3BvcysrXSA9IGMgJiAweDNGIHwgMHg4MDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcG9zO1xuXHR9XG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG5cdCAgdmFyIGUsIG1cblx0ICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuXHQgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG5cdCAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG5cdCAgdmFyIG5CaXRzID0gLTdcblx0ICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG5cdCAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG5cdCAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblx0XG5cdCAgaSArPSBkXG5cdFxuXHQgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG5cdCAgcyA+Pj0gKC1uQml0cylcblx0ICBuQml0cyArPSBlTGVuXG5cdCAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblx0XG5cdCAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcblx0ICBlID4+PSAoLW5CaXRzKVxuXHQgIG5CaXRzICs9IG1MZW5cblx0ICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXHRcblx0ICBpZiAoZSA9PT0gMCkge1xuXHQgICAgZSA9IDEgLSBlQmlhc1xuXHQgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuXHQgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG5cdCAgfSBlbHNlIHtcblx0ICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcblx0ICAgIGUgPSBlIC0gZUJpYXNcblx0ICB9XG5cdCAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcblx0fVxuXHRcblx0ZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuXHQgIHZhciBlLCBtLCBjXG5cdCAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcblx0ICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuXHQgIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuXHQgIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcblx0ICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG5cdCAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG5cdCAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblx0XG5cdCAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblx0XG5cdCAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcblx0ICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuXHQgICAgZSA9IGVNYXhcblx0ICB9IGVsc2Uge1xuXHQgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG5cdCAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG5cdCAgICAgIGUtLVxuXHQgICAgICBjICo9IDJcblx0ICAgIH1cblx0ICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuXHQgICAgICB2YWx1ZSArPSBydCAvIGNcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG5cdCAgICAgIGUrK1xuXHQgICAgICBjIC89IDJcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcblx0ICAgICAgbSA9IDBcblx0ICAgICAgZSA9IGVNYXhcblx0ICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcblx0ICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG5cdCAgICAgIGUgPSBlICsgZUJpYXNcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuXHQgICAgICBlID0gMFxuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblx0XG5cdCAgZSA9IChlIDw8IG1MZW4pIHwgbVxuXHQgIGVMZW4gKz0gbUxlblxuXHQgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblx0XG5cdCAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG5cdH1cblxuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX3NoZWxmUGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXHRcblx0dmFyIF9zaGVsZlBhY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hlbGZQYWNrKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0Ly9pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsL3V0aWwnO1xuXHRcblx0dmFyIFNJWkVfR1JPV1RIX1JBVEUgPSA0O1xuXHR2YXIgREVGQVVMVF9TSVpFID0gMTAyNDtcblx0Ly8gbXVzdCBiZSBcIkRFRkFVTFRfU0laRSAqIFNJWkVfR1JPV1RIX1JBVEUgXiBuXCIgZm9yIHNvbWUgaW50ZWdlciBuXG5cdHZhciBNQVhfU0laRSA9IDIwNDg7XG5cdFxuXHR2YXIgR2x5cGhBdGxhcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEdseXBoQXRsYXMoZ2wsIHJlc2V0Q2FjaGUpIHtcblx0ICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2x5cGhBdGxhcyk7XG5cdFxuXHQgICAgICAgIHRoaXMud2lkdGggPSBERUZBVUxUX1NJWkU7XG5cdCAgICAgICAgdGhpcy5oZWlnaHQgPSBERUZBVUxUX1NJWkU7XG5cdFxuXHQgICAgICAgIHRoaXMuX3Jlc2V0Q2FjaGUgPSByZXNldENhY2hlO1xuXHQgICAgICAgIHRoaXMuYmluID0gbmV3IF9zaGVsZlBhY2syLmRlZmF1bHQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSB7fTtcblx0ICAgICAgICB0aGlzLmlkcyA9IHt9O1xuXHRcblx0ICAgICAgICB0aGlzLmdsID0gZ2w7XG5cdCAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcblx0ICAgIH1cblx0XG5cdCAgICBfY3JlYXRlQ2xhc3MoR2x5cGhBdGxhcywgW3tcblx0ICAgICAgICBrZXk6ICdfY3JlYXRlVGV4dHVyZScsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVUZXh0dXJlKCkge1xuXHQgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cdCAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHQgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblx0ICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHQgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0ICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG5cdCAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHQgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0ICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5BTFBIQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLkFMUEhBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuXHQgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ2dldEdseXBocycsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdseXBocygpIHtcblx0ICAgICAgICAgICAgdmFyIGdseXBocyA9IHt9O1xuXHQgICAgICAgICAgICB2YXIgc3BsaXQgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgICAgICBuYW1lID0gdm9pZCAwLFxuXHQgICAgICAgICAgICAgICAgaWQgPSB2b2lkIDA7XG5cdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcblx0ICAgICAgICAgICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG5cdCAgICAgICAgICAgICAgICBuYW1lID0gc3BsaXRbMF07XG5cdCAgICAgICAgICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXHRcblx0ICAgICAgICAgICAgICAgIGlmICghZ2x5cGhzW25hbWVdKSBnbHlwaHNbbmFtZV0gPSBbXTtcblx0ICAgICAgICAgICAgICAgIGdseXBoc1tuYW1lXS5wdXNoKGlkKTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgcmV0dXJuIGdseXBocztcblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiAnZ2V0UmVjdHMnLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWN0cygpIHtcblx0ICAgICAgICAgICAgdmFyIHJlY3RzID0ge307XG5cdCAgICAgICAgICAgIHZhciBzcGxpdCA9IHZvaWQgMCxcblx0ICAgICAgICAgICAgICAgIG5hbWUgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgICAgICBpZCA9IHZvaWQgMDtcblx0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmlkcykge1xuXHQgICAgICAgICAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcblx0ICAgICAgICAgICAgICAgIG5hbWUgPSBzcGxpdFswXTtcblx0ICAgICAgICAgICAgICAgIGlkID0gc3BsaXRbMV07XG5cdFxuXHQgICAgICAgICAgICAgICAgaWYgKCFyZWN0c1tuYW1lXSkgcmVjdHNbbmFtZV0gPSB7fTtcblx0ICAgICAgICAgICAgICAgIHJlY3RzW25hbWVdW2lkXSA9IHRoaXMuaW5kZXhba2V5XTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgcmV0dXJuIHJlY3RzO1xuXHQgICAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgICBrZXk6ICdhZGRHbHlwaCcsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEdseXBoKGlkLCBuYW1lLCBnbHlwaCwgYnVmZmVyLCBtYXJrRGlydHkpIHtcblx0ICAgICAgICAgICAgaWYgKCFnbHlwaCkgcmV0dXJuIG51bGw7XG5cdFxuXHQgICAgICAgICAgICB2YXIga2V5ID0gbmFtZSArICcjJyArIGdseXBoLmlkO1xuXHRcblx0ICAgICAgICAgICAgLy8gVGhlIGdseXBoIGlzIGFscmVhZHkgaW4gdGhpcyB0ZXh0dXJlLlxuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleFtrZXldKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHNba2V5XS5pbmRleE9mKGlkKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlkc1trZXldLnB1c2goaWQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhba2V5XTtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkV2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXJlZEhlaWdodCA9IGdseXBoLmhlaWdodCArIGJ1ZmZlciAqIDI7XG5cdFxuXHQgICAgICAgICAgICAvLyBBZGQgYSAxcHggYm9yZGVyIGFyb3VuZCBldmVyeSBpbWFnZS5cblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAxO1xuXHQgICAgICAgICAgICB2YXIgcGFja1dpZHRoID0gYnVmZmVyZWRXaWR0aCArIDIgKiBwYWRkaW5nO1xuXHQgICAgICAgICAgICB2YXIgcGFja0hlaWdodCA9IGJ1ZmZlcmVkSGVpZ2h0ICsgMiAqIHBhZGRpbmc7XG5cdFxuXHQgICAgICAgICAgICAvLyBJbmNyZWFzZSB0byBuZXh0IG51bWJlciBkaXZpc2libGUgYnkgNCwgYnV0IGF0IGxlYXN0IDEuXG5cdCAgICAgICAgICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIHNjYWxlIGRvd24gdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHBhY2sgdGhlbVxuXHQgICAgICAgICAgICAvLyBpbnRvIGZld2VyIGJ5dGVzLlxuXHQgICAgICAgICAgICBwYWNrV2lkdGggKz0gNCAtIHBhY2tXaWR0aCAlIDQ7XG5cdCAgICAgICAgICAgIHBhY2tIZWlnaHQgKz0gNCAtIHBhY2tIZWlnaHQgJSA0O1xuXHRcblx0ICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmJpbi5wYWNrT25lKHBhY2tXaWR0aCwgcGFja0hlaWdodCk7XG5cdCAgICAgICAgICAgIGlmICghcmVjdCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcblx0ICAgICAgICAgICAgICAgIHJlY3QgPSB0aGlzLmJpbi5wYWNrT25lKHBhY2tXaWR0aCwgcGFja0hlaWdodCk7XG5cdCAgICAgICAgICAgICAgICBtYXJrRGlydHkgJiYgbWFya0RpcnR5KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFyZWN0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdGhpcy5pbmRleFtrZXldID0gcmVjdDtcblx0ICAgICAgICAgICAgdGhpcy5pZHNba2V5XSA9IFtpZF07XG5cdFxuXHQgICAgICAgICAgICBpZiAoZ2x5cGguYml0bWFwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kYXRhO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGdseXBoLmJpdG1hcDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYnVmZmVyZWRIZWlnaHQ7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSArIHBhZGRpbmcpICsgcmVjdC54ICsgcGFkZGluZztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSBidWZmZXJlZFdpZHRoICogeTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlcmVkV2lkdGg7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IHNvdXJjZVt5MiArIHhdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHRcblx0ICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cdFxuXHQgICAgICAgICAgICByZXR1cm4gcmVjdDtcblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiAncmVzaXplJyxcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuXHQgICAgICAgICAgICB2YXIgcHJldldpZHRoID0gdGhpcy53aWR0aDtcblx0ICAgICAgICAgICAgdmFyIHByZXZIZWlnaHQgPSB0aGlzLmhlaWdodDtcblx0XG5cdCAgICAgICAgICAgIGlmIChwcmV2V2lkdGggPj0gTUFYX1NJWkUgfHwgcHJldkhlaWdodCA+PSBNQVhfU0laRSkgcmV0dXJuO1xuXHRcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmdsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMuX3RleHR1cmUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICAgIHRoaXMud2lkdGggKj0gU0laRV9HUk9XVEhfUkFURTtcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgKj0gU0laRV9HUk9XVEhfUkFURTtcblx0ICAgICAgICAgICAgdGhpcy5iaW4ucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XG5cdCAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2SGVpZ2h0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCBwcmV2SGVpZ2h0ICogaSwgcHJldldpZHRoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShidWYsIHByZXZIZWlnaHQgKiBpICogU0laRV9HUk9XVEhfUkFURSwgcHJldldpZHRoKTtcblx0ICAgICAgICAgICAgICAgIGRzdC5zZXQoc3JjKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShidWYpO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXNldENhY2hlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ2JpbmQnLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKGdsKSB7fVxuXHQgICAgfSwge1xuXHQgICAgICAgIGtleTogJ3VwZGF0ZVRleHR1cmUnLFxuXHQgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUZXh0dXJlKCkge1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHQgICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG5cdCAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiAndGV4dHVyZScsXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuXHQgICAgICAgIH1cblx0ICAgIH1dKTtcblx0XG5cdCAgICByZXR1cm4gR2x5cGhBdGxhcztcblx0fSgpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gR2x5cGhBdGxhcztcblx0O1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0ICAgICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHQgICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0ICAgIChnbG9iYWwuU2hlbGZQYWNrID0gZmFjdG9yeSgpKTtcblx0fSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IFNoZWxmUGFjayBiaW4gYWxsb2NhdG9yLlxuXHQgKlxuXHQgKiBVc2VzIHRoZSBTaGVsZiBCZXN0IEhlaWdodCBGaXQgYWxnb3JpdGhtIGZyb21cblx0ICogaHR0cDovL2NsYi5kZW1vbi5maS9maWxlcy9SZWN0YW5nbGVCaW5QYWNrLnBkZlxuXHQgKlxuXHQgKiBAY2xhc3MgIFNoZWxmUGFja1xuXHQgKiBAcGFyYW0gIHtudW1iZXJ9ICBbdz02NF0gIEluaXRpYWwgd2lkdGggb2YgdGhlIHNwcml0ZVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9ICBbaD02NF0gIEluaXRpYWwgd2lkdGggb2YgdGhlIHNwcml0ZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9ICBbb3B0aW9uc11cblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b1Jlc2l6ZT1mYWxzZV0gIElmIGB0cnVlYCwgdGhlIHNwcml0ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ3Jvd1xuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgc3ByaXRlID0gbmV3IFNoZWxmUGFjayg2NCwgNjQsIHsgYXV0b1Jlc2l6ZTogZmFsc2UgfSk7XG5cdCAqL1xuXHRmdW5jdGlvbiBTaGVsZlBhY2sodywgaCwgb3B0aW9ucykge1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICB0aGlzLncgPSB3IHx8IDY0O1xuXHQgICAgdGhpcy5oID0gaCB8fCA2NDtcblx0ICAgIHRoaXMuYXV0b1Jlc2l6ZSA9ICEhb3B0aW9ucy5hdXRvUmVzaXplO1xuXHQgICAgdGhpcy5zaGVsdmVzID0gW107XG5cdCAgICB0aGlzLmZyZWViaW5zID0gW107XG5cdCAgICB0aGlzLnN0YXRzID0ge307XG5cdCAgICB0aGlzLmJpbnMgPSB7fTtcblx0ICAgIHRoaXMubWF4SWQgPSAwO1xuXHR9XG5cdFxuXHRcblx0LyoqXG5cdCAqIEJhdGNoIHBhY2sgbXVsdGlwbGUgYmlucyBpbnRvIHRoZSBzcHJpdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSAgIHtPYmplY3RbXX0gYmlucyAgICAgICBBcnJheSBvZiByZXF1ZXN0ZWQgYmlucyAtIGVhY2ggb2JqZWN0IHNob3VsZCBoYXZlIGB3aWR0aGAsIGBoZWlnaHRgIChvciBgd2AsIGBoYCkgcHJvcGVydGllc1xuXHQgKiBAcGFyYW0gICB7bnVtYmVyfSAgIGJpbnNbXS53ICAgUmVxdWVzdGVkIGJpbiB3aWR0aFxuXHQgKiBAcGFyYW0gICB7bnVtYmVyfSAgIGJpbnNbXS5oICAgUmVxdWVzdGVkIGJpbiBoZWlnaHRcblx0ICogQHBhcmFtICAge09iamVjdH0gICBbb3B0aW9uc11cblx0ICogQHBhcmFtICAge2Jvb2xlYW59ICBbb3B0aW9ucy5pblBsYWNlPWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZSBzdXBwbGllZCBiaW4gb2JqZWN0cyB3aWxsIGJlIHVwZGF0ZWQgaW5wbGFjZSB3aXRoIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcblx0ICogQHJldHVybnMge0JpbltdfSAgICBBcnJheSBvZiBhbGxvY2F0ZWQgQmlucyAtIGVhY2ggQmluIGlzIGFuIG9iamVjdCB3aXRoIGBpZGAsIGB4YCwgYHlgLCBgd2AsIGBoYCBwcm9wZXJ0aWVzXG5cdCAqIEBleGFtcGxlXG5cdCAqIHZhciBiaW5zID0gW1xuXHQgKiAgICAgeyBpZDogMSwgdzogMTIsIGg6IDEyIH0sXG5cdCAqICAgICB7IGlkOiAyLCB3OiAxMiwgaDogMTYgfSxcblx0ICogICAgIHsgaWQ6IDMsIHc6IDEyLCBoOiAyNCB9XG5cdCAqIF07XG5cdCAqIHZhciByZXN1bHRzID0gc3ByaXRlLnBhY2soYmlucywgeyBpblBsYWNlOiBmYWxzZSB9KTtcblx0ICovXG5cdFNoZWxmUGFjay5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKGJpbnMsIG9wdGlvbnMpIHtcblx0ICAgIGJpbnMgPSBbXS5jb25jYXQoYmlucyk7XG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XG5cdCAgICB2YXIgcmVzdWx0cyA9IFtdLFxuXHQgICAgICAgIHcsIGgsIGlkLCBhbGxvY2F0aW9uO1xuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmlucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHcgID0gYmluc1tpXS53IHx8IGJpbnNbaV0ud2lkdGg7XG5cdCAgICAgICAgaCAgPSBiaW5zW2ldLmggfHwgYmluc1tpXS5oZWlnaHQ7XG5cdCAgICAgICAgaWQgPSBiaW5zW2ldLmlkO1xuXHRcblx0ICAgICAgICBpZiAodyAmJiBoKSB7XG5cdCAgICAgICAgICAgIGFsbG9jYXRpb24gPSB0aGlzLnBhY2tPbmUodywgaCwgaWQpO1xuXHQgICAgICAgICAgICBpZiAoIWFsbG9jYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmluUGxhY2UpIHtcblx0ICAgICAgICAgICAgICAgIGJpbnNbaV0ueCAgPSBhbGxvY2F0aW9uLng7XG5cdCAgICAgICAgICAgICAgICBiaW5zW2ldLnkgID0gYWxsb2NhdGlvbi55O1xuXHQgICAgICAgICAgICAgICAgYmluc1tpXS5pZCA9IGFsbG9jYXRpb24uaWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGFsbG9jYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyBTaHJpbmsgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgc3ByaXRlIHRvIHRoZSBiYXJlIG1pbmltdW0uXG5cdCAgICAvLyBTaW5jZSBzaGVsZi1wYWNrIGRvdWJsZXMgZmlyc3Qgd2lkdGgsIHRoZW4gaGVpZ2h0IHdoZW4gcnVubmluZyBvdXQgb2Ygc2hlbGYgc3BhY2Vcblx0ICAgIC8vIHRoaXMgY2FuIHJlc3VsdCBpbiBmYWlybHkgbGFyZ2UgdW51c2VkIHNwYWNlIGJvdGggaW4gd2lkdGggYW5kIGhlaWdodCBpZiB0aGF0IGhhcHBlbnNcblx0ICAgIC8vIHRvd2FyZHMgdGhlIGVuZCBvZiBiaW4gcGFja2luZy5cblx0ICAgIGlmICh0aGlzLnNoZWx2ZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIHZhciB3MiA9IDA7XG5cdCAgICAgICAgdmFyIGgyID0gMDtcblx0XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIHNoZWxmID0gdGhpcy5zaGVsdmVzW2pdO1xuXHQgICAgICAgICAgICBoMiArPSBzaGVsZi5oO1xuXHQgICAgICAgICAgICB3MiA9IE1hdGgubWF4KHNoZWxmLncgLSBzaGVsZi5mcmVlLCB3Mik7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICB0aGlzLnJlc2l6ZSh3MiwgaDIpO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBQYWNrIGEgc2luZ2xlIGJpbiBpbnRvIHRoZSBzcHJpdGUuXG5cdCAqXG5cdCAqIEVhY2ggYmluIHdpbGwgaGF2ZSBhIHVuaXF1ZSBpZGVudGl0aWZlci5cblx0ICogSWYgbm8gaWRlbnRpZmllciBpcyBzdXBwbGllZCBpbiB0aGUgYGlkYCBwYXJhbWV0ZXIsIG9uZSB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqIE5vdGU6IFRoZSBzdXBwbGllZCBgaWRgIGlzIHVzZWQgYXMgYW4gb2JqZWN0IGluZGV4LCBzbyBudW1lcmljIHZhbHVlcyBhcmUgZmFzdGVzdCFcblx0ICpcblx0ICogQmlucyBhcmUgYXV0b21hdGljYWxseSByZWZjb3VudGVkIChpLmUuIGEgbmV3bHkgcGFja2VkIEJpbiB3aWxsIGhhdmUgYSByZWZjb3VudCBvZiAxKS5cblx0ICogV2hlbiBhIGJpbiBpcyBubyBsb25nZXIgbmVlZGVkLCB1c2UgdGhlIGBTaGVsZlBhY2sudW5yZWZgIGZ1bmN0aW9uIHRvIG1hcmsgaXRcblx0ICogICBhcyB1bnVzZWQuICBXaGVuIGEgQmluJ3MgcmVmY291bnQgZGVjcmVtZW50cyB0byAwLCB0aGUgQmluIHdpbGwgYmUgbWFya2VkXG5cdCAqICAgYXMgZnJlZSBhbmQgaXRzIHNwYWNlIG1heSBiZSByZXVzZWQgYnkgdGhlIHBhY2tpbmcgY29kZS5cblx0ICpcblx0ICogQHBhcmFtICAgIHtudW1iZXJ9ICAgICAgICAgdyAgICAgIFdpZHRoIG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcblx0ICogQHBhcmFtICAgIHtudW1iZXJ9ICAgICAgICAgaCAgICAgIEhlaWdodCBvZiB0aGUgYmluIHRvIGFsbG9jYXRlXG5cdCAqIEBwYXJhbSAgICB7bnVtYmVyfHN0cmluZ30gIFtpZF0gICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBiaW4sIChpZiB1bnN1cHBsaWVkLCBhc3N1bWUgaXQncyBhIG5ldyBiaW4gYW5kIGNyZWF0ZSBhbiBpZClcblx0ICogQHJldHVybnMgIHtCaW59ICAgICAgICAgICAgQmluIG9iamVjdCB3aXRoIGBpZGAsIGB4YCwgYHlgLCBgd2AsIGBoYCBwcm9wZXJ0aWVzLCBvciBgbnVsbGAgaWYgYWxsb2NhdGlvbiBmYWlsZWRcblx0ICogQGV4YW1wbGVcblx0ICogdmFyIHJlc3VsdHMgPSBzcHJpdGUucGFja09uZSgxMiwgMTYsICdhJyk7XG5cdCAqL1xuXHRTaGVsZlBhY2sucHJvdG90eXBlLnBhY2tPbmUgPSBmdW5jdGlvbih3LCBoLCBpZCkge1xuXHQgICAgdmFyIGJlc3QgPSB7IGZyZWViaW46IC0xLCBzaGVsZjogLTEsIHdhc3RlOiBJbmZpbml0eSB9LFxuXHQgICAgICAgIHkgPSAwLFxuXHQgICAgICAgIGJpbiwgc2hlbGYsIHdhc3RlLCBpO1xuXHRcblx0ICAgIC8vIGlmIGlkIHdhcyBzdXBwbGllZCwgYXR0ZW1wdCBhIGxvb2t1cC4uXG5cdCAgICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgYmluID0gdGhpcy5nZXRCaW4oaWQpO1xuXHQgICAgICAgIGlmIChiaW4pIHsgICAgICAgICAgICAgIC8vIHdlIHBhY2tlZCB0aGlzIGJpbiBhbHJlYWR5XG5cdCAgICAgICAgICAgIHRoaXMucmVmKGJpbik7XG5cdCAgICAgICAgICAgIHJldHVybiBiaW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWF4SWQgPSBNYXRoLm1heChpZCwgdGhpcy5tYXhJZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZCA9ICsrdGhpcy5tYXhJZDtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBGaXJzdCB0cnkgdG8gcmV1c2UgYSBmcmVlIGJpbi4uXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5mcmVlYmlucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGJpbiA9IHRoaXMuZnJlZWJpbnNbaV07XG5cdFxuXHQgICAgICAgIC8vIGV4YWN0bHkgdGhlIHJpZ2h0IGhlaWdodCBhbmQgd2lkdGgsIHVzZSBpdC4uXG5cdCAgICAgICAgaWYgKGggPT09IGJpbi5tYXhoICYmIHcgPT09IGJpbi5tYXh3KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbG9jRnJlZWJpbihpLCB3LCBoLCBpZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIG5vdCBlbm91Z2ggaGVpZ2h0IG9yIHdpZHRoLCBza2lwIGl0Li5cblx0ICAgICAgICBpZiAoaCA+IGJpbi5tYXhoIHx8IHcgPiBiaW4ubWF4dykge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gZXh0cmEgaGVpZ2h0IG9yIHdpZHRoLCBtaW5pbWl6ZSB3YXN0ZWQgYXJlYS4uXG5cdCAgICAgICAgaWYgKGggPD0gYmluLm1heGggJiYgdyA8PSBiaW4ubWF4dykge1xuXHQgICAgICAgICAgICB3YXN0ZSA9IChiaW4ubWF4dyAqIGJpbi5tYXhoKSAtICh3ICogaCk7XG5cdCAgICAgICAgICAgIGlmICh3YXN0ZSA8IGJlc3Qud2FzdGUpIHtcblx0ICAgICAgICAgICAgICAgIGJlc3Qud2FzdGUgPSB3YXN0ZTtcblx0ICAgICAgICAgICAgICAgIGJlc3QuZnJlZWJpbiA9IGk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gTmV4dCBmaW5kIHRoZSBiZXN0IHNoZWxmLi5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBzaGVsZiA9IHRoaXMuc2hlbHZlc1tpXTtcblx0ICAgICAgICB5ICs9IHNoZWxmLmg7XG5cdFxuXHQgICAgICAgIC8vIG5vdCBlbm91Z2ggd2lkdGggb24gdGhpcyBzaGVsZiwgc2tpcCBpdC4uXG5cdCAgICAgICAgaWYgKHcgPiBzaGVsZi5mcmVlKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBleGFjdGx5IHRoZSByaWdodCBoZWlnaHQsIHBhY2sgaXQuLlxuXHQgICAgICAgIGlmIChoID09PSBzaGVsZi5oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbG9jU2hlbGYoaSwgdywgaCwgaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBub3QgZW5vdWdoIGhlaWdodCwgc2tpcCBpdC4uXG5cdCAgICAgICAgaWYgKGggPiBzaGVsZi5oKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBleHRyYSBoZWlnaHQsIG1pbmltaXplIHdhc3RlZCBhcmVhLi5cblx0ICAgICAgICBpZiAoaCA8IHNoZWxmLmgpIHtcblx0ICAgICAgICAgICAgd2FzdGUgPSAoc2hlbGYuaCAtIGgpICogdztcblx0ICAgICAgICAgICAgaWYgKHdhc3RlIDwgYmVzdC53YXN0ZSkge1xuXHQgICAgICAgICAgICAgICAgYmVzdC5mcmVlYmluID0gLTE7XG5cdCAgICAgICAgICAgICAgICBiZXN0Lndhc3RlID0gd2FzdGU7XG5cdCAgICAgICAgICAgICAgICBiZXN0LnNoZWxmID0gaTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICBpZiAoYmVzdC5mcmVlYmluICE9PSAtMSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmFsbG9jRnJlZWJpbihiZXN0LmZyZWViaW4sIHcsIGgsIGlkKTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoYmVzdC5zaGVsZiAhPT0gLTEpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5hbGxvY1NoZWxmKGJlc3Quc2hlbGYsIHcsIGgsIGlkKTtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBObyBmcmVlIGJpbnMgb3Igc2hlbHZlcy4uIGFkZCBzaGVsZi4uXG5cdCAgICBpZiAoaCA8PSAodGhpcy5oIC0geSkgJiYgdyA8PSB0aGlzLncpIHtcblx0ICAgICAgICBzaGVsZiA9IG5ldyBTaGVsZih5LCB0aGlzLncsIGgpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmFsbG9jU2hlbGYodGhpcy5zaGVsdmVzLnB1c2goc2hlbGYpIC0gMSwgdywgaCwgaWQpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8vIE5vIHJvb20gZm9yIG1vcmUgc2hlbHZlcy4uXG5cdCAgICAvLyBJZiBgYXV0b1Jlc2l6ZWAgb3B0aW9uIGlzIHNldCwgZ3JvdyB0aGUgc3ByaXRlIGFzIGZvbGxvd3M6XG5cdCAgICAvLyAgKiBkb3VibGUgd2hpY2hldmVyIHNwcml0ZSBkaW1lbnNpb24gaXMgc21hbGxlciAoYHcxYCBvciBgaDFgKVxuXHQgICAgLy8gICogaWYgc3ByaXRlIGRpbWVuc2lvbnMgYXJlIGVxdWFsLCBncm93IHdpZHRoIGJlZm9yZSBoZWlnaHRcblx0ICAgIC8vICAqIGFjY29tb2RhdGUgdmVyeSBsYXJnZSBiaW4gcmVxdWVzdHMgKGJpZyBgd2Agb3IgYGhgKVxuXHQgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuXHQgICAgICAgIHZhciBoMSwgaDIsIHcxLCB3Mjtcblx0XG5cdCAgICAgICAgaDEgPSBoMiA9IHRoaXMuaDtcblx0ICAgICAgICB3MSA9IHcyID0gdGhpcy53O1xuXHRcblx0ICAgICAgICBpZiAodzEgPD0gaDEgfHwgdyA+IHcxKSB7ICAgLy8gZ3JvdyB3aWR0aC4uXG5cdCAgICAgICAgICAgIHcyID0gTWF0aC5tYXgodywgdzEpICogMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGgxIDwgdzEgfHwgaCA+IGgxKSB7ICAgIC8vIGdyb3cgaGVpZ2h0Li5cblx0ICAgICAgICAgICAgaDIgPSBNYXRoLm1heChoLCBoMSkgKiAyO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgdGhpcy5yZXNpemUodzIsIGgyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYWNrT25lKHcsIGgsIGlkKTsgIC8vIHJldHJ5XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENhbGxlZCBieSBwYWNrT25lKCkgdG8gYWxsb2NhdGUgYSBiaW4gYnkgcmV1c2luZyBhbiBleGlzdGluZyBmcmVlYmluXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAgICB7bnVtYmVyfSAgICAgICAgIGluZGV4ICBJbmRleCBpbnRvIHRoZSBgdGhpcy5mcmVlYmluc2AgYXJyYXlcblx0ICogQHBhcmFtICAgIHtudW1iZXJ9ICAgICAgICAgdyAgICAgIFdpZHRoIG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcblx0ICogQHBhcmFtICAgIHtudW1iZXJ9ICAgICAgICAgaCAgICAgIEhlaWdodCBvZiB0aGUgYmluIHRvIGFsbG9jYXRlXG5cdCAqIEBwYXJhbSAgICB7bnVtYmVyfHN0cmluZ30gIGlkICAgICBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBiaW5cblx0ICogQHJldHVybnMgIHtCaW59ICAgICAgICAgICAgQmluIG9iamVjdCB3aXRoIGBpZGAsIGB4YCwgYHlgLCBgd2AsIGBoYCBwcm9wZXJ0aWVzXG5cdCAqIEBleGFtcGxlXG5cdCAqIHZhciBiaW4gPSBzcHJpdGUuYWxsb2NGcmVlYmluKDAsIDEyLCAxNiwgJ2EnKTtcblx0ICovXG5cdFNoZWxmUGFjay5wcm90b3R5cGUuYWxsb2NGcmVlYmluID0gZnVuY3Rpb24gKGluZGV4LCB3LCBoLCBpZCkge1xuXHQgICAgdmFyIGJpbiA9IHRoaXMuZnJlZWJpbnMuc3BsaWNlKGluZGV4LCAxKVswXTtcblx0ICAgIGJpbi5pZCA9IGlkO1xuXHQgICAgYmluLncgPSB3O1xuXHQgICAgYmluLmggPSBoO1xuXHQgICAgYmluLnJlZmNvdW50ID0gMDtcblx0ICAgIHRoaXMuYmluc1tpZF0gPSBiaW47XG5cdCAgICB0aGlzLnJlZihiaW4pO1xuXHQgICAgcmV0dXJuIGJpbjtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIGJ5IGBwYWNrT25lKCkgdG8gYWxsb2NhdGUgYmluIG9uIGFuIGV4aXN0aW5nIHNoZWxmXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAgICB7bnVtYmVyfSAgICAgICAgIGluZGV4ICBJbmRleCBpbnRvIHRoZSBgdGhpcy5zaGVsdmVzYCBhcnJheVxuXHQgKiBAcGFyYW0gICAge251bWJlcn0gICAgICAgICB3ICAgICAgV2lkdGggb2YgdGhlIGJpbiB0byBhbGxvY2F0ZVxuXHQgKiBAcGFyYW0gICAge251bWJlcn0gICAgICAgICBoICAgICAgSGVpZ2h0IG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcblx0ICogQHBhcmFtICAgIHtudW1iZXJ8c3RyaW5nfSAgaWQgICAgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGJpblxuXHQgKiBAcmV0dXJucyAge0Jpbn0gICAgICAgICAgICBCaW4gb2JqZWN0IHdpdGggYGlkYCwgYHhgLCBgeWAsIGB3YCwgYGhgIHByb3BlcnRpZXNcblx0ICogQGV4YW1wbGVcblx0ICogdmFyIHJlc3VsdHMgPSBzcHJpdGUuYWxsb2NTaGVsZigwLCAxMiwgMTYsICdhJyk7XG5cdCAqL1xuXHRTaGVsZlBhY2sucHJvdG90eXBlLmFsbG9jU2hlbGYgPSBmdW5jdGlvbihpbmRleCwgdywgaCwgaWQpIHtcblx0ICAgIHZhciBzaGVsZiA9IHRoaXMuc2hlbHZlc1tpbmRleF07XG5cdCAgICB2YXIgYmluID0gc2hlbGYuYWxsb2ModywgaCwgaWQpO1xuXHQgICAgdGhpcy5iaW5zW2lkXSA9IGJpbjtcblx0ICAgIHRoaXMucmVmKGJpbik7XG5cdCAgICByZXR1cm4gYmluO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBwYWNrZWQgYmluIGdpdmVuIGl0cyBpZCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBpZCBpcyBub3QgZm91bmRcblx0ICpcblx0ICogQHBhcmFtICAgIHtudW1iZXJ8c3RyaW5nfSAgaWQgIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGJpbixcblx0ICogQHJldHVybnMgIHtCaW59ICAgICAgICAgICAgVGhlIHJlcXVlc3RlZCBiaW4sIG9yIHVuZGVmaW5lZCBpZiBub3QgeWV0IHBhY2tlZFxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgYiA9IHNwcml0ZS5nZXRCaW4oJ2EnKTtcblx0ICovXG5cdFNoZWxmUGFjay5wcm90b3R5cGUuZ2V0QmluID0gZnVuY3Rpb24oaWQpIHtcblx0ICAgIHJldHVybiB0aGlzLmJpbnNbaWRdO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBJbmNyZW1lbnQgdGhlIHJlZiBjb3VudCBvZiBhIGJpbiBhbmQgdXBkYXRlIHN0YXRpc3RpY3MuXG5cdCAqXG5cdCAqIEBwYXJhbSAgICB7QmlufSAgICAgYmluICBCaW4gaW5zdGFuY2Vcblx0ICogQHJldHVybnMgIHtudW1iZXJ9ICBOZXcgcmVmY291bnQgb2YgdGhlIGJpblxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgYmluID0gc3ByaXRlLmdldEJpbignYScpO1xuXHQgKiBzcHJpdGUucmVmKGJpbik7XG5cdCAqL1xuXHRTaGVsZlBhY2sucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKGJpbikge1xuXHQgICAgaWYgKCsrYmluLnJlZmNvdW50ID09PSAxKSB7ICAgLy8gYSBuZXcgQmluLi4gcmVjb3JkIGhlaWdodCBpbiBzdGF0cyBoaXN0b3JncmFtLi5cblx0ICAgICAgICB2YXIgaCA9IGJpbi5oO1xuXHQgICAgICAgIHRoaXMuc3RhdHNbaF0gPSAodGhpcy5zdGF0c1toXSB8IDApICsgMTtcblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gYmluLnJlZmNvdW50O1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBEZWNyZW1lbnQgdGhlIHJlZiBjb3VudCBvZiBhIGJpbiBhbmQgdXBkYXRlIHN0YXRpc3RpY3MuXG5cdCAqIFRoZSBiaW4gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IG1hcmtlZCBhcyBmcmVlIHNwYWNlIG9uY2UgdGhlIHJlZmNvdW50IHJlYWNoZXMgMC5cblx0ICpcblx0ICogQHBhcmFtICAgIHtCaW59ICAgICBiaW4gIEJpbiBpbnN0YW5jZVxuXHQgKiBAcmV0dXJucyAge251bWJlcn0gIE5ldyByZWZjb3VudCBvZiB0aGUgYmluXG5cdCAqIEBleGFtcGxlXG5cdCAqIHZhciBiaW4gPSBzcHJpdGUuZ2V0QmluKCdhJyk7XG5cdCAqIHNwcml0ZS51bnJlZihiaW4pO1xuXHQgKi9cblx0U2hlbGZQYWNrLnByb3RvdHlwZS51bnJlZiA9IGZ1bmN0aW9uKGJpbikge1xuXHQgICAgaWYgKGJpbi5yZWZjb3VudCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmICgtLWJpbi5yZWZjb3VudCA9PT0gMCkge1xuXHQgICAgICAgIHRoaXMuc3RhdHNbYmluLmhdLS07XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuYmluc1tiaW4uaWRdO1xuXHQgICAgICAgIHRoaXMuZnJlZWJpbnMucHVzaChiaW4pO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBiaW4ucmVmY291bnQ7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIENsZWFyIHRoZSBzcHJpdGUuICBSZXNldHMgZXZlcnl0aGluZyBhbmQgcmVzZXRzIHN0YXRpc3RpY3MuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIHNwcml0ZS5jbGVhcigpO1xuXHQgKi9cblx0U2hlbGZQYWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5zaGVsdmVzID0gW107XG5cdCAgICB0aGlzLmZyZWViaW5zID0gW107XG5cdCAgICB0aGlzLnN0YXRzID0ge307XG5cdCAgICB0aGlzLmJpbnMgPSB7fTtcblx0ICAgIHRoaXMubWF4SWQgPSAwO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBSZXNpemUgdGhlIHNwcml0ZS5cblx0ICpcblx0ICogQHBhcmFtICAge251bWJlcn0gIHcgIFJlcXVlc3RlZCBuZXcgc3ByaXRlIHdpZHRoXG5cdCAqIEBwYXJhbSAgIHtudW1iZXJ9ICBoICBSZXF1ZXN0ZWQgbmV3IHNwcml0ZSBoZWlnaHRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNpemUgc3VjY2VlZGVkLCBgZmFsc2VgIGlmIGZhaWxlZFxuXHQgKiBAZXhhbXBsZVxuXHQgKiBzcHJpdGUucmVzaXplKDI1NiwgMjU2KTtcblx0ICovXG5cdFNoZWxmUGFjay5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuXHQgICAgdGhpcy53ID0gdztcblx0ICAgIHRoaXMuaCA9IGg7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hlbHZlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMuc2hlbHZlc1tpXS5yZXNpemUodyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IFNoZWxmLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY2xhc3MgIFNoZWxmXG5cdCAqIEBwYXJhbSAge251bWJlcn0gIHkgICBUb3AgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHNoZWxmXG5cdCAqIEBwYXJhbSAge251bWJlcn0gIHcgICBXaWR0aCBvZiB0aGUgbmV3IHNoZWxmXG5cdCAqIEBwYXJhbSAge251bWJlcn0gIGggICBIZWlnaHQgb2YgdGhlIG5ldyBzaGVsZlxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgc2hlbGYgPSBuZXcgU2hlbGYoNjQsIDUxMiwgMjQpO1xuXHQgKi9cblx0ZnVuY3Rpb24gU2hlbGYoeSwgdywgaCkge1xuXHQgICAgdGhpcy54ID0gMDtcblx0ICAgIHRoaXMueSA9IHk7XG5cdCAgICB0aGlzLncgPSB0aGlzLmZyZWUgPSB3O1xuXHQgICAgdGhpcy5oID0gaDtcblx0fVxuXHRcblx0XG5cdC8qKlxuXHQgKiBBbGxvY2F0ZSBhIHNpbmdsZSBiaW4gaW50byB0aGUgc2hlbGYuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgICAgICAgdyAgIFdpZHRoIG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcblx0ICogQHBhcmFtICAge251bWJlcn0gICAgICAgICBoICAgSGVpZ2h0IG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcblx0ICogQHBhcmFtICAge251bWJlcnxzdHJpbmd9ICBpZCAgVW5pcXVlIGlkIG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcblx0ICogQHJldHVybnMge0Jpbn0gICAgICAgICAgICBCaW4gb2JqZWN0IHdpdGggYGlkYCwgYHhgLCBgeWAsIGB3YCwgYGhgIHByb3BlcnRpZXMsIG9yIGBudWxsYCBpZiBhbGxvY2F0aW9uIGZhaWxlZFxuXHQgKiBAZXhhbXBsZVxuXHQgKiBzaGVsZi5hbGxvYygxMiwgMTYsICdhJyk7XG5cdCAqL1xuXHRTaGVsZi5wcm90b3R5cGUuYWxsb2MgPSBmdW5jdGlvbih3LCBoLCBpZCkge1xuXHQgICAgaWYgKHcgPiB0aGlzLmZyZWUgfHwgaCA+IHRoaXMuaCkge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgdmFyIHggPSB0aGlzLng7XG5cdCAgICB0aGlzLnggKz0gdztcblx0ICAgIHRoaXMuZnJlZSAtPSB3O1xuXHQgICAgcmV0dXJuIG5ldyBCaW4oaWQsIHgsIHRoaXMueSwgdywgaCk7XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIFJlc2l6ZSB0aGUgc2hlbGYuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAgIHtudW1iZXJ9ICB3ICBSZXF1ZXN0ZWQgbmV3IHdpZHRoIG9mIHRoZSBzaGVsZlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgdHJ1ZVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBzaGVsZi5yZXNpemUoNTEyKTtcblx0ICovXG5cdFNoZWxmLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3KSB7XG5cdCAgICB0aGlzLmZyZWUgKz0gKHcgLSB0aGlzLncpO1xuXHQgICAgdGhpcy53ID0gdztcblx0ICAgIHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgQmluIG9iamVjdC5cblx0ICpcblx0ICogQGNsYXNzICBCaW5cblx0ICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gIGlkICBVbmlxdWUgaWQgb2YgdGhlIGJpblxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgeCAgIExlZnQgY29vcmRpbmF0ZSBvZiB0aGUgYmluXG5cdCAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICB5ICAgVG9wIGNvb3JkaW5hdGUgb2YgdGhlIGJpblxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgdyAgIFdpZHRoIG9mIHRoZSBiaW5cblx0ICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgIGggICBIZWlnaHQgb2YgdGhlIGJpblxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgYmluID0gbmV3IEJpbignYScsIDAsIDAsIDEyLCAxNik7XG5cdCAqL1xuXHRmdW5jdGlvbiBCaW4oaWQsIHgsIHksIHcsIGgpIHtcblx0ICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgIHRoaXMueCAgPSB4O1xuXHQgICAgdGhpcy55ICA9IHk7XG5cdCAgICB0aGlzLncgID0gdztcblx0ICAgIHRoaXMuaCAgPSBoO1xuXHQgICAgdGhpcy5tYXh3ID0gdztcblx0ICAgIHRoaXMubWF4aCA9IGg7XG5cdCAgICB0aGlzLnJlZmNvdW50ID0gMDtcblx0fVxuXHRcblx0cmV0dXJuIFNoZWxmUGFjaztcblx0XG5cdH0pKTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IEdseXBocztcblx0ZnVuY3Rpb24gR2x5cGhzKHBiZiwgZW5kKSB7XG5cdCAgICB0aGlzLnN0YWNrcyA9IHBiZi5yZWFkRmllbGRzKHJlYWRGb250c3RhY2tzLCBbXSwgZW5kKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gcmVhZEZvbnRzdGFja3ModGFnLCBzdGFja3MsIHBiZikge1xuXHQgICAgaWYgKHRhZyA9PT0gMSkge1xuXHQgICAgICAgIHZhciBmb250c3RhY2sgPSBwYmYucmVhZE1lc3NhZ2UocmVhZEZvbnRzdGFjaywgeyBnbHlwaHM6IHt9IH0pO1xuXHQgICAgICAgIHN0YWNrcy5wdXNoKGZvbnRzdGFjayk7XG5cdCAgICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlYWRGb250c3RhY2sodGFnLCBmb250c3RhY2ssIHBiZikge1xuXHQgICAgaWYgKHRhZyA9PT0gMSkgZm9udHN0YWNrLm5hbWUgPSBwYmYucmVhZFN0cmluZygpO2Vsc2UgaWYgKHRhZyA9PT0gMikgZm9udHN0YWNrLnJhbmdlID0gcGJmLnJlYWRTdHJpbmcoKTtlbHNlIGlmICh0YWcgPT09IDMpIHtcblx0ICAgICAgICB2YXIgZ2x5cGggPSBwYmYucmVhZE1lc3NhZ2UocmVhZEdseXBoLCB7fSk7XG5cdCAgICAgICAgZm9udHN0YWNrLmdseXBoc1tnbHlwaC5pZF0gPSBnbHlwaDtcblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gcmVhZEdseXBoKHRhZywgZ2x5cGgsIHBiZikge1xuXHQgICAgaWYgKHRhZyA9PT0gMSkgZ2x5cGguaWQgPSBwYmYucmVhZFZhcmludCgpO2Vsc2UgaWYgKHRhZyA9PT0gMikgZ2x5cGguYml0bWFwID0gcGJmLnJlYWRCeXRlcygpO2Vsc2UgaWYgKHRhZyA9PT0gMykgZ2x5cGgud2lkdGggPSBwYmYucmVhZFZhcmludCgpO2Vsc2UgaWYgKHRhZyA9PT0gNCkgZ2x5cGguaGVpZ2h0ID0gcGJmLnJlYWRWYXJpbnQoKTtlbHNlIGlmICh0YWcgPT09IDUpIGdseXBoLmxlZnQgPSBwYmYucmVhZFNWYXJpbnQoKTtlbHNlIGlmICh0YWcgPT09IDYpIGdseXBoLnRvcCA9IHBiZi5yZWFkU1ZhcmludCgpO2Vsc2UgaWYgKHRhZyA9PT0gNykgZ2x5cGguYWR2YW5jZSA9IHBiZi5yZWFkVmFyaW50KCk7XG5cdH1cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3JzOiBEYXZpZCBUaWNoeSwgQWxlxaEgU2Fza2Fcblx0ICovXG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gX2NsYXNzKCkge1xuXHQgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfY2xhc3MpO1xuXHRcblx0ICAgICAgICB0aGlzLl9lbmFibGUgPSB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG5cdCAgICAgICAga2V5OiBcImRlYm91bmNlXCIsXG5cdCAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblx0XG5cdCAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwLFxuXHQgICAgICAgICAgICAgICAgYXJncyA9IHZvaWQgMCxcblx0ICAgICAgICAgICAgICAgIGNvbnRleHQgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSB2b2lkIDAsXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG5cdFxuXHQgICAgICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gRGF0ZS5ub3cgLSB0aW1lc3RhbXA7XG5cdFxuXHQgICAgICAgICAgICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHRcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRleHQgPSBfdGhpcztcblx0ICAgICAgICAgICAgICAgIGFyZ3MgPSBfYXJndW1lbnRzO1xuXHQgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3c7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcblx0ICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhbGxOb3cpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2VuYWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdFxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgICAga2V5OiBcImRpc2FibGVcIixcblx0ICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZW5hYmxlID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfV0pO1xuXHRcblx0ICAgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHR2YXIgX2dlb211dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXHRcblx0dmFyIF9nZW9tdXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2VvbXV0aWxzKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0LyoqXG5cdCAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIEhlbGlrYXIgTGFiLlxuXHQgKiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblx0ICpcblx0ICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEdQTHYzIExpY2Vuc2UuXG5cdCAqICBBdXRob3I6IEFsZcWhIFNhc2thXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gcHVzaFVuaXF1ZShhcnIsIGUpIHtcblx0ICBpZiAoYXJyLmluZGV4T2YoZSkgPj0gMCkgcmV0dXJuO1xuXHQgIGFyci5wdXNoKGUpO1xuXHR9XG5cdFxuXHR2YXIgX2NsYXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIF9jbGFzcyhsYXllcnMsIGluc2VydFRlbXBMYXllciwgZHJhdywgbm9kZXMsIGVkZ2VzLCBjaGVja1VuaXFJZCkge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblx0XG5cdCAgICB0aGlzLl9sYXllcnMgPSBsYXllcnM7XG5cdCAgICB0aGlzLl9pbnNlcnRUZW1wTGF5ZXIgPSBpbnNlcnRUZW1wTGF5ZXI7XG5cdFxuXHQgICAgdGhpcy5fZHJhdyA9IGRyYXc7XG5cdCAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xuXHQgICAgdGhpcy5fZWRnZXMgPSBlZGdlcztcblx0ICAgIHRoaXMuX2NoZWNrVW5pcUlkID0gY2hlY2tVbmlxSWQ7XG5cdFxuXHQgICAgdGhpcy5fdG9BZGRFZGdlcyA9IFtdO1xuXHQgICAgdGhpcy5fdG9BZGROb2RlcyA9IFtdO1xuXHQgICAgdGhpcy5fdG9SZW1vdmVFZGdlcyA9IFtdO1xuXHQgICAgdGhpcy5fdG9SZW1vdmVOb2RlcyA9IFtdO1xuXHRcblx0ICAgIC8vY3JlYXRlIHN1cHBvcnQgc3RydWN0dXJlc1xuXHQgICAgdGhpcy5fblBvcyA9IHt9O1xuXHQgICAgdGhpcy5fZVBvcyA9IHt9O1xuXHQgICAgdGhpcy5fZURpcnMgPSB7fTtcblx0XG5cdCAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuLCBpKSB7XG5cdCAgICAgIF90aGlzLl9uUG9zW24udW5pcWlkXSA9IGk7XG5cdCAgICAgIF90aGlzLl9lRGlyc1tuLnVuaXFpZF0gPSB7fTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcblx0ICAgICAgdmFyIHMgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VTb3VyY2UoZSk7XG5cdCAgICAgIHZhciB0ID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlVGFyZ2V0KGUpO1xuXHRcblx0ICAgICAgdmFyIHNpID0gcy51bmlxaWQgfHwgcy5fX3VuaXFpZDtcblx0ICAgICAgdmFyIHRpID0gdC51bmlxaWQgfHwgdC5fX3VuaXFpZDtcblx0ICAgICAgKF90aGlzLl9lRGlyc1tzaV0gfHwgKF90aGlzLl9lRGlyc1tzaV0gPSB7fSkpW3RpXSA9IGU7XG5cdCAgICAgIF90aGlzLl9lUG9zW2UudW5pcWlkXSA9IGk7XG5cdCAgICB9KTtcblx0XG5cdCAgICB0aGlzLl9hY3R1YWxUZW1wTm9kZXMgPSBbXTtcblx0ICAgIHRoaXMuX2FjdHVhbFRlbXBFZGdlcyA9IFtdO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcblx0ICAgIGtleTogXCJfZG9SZW1vdmVOb2Rlc1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9kb1JlbW92ZU5vZGVzKG5vZGVzKSB7XG5cdCAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHRcblx0ICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXHQgICAgICAgIGlmIChuLnVuaXFpZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFxuXHQgICAgICAgIGlmIChfdGhpczIuX25Qb3Nbbi51bmlxaWRdICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIC8vaW4gdGhlIG5vcm1hbCBncmFwaFxuXHQgICAgICAgICAgdmFyIHBvcyA9IF90aGlzMi5fblBvc1tuLnVuaXFpZF07XG5cdCAgICAgICAgICBfdGhpczIuX2xheWVycy5tYWluLnJlbW92ZU5vZGVBdFBvcyhwb3MpO1xuXHQgICAgICAgICAgZGVsZXRlIF90aGlzMi5fblBvc1tuLnVuaXFpZF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vdHJ5IHRvIHJlbW92ZSBmcm9tIHRlbXAgZ3JhcGhcblx0XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMi5fYWN0dWFsVGVtcE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChfdGhpczIuX2FjdHVhbFRlbXBOb2Rlc1tpXSA9PT0gbikge1xuXHQgICAgICAgICAgICAgIF90aGlzMi5fYWN0dWFsVGVtcE5vZGVzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgbi5fX3VuaXFpZCA9IG4udW5pcWlkO1xuXHQgICAgICAgIGRlbGV0ZSBuLnVuaXFpZDtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcIl9kb1JlbW92ZUVkZ2VzXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2RvUmVtb3ZlRWRnZXMoZWRnZXMpIHtcblx0ICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdFxuXHQgICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKGUudW5pcWlkID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XG5cdCAgICAgICAgdmFyIHMgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VTb3VyY2UoZSk7XG5cdCAgICAgICAgdmFyIHQgPSBfZ2VvbXV0aWxzMi5kZWZhdWx0LmVkZ2VUYXJnZXQoZSk7XG5cdFxuXHQgICAgICAgIGRlbGV0ZSAoX3RoaXMzLl9lRGlyc1tzLnVuaXFpZCB8fCBzLl9fdW5pcWlkXSB8fCB7fSlbdC51bmlxaWQgfHwgdC5fX3VuaXFpZF07XG5cdFxuXHQgICAgICAgIGlmIChfdGhpczMuX2VQb3NbZS51bmlxaWRdICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIC8vaW4gdGhlIG5vcm1hbCBncmFwaFxuXHQgICAgICAgICAgdmFyIHBvcyA9IF90aGlzMy5fZVBvc1tlLnVuaXFpZF07XG5cdCAgICAgICAgICBfdGhpczMuX2xheWVycy5tYWluLnJlbW92ZUVkZ2VBdFBvcyhwb3MpO1xuXHQgICAgICAgICAgZGVsZXRlIF90aGlzMy5fZVBvc1tlLnVuaXFpZF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vdHJ5IHRvIHJlbW92ZSBmcm9tIHRlbXAgZ3JhcGhcblx0XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMy5fYWN0dWFsVGVtcEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChfdGhpczMuX2FjdHVhbFRlbXBFZGdlc1tpXSA9PT0gZSkge1xuXHQgICAgICAgICAgICAgIF90aGlzMy5fYWN0dWFsVGVtcEVkZ2VzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgZS5fX3VuaXFpZCA9IGUudW5pcWlkO1xuXHQgICAgICAgIGRlbGV0ZSBlLnVuaXFpZDtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcIl9kb0FkZEVkZ2VzXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2RvQWRkRWRnZXMoKSB7XG5cdCAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXHRcblx0ICAgICAgdGhpcy5fdG9BZGRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgLy9hbHJlYWR5IGFkZGVkIGluIG1haW4gZ3JhcGhcblx0ICAgICAgICBpZiAoX3RoaXM0Ll9lUG9zW2UudW5pcWlkXSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBfdGhpczQuX2RvUmVtb3ZlRWRnZXMoW2VdKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGlmIChlLnVuaXFpZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuXHQgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoaXMgZWRnZSBoYXMgYmVlbiBhbHJlYWR5IGFkZGVkLCBpZiB5b3Ugd2FudCB0byBhZGQgc2FtZSBlZGdlIHR3aWNlLCBjcmVhdGUgbmV3IG9iamVjdCB3aXRoIHNhbWUgcHJvcGVydGllc1wiKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXM0Ll9jaGVja1VuaXFJZChlKTtcblx0XG5cdCAgICAgICAgLy9hZGQgdGhpcyBub2RlIGludG8gdGVtcG9yYXJ5IGNoYXJ0XG5cdFxuXHQgICAgICAgIC8vVE9ETzogTm90IHNvIGVmZmljaWVudCA+PiBjYXVzZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYWRkaW5nIGVkZ2VzIGludG8gdGVtcG9yYXJ5IGdyYXBoXG5cdCAgICAgICAgcHVzaFVuaXF1ZShfdGhpczQuX2FjdHVhbFRlbXBFZGdlcywgZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJfZG9BZGROb2Rlc1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9kb0FkZE5vZGVzKG5vZGVzKSB7XG5cdCAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXHRcblx0ICAgICAgdGhpcy5fdG9BZGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgaWYgKF90aGlzNS5fblBvc1tuLnVuaXFpZF0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgX3RoaXM1Ll9kb1JlbW92ZU5vZGVzKFtuXSk7XG5cdCAgICAgICAgfVxuXHRcblx0ICAgICAgICAvL2FscmVhZHkgYWRkZWRcblx0ICAgICAgICBpZiAobi51bmlxaWQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgY29uc29sZS5lcnJvcihuKTtcblx0ICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGlzIG5vZGUgaGFzIGJlZW4gYWxyZWFkeSBhZGRlZCwgaWYgeW91IHdhbnQgdG8gYWRkIHNhbWUgbm9kZSB0d2ljZSwgY3JlYXRlIG5ldyBvYmplY3Qgd2l0aCBzYW1lIHByb3BlcnRpZXNcIik7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzNS5fY2hlY2tVbmlxSWQobik7XG5cdFxuXHQgICAgICAgIF90aGlzNS5fZURpcnNbbi51bmlxaWRdID0ge307XG5cdFxuXHQgICAgICAgIC8vVE9ETzogTm90IHNvIGVmZmljaWVudCA+PiBjYXVzZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYWRkaW5nIG5vZGVzIGludG8gdGVtcG9yYXJ5IGdyYXBoXG5cdCAgICAgICAgcHVzaFVuaXF1ZShfdGhpczUuX2FjdHVhbFRlbXBOb2Rlcywgbik7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJhZGRFZGdlXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZShlKSB7XG5cdCAgICAgIHZhciBzID0gX2dlb211dGlsczIuZGVmYXVsdC5lZGdlU291cmNlKGUpO1xuXHQgICAgICB2YXIgdCA9IF9nZW9tdXRpbHMyLmRlZmF1bHQuZWRnZVRhcmdldChlKTtcblx0XG5cdCAgICAgIHZhciB0aWQgPSB0LnVuaXFpZCB8fCB0Ll9fdW5pcWlkO1xuXHQgICAgICB2YXIgc2lkID0gcy51bmlxaWQgfHwgcy5fX3VuaXFpZDtcblx0XG5cdCAgICAgIGlmICgodGhpcy5fZURpcnNbc2lkXSB8fCB7fSlbdGlkXSkge1xuXHQgICAgICAgIC8vdGhpcyBlZGdlIHdhcyBhbHJlYWR5IGFkZGVkID4+IHJlbW92ZSBpdFxuXHQgICAgICAgIHRoaXMuX2RvUmVtb3ZlRWRnZXMoW2VdKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKCh0aGlzLl9lRGlyc1t0aWRdIHx8IHt9KVtzaWRdKSB7XG5cdCAgICAgICAgLy9tdXN0IHJlbW92ZSBsaW5lIGFuZCBhZGQgdHdvIGN1cnZlc1xuXHRcblx0ICAgICAgICB0aGlzLl90b0FkZEVkZ2VzLnB1c2godGhpcy5fZURpcnNbdGlkXVtzaWRdKTtcblx0ICAgICAgICB0aGlzLl9kb1JlbW92ZUVkZ2VzKFt0aGlzLl9lRGlyc1t0aWRdW3NpZF1dKTtcblx0XG5cdCAgICAgICAgdGhpcy5fdG9BZGRFZGdlcy5wdXNoKHRoaXMuX2VEaXJzW3NpZF1bdGlkXSA9IGUpO1xuXHRcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdGhpcy5fdG9BZGRFZGdlcy5wdXNoKGUpO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiYWRkTm9kZVwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGUobikge1xuXHQgICAgICB0aGlzLl90b0FkZE5vZGVzLnB1c2gobik7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJyZW1vdmVOb2RlXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTm9kZShuKSB7XG5cdCAgICAgIHRoaXMuX3RvUmVtb3ZlTm9kZXMucHVzaChuKTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInJlbW92ZUVkZ2VcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFZGdlKGUpIHtcblx0ICAgICAgdGhpcy5fdG9SZW1vdmVFZGdlcy5wdXNoKGUpO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiYXBwbHlDaGFuZ2VzXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlDaGFuZ2VzKCkge1xuXHRcblx0ICAgICAgLy9ub3RoaW5nIHRvIGRvXG5cdCAgICAgIGlmICh0aGlzLl90b1JlbW92ZUVkZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl90b1JlbW92ZU5vZGVzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl90b0FkZEVkZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl90b0FkZE5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgICAgICB0aGlzLl9hY3R1YWxUZW1wTm9kZXMgPSB0aGlzLl9sYXllcnMudGVtcCA/IHRoaXMuX2xheWVycy50ZW1wLm5vZGVzIDogW107XG5cdCAgICAgIHRoaXMuX2FjdHVhbFRlbXBFZGdlcyA9IHRoaXMuX2xheWVycy50ZW1wID8gdGhpcy5fbGF5ZXJzLnRlbXAuZWRnZXMgOiBbXTtcblx0XG5cdCAgICAgIHRoaXMuX2RvUmVtb3ZlRWRnZXModGhpcy5fdG9SZW1vdmVFZGdlcyk7XG5cdCAgICAgIHRoaXMuX2RvUmVtb3ZlTm9kZXModGhpcy5fdG9SZW1vdmVOb2Rlcyk7XG5cdCAgICAgIHRoaXMuX2RvQWRkTm9kZXMoKTtcblx0ICAgICAgdGhpcy5fZG9BZGRFZGdlcygpO1xuXHRcblx0ICAgICAgdGhpcy5fdG9BZGRFZGdlcyA9IFtdO1xuXHQgICAgICB0aGlzLl90b0FkZE5vZGVzID0gW107XG5cdCAgICAgIHRoaXMuX3RvUmVtb3ZlRWRnZXMgPSBbXTtcblx0ICAgICAgdGhpcy5fdG9SZW1vdmVOb2RlcyA9IFtdO1xuXHRcblx0ICAgICAgdGhpcy5faW5zZXJ0VGVtcExheWVyKCk7XG5cdCAgICAgIHRoaXMuX2xheWVycy50ZW1wLnNldCh0aGlzLl9hY3R1YWxUZW1wTm9kZXMsIHRoaXMuX2FjdHVhbFRlbXBFZGdlcyk7XG5cdFxuXHQgICAgICB0aGlzLl9kcmF3KCk7XG5cdFxuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICB9XSk7XG5cdFxuXHQgIHJldHVybiBfY2xhc3M7XG5cdH0oKTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9jbGFzcztcblx0O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jY05ldFZpei5qcy5tYXBcbmlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpXG5tb2R1bGUuZXhwb3J0cyA9IGNjTmV0Vml6OyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi44LjZcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlO1xudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93UHJpb3JpdHlXYXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcblxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG5cbi8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHtjcmVhdGVSZWZ9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ0NOZXRWaXogZnJvbSAnY2NuZXR2aXonO1xuXG5jbGFzcyBDQ05ldFZpekNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jYW52YXNFbCA9IGNyZWF0ZVJlZigpO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICB0aGlzLmNjTmV0Vml6LmRyYXcoKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IHtub2RlcywgZWRnZXMsIGxheW91dH0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5jY05ldFZpei5zZXQobm9kZXMsIGVkZ2VzLCBsYXlvdXQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5jY05ldFZpeikge1xuICAgICAgdGhpcy5jY05ldFZpei5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5jY05ldFZpeiA9IG5ldyBDQ05ldFZpeih0aGlzLmNhbnZhc0VsLmN1cnJlbnQsIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gIH1cblxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV3cHJvcHMpIHtcbiAgICBjb25zdCBpc0NoYW5nZUluID0gKHR5cGVzKSA9PlxuICAgICAgdHlwZXMuc29tZSgoa2V5KSA9PiBuZXdwcm9wc1trZXldICE9PSB0aGlzLnByb3BzW2tleV0pO1xuXG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyID0gKCkgPT4gaXNDaGFuZ2VJbihbJ3dpZHRoJywgJ2hlaWdodCcsICdzdHlsZScsICdjbGFzc05hbWUnXSk7XG5cbiAgICBpZiAoaXNDaGFuZ2VJbihbJ29wdGlvbnMnXSkpIHtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICByZXR1cm4gc2hvdWxkUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2hhbmdlSW4oWydub2RlcycsICdlZGdlcycsICdsYXlvdXQnXSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgcmV0dXJuIHNob3VsZFJlbmRlcigpO1xuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRSZW5kZXIoKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmRyYXcoKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2NOZXRWaXoucmVtb3ZlKCk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5kcmF3KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGgsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBoZWlnaHQsXG4gICAgICByZWY6IHRoaXMuY2FudmFzRWxcbiAgICB9KTtcbiAgfVxufVxuXG5DQ05ldFZpekNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxheW91dDogUHJvcFR5cGVzLnN0cmluZyxcbiAgbm9kZXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBlZGdlczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENDTmV0Vml6Q29tcG9uZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X187Il0sInNvdXJjZVJvb3QiOiIifQ==